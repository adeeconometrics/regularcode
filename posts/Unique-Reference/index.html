<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Unique References" /><meta name="author" content="Dave Amiana" /><meta property="og:locale" content="en_US" /><meta name="description" content="Our previous discussion explores the anatomy of pointer types in C and C++ on par with hinting nuances of reference semantics. We discussed the use cases of raw pointers and smart pointers in modern C++ and found that there are degrees of aptness in choosing between automatic resource management over manual resource management. More specifically, we introduced std::unique_ptr&lt;T&gt; and demonstrated some of its functionalities. This article discusses the design goals and implementation of std::unique_ptr&lt;T&gt;. However, instead of discussing the intricacies of the STL implementation in different C++ compiler distributions, we simplify this to express the design goals of a unique reference. At the end of this article, we develop another layer of understanding with the functionalities of unique reference and implement our version of it. Design goals of unique reference Let us list down the requirements we must satisfy for implementing our version of the unique reference. Our implementation must satisfy the following. Must accept any type Automatic resource management Maintain the property of uniqueness Pointer-like interface Our simple version of the std::unique_ptr&lt;T&gt; requires to be explicitly initialized with the object it refers to. Implementation Let us build up our implementation by fulfilling our design requirements one by one. Requirement: Must Accept any Type We begin with the simplest requirement It must take any type. We simply have to add a template parameter to our type (class) for this requirement to suffice this. 1 template&lt;typename T&gt; class unique_reference; That’s it! We satisfied our first requirement. Requirement: Automatic Resource Management This is the elegant solution of the C++ abstraction mechanism that comes in: the answer is Resource Acquisition Is Initialization or RAII. RAII provides guarantees regarding the state of our class. Resource management is tied with class invariance the lifetime of an object. This is achieved by object constructors and destructors which are responsible for initialization and clean-up of resources. 1 2 3 4 5 6 7 8 9 10 template&lt;typename T&gt; class unique_reference{ T* m_ptr{nullptr}; public: unique_reference() = default; ~unique_reference() { delete m_ptr; // seems right, but dangerous! m_ptr = nullptr; } }; The constructor is triggered when an instance of unique_reference is initialized – that is why in other languages like Python, and Swift, these are known as initializers. Meanwhile, destructors are triggered when an instance of unique_reference goes out of scope. Together, they serve our need for automatic resource management that gives us deterministic behavior which guarantees resource management. The deterministic behavior of our reference management gives superior property over implementing garbage collectors which may or may not clean up a piece of resource at the time an object went out of scope. It seems that we managed our resources well. We initialized our pointer to nullptr upon construction and de-initialized it by deleting the contents of m_ptr. However, there is a subtle element of trouble that we still might leak our resources, even after setting m_ptr = nullptr. The compiler will not warn you with this, but you are shooting yourself in the foot. To resolve this, we need to re-think our mental model of unique reference. At the time our object goes out of scope we want to destroy the object, not necessarily delete them abruptly. So we call the object’s destructor ~T(). Note that types that do not have user-provided destructors such as primitives are marked as _ trivial destructors _, which is why ~T() is valid for primitives. 1 2 3 4 5 6 7 8 9 10 11 12 template&lt;typename T&gt; class unique_reference{ T* m_ptr{nullptr}; public: unique_reference() = default; ~unique_reference(){ if(m_ptr != nullptr){ m_ptr-&gt;~T(); m_ptr = nullptr; } } }; We’re doing great. Let’s keep going! Requirement: Maintain Property of Uniqueness For this, we want our unique reference to be able to transfer its ownership inside a function or a class when need be. By implementing the mechanism of transference, we need to maintain the property of uniqueness. We do so by incorporating move semantics. There are two parts for enabling moveable ownership, our unique reference has to be: move constructible, and move assignable. Let us work with our moveable constructors first. 1 2 3 explicit unique_reference(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { std::swap(other.m_ptr, m_ptr); } Let us walk through what we are actually saying with the above snippet of code. First, we need to mark our constructors as explicit to avoid unexpected implicit conversions. Then we make use of _ rvalue reference _ for our parameter which marks our class as move constructible. But before we handle move construction, we have to guarantee that upon construction we will not throw exceptions so we mark our noexcept specifier. The body of our function is very trivial to implement. We want to take all the resources of our moved-from reference (other), and swap it with our moved-in object (this). That said, the second requirement (move assignable) is equally trivial to implement. We simply need to overload the assignment operator. 1 2 3 unique_reference &amp;operator=(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { std::swap(other.m_ptr, m_ptr); } We are essentially repeating the body of our assignment and constructor, so for consistency, let us implement a little helper function we declare in private which shall be responsible for swapping the objects. 1 2 3 4 private: void swap(unique_reference&lt;T&gt; &amp;other) noexcept { std::swap(m_ptr, other.m_ptr); } Effectively, this results to: 1 2 3 4 5 6 7 explicit unique_reference(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } / ... / unique_reference&amp;operator=(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } Since we are discussing the constructors and assignment operators it is a good point to note about how to suppress them and why. The reason we want to suppress constructors are two folds: we want to explicitly mention that we do not intend this to happen, and we want the compiler to check if users try to access such modalities. To do this, we simply write: 1 2 explicit unique_reference(const unique_reference&lt;T&gt; &amp;Type) = delete; unique_reference&amp;operator=(const unique_reference&lt;T&gt; &amp;other) = delete; Here, we suppressed copy-assignment and copy-construction since copying will defy the meaning of being unique. Requirement: Pointer-like Interface We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer. Recall that a pointer can be dereferenced with * and -&gt; operators. And we need &amp; operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write: 1 2 3 T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(unique_reference&lt;T&gt; &amp;other) { return other.m_ptr; } Let us walk through the three lines. The first line returns a reference of *(this-&gt;m_ptr) which means that the content of m_ptr is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to m_ptr’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. Recall that a pointer has its own location in memory separate from the entities it points to. Putting it all together: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 template &lt;typename T&gt; class unique_reference { public: T *m_ptr{nullptr}; explicit unique_reference() = default; explicit unique_reference(const unique_reference&lt;T&gt; &amp;Type) = delete; explicit unique_reference(T *Type) : m_ptr(Type) {} explicit unique_reference(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } unique_reference &amp;operator=(const unique_reference&lt;T&gt; &amp;other) = delete; unique_reference &amp;operator=(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } ~unique_reference() { if (m_ptr != nullptr) { m_ptr-&gt;~T(); m_ptr = nullptr; } } T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(unique_reference&lt;T&gt; &amp;other) { return other.m_ptr; } private: void swap(unique_reference&lt;T&gt; &amp;other) noexcept { std::swap(m_ptr, other.m_ptr); } }; Test Cases Time to see if we satisfied our design requirements: Summary We fleshed out our design requirements and implemented our version of the unique reference to satisfy what we intend to do with unique references. Upon testing, we found that it sufficiently did what we want it to do: we now have the first piece of our automatic resource management! Since that we implemented a simple unique reference class, try to think about how we can extend this for an array-like interface as your homework. Doing this part on your own gives you room to re-think what we did with our unique_reference. Have fun hacking! References Wikipedia contributors. (2021, May 21). Resource acquisition is initialization. In Wikipedia, The Free Encyclopedia. Retrieved 07:06, August 17, 2021, from https://en.wikipedia.org/w/index.php?title=Resource_acquisition_is_initialization&amp;oldid=1024395395. Python (2021). Python Initialization Configuration Reference Manual. https://docs.python.org/3/c-api/init_config.html. Swift (2021). Swift Language Guide. https://docs.swift.org/swift-book/LanguageGuide/Initialization.html. cppreference.com (2021). Destructors. https://en.cppreference.com/w/cpp/language/destructor. cppreference.com (2021). Fundamental types. https://en.cppreference.com/w/cpp/language/types. StackOverflow (2010). What is move semantics? https://stackoverflow.com/questions/3106110/what-is-move-semantics. StackOverflow (2009). What does the explicit keyword mean? https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean. Triangles (2019). C++ rvalue references and move semantics for beginners. https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners. Amiana, D. (2021). Pointers and References: Design Goals and Use Cases. https://dcode.hashnode.dev/pointers-and-references-design-goals-and-use-cases." /><meta property="og:description" content="Our previous discussion explores the anatomy of pointer types in C and C++ on par with hinting nuances of reference semantics. We discussed the use cases of raw pointers and smart pointers in modern C++ and found that there are degrees of aptness in choosing between automatic resource management over manual resource management. More specifically, we introduced std::unique_ptr&lt;T&gt; and demonstrated some of its functionalities. This article discusses the design goals and implementation of std::unique_ptr&lt;T&gt;. However, instead of discussing the intricacies of the STL implementation in different C++ compiler distributions, we simplify this to express the design goals of a unique reference. At the end of this article, we develop another layer of understanding with the functionalities of unique reference and implement our version of it. Design goals of unique reference Let us list down the requirements we must satisfy for implementing our version of the unique reference. Our implementation must satisfy the following. Must accept any type Automatic resource management Maintain the property of uniqueness Pointer-like interface Our simple version of the std::unique_ptr&lt;T&gt; requires to be explicitly initialized with the object it refers to. Implementation Let us build up our implementation by fulfilling our design requirements one by one. Requirement: Must Accept any Type We begin with the simplest requirement It must take any type. We simply have to add a template parameter to our type (class) for this requirement to suffice this. 1 template&lt;typename T&gt; class unique_reference; That’s it! We satisfied our first requirement. Requirement: Automatic Resource Management This is the elegant solution of the C++ abstraction mechanism that comes in: the answer is Resource Acquisition Is Initialization or RAII. RAII provides guarantees regarding the state of our class. Resource management is tied with class invariance the lifetime of an object. This is achieved by object constructors and destructors which are responsible for initialization and clean-up of resources. 1 2 3 4 5 6 7 8 9 10 template&lt;typename T&gt; class unique_reference{ T* m_ptr{nullptr}; public: unique_reference() = default; ~unique_reference() { delete m_ptr; // seems right, but dangerous! m_ptr = nullptr; } }; The constructor is triggered when an instance of unique_reference is initialized – that is why in other languages like Python, and Swift, these are known as initializers. Meanwhile, destructors are triggered when an instance of unique_reference goes out of scope. Together, they serve our need for automatic resource management that gives us deterministic behavior which guarantees resource management. The deterministic behavior of our reference management gives superior property over implementing garbage collectors which may or may not clean up a piece of resource at the time an object went out of scope. It seems that we managed our resources well. We initialized our pointer to nullptr upon construction and de-initialized it by deleting the contents of m_ptr. However, there is a subtle element of trouble that we still might leak our resources, even after setting m_ptr = nullptr. The compiler will not warn you with this, but you are shooting yourself in the foot. To resolve this, we need to re-think our mental model of unique reference. At the time our object goes out of scope we want to destroy the object, not necessarily delete them abruptly. So we call the object’s destructor ~T(). Note that types that do not have user-provided destructors such as primitives are marked as _ trivial destructors _, which is why ~T() is valid for primitives. 1 2 3 4 5 6 7 8 9 10 11 12 template&lt;typename T&gt; class unique_reference{ T* m_ptr{nullptr}; public: unique_reference() = default; ~unique_reference(){ if(m_ptr != nullptr){ m_ptr-&gt;~T(); m_ptr = nullptr; } } }; We’re doing great. Let’s keep going! Requirement: Maintain Property of Uniqueness For this, we want our unique reference to be able to transfer its ownership inside a function or a class when need be. By implementing the mechanism of transference, we need to maintain the property of uniqueness. We do so by incorporating move semantics. There are two parts for enabling moveable ownership, our unique reference has to be: move constructible, and move assignable. Let us work with our moveable constructors first. 1 2 3 explicit unique_reference(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { std::swap(other.m_ptr, m_ptr); } Let us walk through what we are actually saying with the above snippet of code. First, we need to mark our constructors as explicit to avoid unexpected implicit conversions. Then we make use of _ rvalue reference _ for our parameter which marks our class as move constructible. But before we handle move construction, we have to guarantee that upon construction we will not throw exceptions so we mark our noexcept specifier. The body of our function is very trivial to implement. We want to take all the resources of our moved-from reference (other), and swap it with our moved-in object (this). That said, the second requirement (move assignable) is equally trivial to implement. We simply need to overload the assignment operator. 1 2 3 unique_reference &amp;operator=(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { std::swap(other.m_ptr, m_ptr); } We are essentially repeating the body of our assignment and constructor, so for consistency, let us implement a little helper function we declare in private which shall be responsible for swapping the objects. 1 2 3 4 private: void swap(unique_reference&lt;T&gt; &amp;other) noexcept { std::swap(m_ptr, other.m_ptr); } Effectively, this results to: 1 2 3 4 5 6 7 explicit unique_reference(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } / ... / unique_reference&amp;operator=(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } Since we are discussing the constructors and assignment operators it is a good point to note about how to suppress them and why. The reason we want to suppress constructors are two folds: we want to explicitly mention that we do not intend this to happen, and we want the compiler to check if users try to access such modalities. To do this, we simply write: 1 2 explicit unique_reference(const unique_reference&lt;T&gt; &amp;Type) = delete; unique_reference&amp;operator=(const unique_reference&lt;T&gt; &amp;other) = delete; Here, we suppressed copy-assignment and copy-construction since copying will defy the meaning of being unique. Requirement: Pointer-like Interface We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer. Recall that a pointer can be dereferenced with * and -&gt; operators. And we need &amp; operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write: 1 2 3 T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(unique_reference&lt;T&gt; &amp;other) { return other.m_ptr; } Let us walk through the three lines. The first line returns a reference of *(this-&gt;m_ptr) which means that the content of m_ptr is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to m_ptr’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. Recall that a pointer has its own location in memory separate from the entities it points to. Putting it all together: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 template &lt;typename T&gt; class unique_reference { public: T *m_ptr{nullptr}; explicit unique_reference() = default; explicit unique_reference(const unique_reference&lt;T&gt; &amp;Type) = delete; explicit unique_reference(T *Type) : m_ptr(Type) {} explicit unique_reference(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } unique_reference &amp;operator=(const unique_reference&lt;T&gt; &amp;other) = delete; unique_reference &amp;operator=(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } ~unique_reference() { if (m_ptr != nullptr) { m_ptr-&gt;~T(); m_ptr = nullptr; } } T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(unique_reference&lt;T&gt; &amp;other) { return other.m_ptr; } private: void swap(unique_reference&lt;T&gt; &amp;other) noexcept { std::swap(m_ptr, other.m_ptr); } }; Test Cases Time to see if we satisfied our design requirements: Summary We fleshed out our design requirements and implemented our version of the unique reference to satisfy what we intend to do with unique references. Upon testing, we found that it sufficiently did what we want it to do: we now have the first piece of our automatic resource management! Since that we implemented a simple unique reference class, try to think about how we can extend this for an array-like interface as your homework. Doing this part on your own gives you room to re-think what we did with our unique_reference. Have fun hacking! References Wikipedia contributors. (2021, May 21). Resource acquisition is initialization. In Wikipedia, The Free Encyclopedia. Retrieved 07:06, August 17, 2021, from https://en.wikipedia.org/w/index.php?title=Resource_acquisition_is_initialization&amp;oldid=1024395395. Python (2021). Python Initialization Configuration Reference Manual. https://docs.python.org/3/c-api/init_config.html. Swift (2021). Swift Language Guide. https://docs.swift.org/swift-book/LanguageGuide/Initialization.html. cppreference.com (2021). Destructors. https://en.cppreference.com/w/cpp/language/destructor. cppreference.com (2021). Fundamental types. https://en.cppreference.com/w/cpp/language/types. StackOverflow (2010). What is move semantics? https://stackoverflow.com/questions/3106110/what-is-move-semantics. StackOverflow (2009). What does the explicit keyword mean? https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean. Triangles (2019). C++ rvalue references and move semantics for beginners. https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners. Amiana, D. (2021). Pointers and References: Design Goals and Use Cases. https://dcode.hashnode.dev/pointers-and-references-design-goals-and-use-cases." /><link rel="canonical" href="https://adeeconometrics.github.io//posts/Unique-Reference/" /><meta property="og:url" content="https://adeeconometrics.github.io//posts/Unique-Reference/" /><meta property="og:site_name" content="Dave Amiana" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-17T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Unique References" /><meta name="twitter:site" content="@iamdeb25" /><meta name="twitter:creator" content="@Dave Amiana" /><meta name="google-site-verification" content="google-site-verification=28bVbRErS2VwJaonXuu3GbqmRlyNvizt6I00B2kQh88" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Dave Amiana"},"dateModified":"2022-10-22T22:11:50+08:00","datePublished":"2021-08-17T00:00:00+08:00","description":"Our previous discussion explores the anatomy of pointer types in C and C++ on par with hinting nuances of reference semantics. We discussed the use cases of raw pointers and smart pointers in modern C++ and found that there are degrees of aptness in choosing between automatic resource management over manual resource management. More specifically, we introduced std::unique_ptr&lt;T&gt; and demonstrated some of its functionalities. This article discusses the design goals and implementation of std::unique_ptr&lt;T&gt;. However, instead of discussing the intricacies of the STL implementation in different C++ compiler distributions, we simplify this to express the design goals of a unique reference. At the end of this article, we develop another layer of understanding with the functionalities of unique reference and implement our version of it. Design goals of unique reference Let us list down the requirements we must satisfy for implementing our version of the unique reference. Our implementation must satisfy the following. Must accept any type Automatic resource management Maintain the property of uniqueness Pointer-like interface Our simple version of the std::unique_ptr&lt;T&gt; requires to be explicitly initialized with the object it refers to. Implementation Let us build up our implementation by fulfilling our design requirements one by one. Requirement: Must Accept any Type We begin with the simplest requirement It must take any type. We simply have to add a template parameter to our type (class) for this requirement to suffice this. 1 template&lt;typename T&gt; class unique_reference; That’s it! We satisfied our first requirement. Requirement: Automatic Resource Management This is the elegant solution of the C++ abstraction mechanism that comes in: the answer is Resource Acquisition Is Initialization or RAII. RAII provides guarantees regarding the state of our class. Resource management is tied with class invariance the lifetime of an object. This is achieved by object constructors and destructors which are responsible for initialization and clean-up of resources. 1 2 3 4 5 6 7 8 9 10 template&lt;typename T&gt; class unique_reference{ T* m_ptr{nullptr}; public: unique_reference() = default; ~unique_reference() { delete m_ptr; // seems right, but dangerous! m_ptr = nullptr; } }; The constructor is triggered when an instance of unique_reference is initialized – that is why in other languages like Python, and Swift, these are known as initializers. Meanwhile, destructors are triggered when an instance of unique_reference goes out of scope. Together, they serve our need for automatic resource management that gives us deterministic behavior which guarantees resource management. The deterministic behavior of our reference management gives superior property over implementing garbage collectors which may or may not clean up a piece of resource at the time an object went out of scope. It seems that we managed our resources well. We initialized our pointer to nullptr upon construction and de-initialized it by deleting the contents of m_ptr. However, there is a subtle element of trouble that we still might leak our resources, even after setting m_ptr = nullptr. The compiler will not warn you with this, but you are shooting yourself in the foot. To resolve this, we need to re-think our mental model of unique reference. At the time our object goes out of scope we want to destroy the object, not necessarily delete them abruptly. So we call the object’s destructor ~T(). Note that types that do not have user-provided destructors such as primitives are marked as _ trivial destructors _, which is why ~T() is valid for primitives. 1 2 3 4 5 6 7 8 9 10 11 12 template&lt;typename T&gt; class unique_reference{ T* m_ptr{nullptr}; public: unique_reference() = default; ~unique_reference(){ if(m_ptr != nullptr){ m_ptr-&gt;~T(); m_ptr = nullptr; } } }; We’re doing great. Let’s keep going! Requirement: Maintain Property of Uniqueness For this, we want our unique reference to be able to transfer its ownership inside a function or a class when need be. By implementing the mechanism of transference, we need to maintain the property of uniqueness. We do so by incorporating move semantics. There are two parts for enabling moveable ownership, our unique reference has to be: move constructible, and move assignable. Let us work with our moveable constructors first. 1 2 3 explicit unique_reference(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { std::swap(other.m_ptr, m_ptr); } Let us walk through what we are actually saying with the above snippet of code. First, we need to mark our constructors as explicit to avoid unexpected implicit conversions. Then we make use of _ rvalue reference _ for our parameter which marks our class as move constructible. But before we handle move construction, we have to guarantee that upon construction we will not throw exceptions so we mark our noexcept specifier. The body of our function is very trivial to implement. We want to take all the resources of our moved-from reference (other), and swap it with our moved-in object (this). That said, the second requirement (move assignable) is equally trivial to implement. We simply need to overload the assignment operator. 1 2 3 unique_reference &amp;operator=(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { std::swap(other.m_ptr, m_ptr); } We are essentially repeating the body of our assignment and constructor, so for consistency, let us implement a little helper function we declare in private which shall be responsible for swapping the objects. 1 2 3 4 private: void swap(unique_reference&lt;T&gt; &amp;other) noexcept { std::swap(m_ptr, other.m_ptr); } Effectively, this results to: 1 2 3 4 5 6 7 explicit unique_reference(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } / ... / unique_reference&amp;operator=(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } Since we are discussing the constructors and assignment operators it is a good point to note about how to suppress them and why. The reason we want to suppress constructors are two folds: we want to explicitly mention that we do not intend this to happen, and we want the compiler to check if users try to access such modalities. To do this, we simply write: 1 2 explicit unique_reference(const unique_reference&lt;T&gt; &amp;Type) = delete; unique_reference&amp;operator=(const unique_reference&lt;T&gt; &amp;other) = delete; Here, we suppressed copy-assignment and copy-construction since copying will defy the meaning of being unique. Requirement: Pointer-like Interface We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer. Recall that a pointer can be dereferenced with * and -&gt; operators. And we need &amp; operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write: 1 2 3 T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(unique_reference&lt;T&gt; &amp;other) { return other.m_ptr; } Let us walk through the three lines. The first line returns a reference of *(this-&gt;m_ptr) which means that the content of m_ptr is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to m_ptr’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. Recall that a pointer has its own location in memory separate from the entities it points to. Putting it all together: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 template &lt;typename T&gt; class unique_reference { public: T *m_ptr{nullptr}; explicit unique_reference() = default; explicit unique_reference(const unique_reference&lt;T&gt; &amp;Type) = delete; explicit unique_reference(T *Type) : m_ptr(Type) {} explicit unique_reference(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } unique_reference &amp;operator=(const unique_reference&lt;T&gt; &amp;other) = delete; unique_reference &amp;operator=(unique_reference&lt;T&gt; &amp;&amp;other) noexcept { other.swap(*this); } ~unique_reference() { if (m_ptr != nullptr) { m_ptr-&gt;~T(); m_ptr = nullptr; } } T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(unique_reference&lt;T&gt; &amp;other) { return other.m_ptr; } private: void swap(unique_reference&lt;T&gt; &amp;other) noexcept { std::swap(m_ptr, other.m_ptr); } }; Test Cases Time to see if we satisfied our design requirements: Summary We fleshed out our design requirements and implemented our version of the unique reference to satisfy what we intend to do with unique references. Upon testing, we found that it sufficiently did what we want it to do: we now have the first piece of our automatic resource management! Since that we implemented a simple unique reference class, try to think about how we can extend this for an array-like interface as your homework. Doing this part on your own gives you room to re-think what we did with our unique_reference. Have fun hacking! References Wikipedia contributors. (2021, May 21). Resource acquisition is initialization. In Wikipedia, The Free Encyclopedia. Retrieved 07:06, August 17, 2021, from https://en.wikipedia.org/w/index.php?title=Resource_acquisition_is_initialization&amp;oldid=1024395395. Python (2021). Python Initialization Configuration Reference Manual. https://docs.python.org/3/c-api/init_config.html. Swift (2021). Swift Language Guide. https://docs.swift.org/swift-book/LanguageGuide/Initialization.html. cppreference.com (2021). Destructors. https://en.cppreference.com/w/cpp/language/destructor. cppreference.com (2021). Fundamental types. https://en.cppreference.com/w/cpp/language/types. StackOverflow (2010). What is move semantics? https://stackoverflow.com/questions/3106110/what-is-move-semantics. StackOverflow (2009). What does the explicit keyword mean? https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean. Triangles (2019). C++ rvalue references and move semantics for beginners. https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners. Amiana, D. (2021). Pointers and References: Design Goals and Use Cases. https://dcode.hashnode.dev/pointers-and-references-design-goals-and-use-cases.","headline":"Unique References","mainEntityOfPage":{"@type":"WebPage","@id":"https://adeeconometrics.github.io//posts/Unique-Reference/"},"url":"https://adeeconometrics.github.io//posts/Unique-Reference/"}</script><title>Unique References | Dave Amiana</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dave Amiana"><meta name="application-name" content="Dave Amiana"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0M61FBNQ0K"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0M61FBNQ0K'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/profile-picture.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dave Amiana</a></div><div class="site-subtitle font-italic">Open-source and Enterprise Software Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/adeeconometrics" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/dave-amiana/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['amiana.dave','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Unique References</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Unique References</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Dave Amiana </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Aug 17, 2021, 12:00 AM +0800" prep="on" > Aug 17, 2021 <i class="unloaded">2021-08-17T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 22, 2022, 10:11 PM +0800" prefix="Updated " > Oct 22, 2022 <i class="unloaded">2022-10-22T22:11:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1481 words">8 min</span></div></div><div class="post-content"><p>Our previous discussion explores the anatomy of pointer types in C and C++ on par with hinting nuances of reference semantics. We discussed the use cases of raw pointers and smart pointers in modern C++ and found that there are degrees of aptness in choosing between automatic resource management over manual resource management. More specifically, we introduced <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt;</code> and demonstrated some of its functionalities.</p><p>This article discusses the design goals and implementation of <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt;</code>. However, instead of discussing the intricacies of the STL implementation in different C++ compiler distributions, we simplify this to express the design goals of a unique reference.</p><p>At the end of this article, we develop another layer of understanding with the functionalities of unique reference and implement our version of it.</p><h3 id="design-goals-of-unique-reference">Design goals of unique reference</h3><p>Let us list down the requirements we must satisfy for implementing our version of the unique reference. Our implementation must satisfy the following.</p><ul><li>Must accept any type<li>Automatic resource management<li>Maintain the property of uniqueness<li>Pointer-like interface</ul><p>Our simple version of the <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt;</code> requires to be explicitly initialized with the object it refers to.</p><h3 id="implementation">Implementation</h3><p>Let us build up our implementation by fulfilling our design requirements one by one.</p><h4 id="requirement-must-accept-any-type">Requirement: Must Accept any Type</h4><p>We begin with the simplest requirement <em>It must take any type</em>. We simply have to add a template parameter to our type (class) for this requirement to suffice this.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">unique_reference</span><span class="p">;</span>
</pre></table></code></div></div><p>That’s it! We satisfied our first requirement.</p><h4 id="requirement-automatic-resource-management">Requirement: Automatic Resource Management</h4><p>This is the elegant solution of the C++ abstraction mechanism that comes in: the answer is <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"><em>Resource Acquisition Is Initialization</em></a> or RAII.</p><p>RAII provides guarantees regarding the state of our class. Resource management is tied with class invariance the lifetime of an object. This is achieved by object constructors and destructors which are responsible for initialization and clean-up of resources.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">unique_reference</span><span class="p">{</span>
<span class="n">T</span><span class="o">*</span> <span class="n">m_ptr</span><span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">unique_reference</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="o">~</span><span class="n">unique_reference</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">m_ptr</span><span class="p">;</span> <span class="c1">// seems right, but dangerous!</span>
    <span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>The constructor is triggered when an instance of <code class="language-plaintext highlighter-rouge">unique_reference</code> is initialized – that is why in other languages like <a href="https://docs.python.org/3/c-api/init_config.html">Python</a>, and <a href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html">Swift</a>, these are known as <em>initializers</em>. Meanwhile, destructors are triggered when an instance of <code class="language-plaintext highlighter-rouge">unique_reference</code> goes out of scope. Together, they serve our need for automatic resource management that gives us deterministic behavior which guarantees resource management. The deterministic behavior of our reference management gives superior property over implementing garbage collectors which may or may not clean up a piece of resource at the time an object went out of scope.</p><p>It seems that we managed our resources well. We initialized our pointer to <code class="language-plaintext highlighter-rouge">nullptr</code> upon construction and de-initialized it by deleting the contents of <code class="language-plaintext highlighter-rouge">m_ptr</code>. However, there is a subtle element of trouble that we still might leak our resources, even after setting <code class="language-plaintext highlighter-rouge">m_ptr = nullptr</code>. The compiler will not warn you with this, but you are shooting yourself in the foot.</p><p>To resolve this, we need to re-think our mental model of unique reference. At the time our object goes out of scope we want to destroy the object, not necessarily <em>delete</em> them abruptly. So we call the object’s destructor <code class="language-plaintext highlighter-rouge">~T()</code>.</p><p>Note that types that do not have user-provided destructors such as primitives are marked as _ <a href="https://en.cppreference.com/w/cpp/language/destructor">trivial destructors</a> _, which is why <code class="language-plaintext highlighter-rouge">~T()</code> is valid for <a href="https://en.cppreference.com/w/cpp/language/types">primitives</a>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">unique_reference</span><span class="p">{</span>
<span class="n">T</span><span class="o">*</span> <span class="n">m_ptr</span><span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">unique_reference</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  	<span class="o">~</span><span class="n">unique_reference</span><span class="p">(){</span>
      <span class="k">if</span><span class="p">(</span><span class="n">m_ptr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span>
  	    <span class="n">m_ptr</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>
        <span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>We’re doing great. Let’s keep going!</p><h4 id="requirement-maintain-property-of-uniqueness">Requirement: Maintain Property of Uniqueness</h4><p>For this, we want our unique reference to be able to transfer its ownership inside a function or a class when need be. By implementing the mechanism of transference, we need to maintain the property of uniqueness. We do so by incorporating <a href="https://bityl.co/8Fgd">move semantics</a>. There are two parts for enabling moveable ownership, our unique reference has to be: move constructible, and move assignable.</p><p>Let us work with our moveable constructors first.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="k">explicit</span> <span class="nf">unique_reference</span><span class="p">(</span><span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">,</span> <span class="n">m_ptr</span><span class="p">);</span>
  <span class="p">}</span>
</pre></table></code></div></div><p>Let us walk through what we are actually saying with the above snippet of code. First, we need to mark our constructors as <code class="language-plaintext highlighter-rouge">explicit</code> to avoid <a href="https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean">unexpected implicit conversions</a>. Then we make use of _ <a href="https://bityl.co/8G2V">rvalue reference</a> _ for our parameter which marks our class as move constructible. But before we handle move construction, we have to guarantee that upon construction we will not throw exceptions so we mark our <code class="language-plaintext highlighter-rouge">noexcept</code> specifier.</p><p>The body of our function is very trivial to implement. We want to take all the resources of our moved-from reference (<code class="language-plaintext highlighter-rouge">other</code>), and swap it with our moved-in object (<code class="language-plaintext highlighter-rouge">this</code>). That said, the second requirement (move assignable) is equally trivial to implement. We simply need to overload the assignment operator.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="n">unique_reference</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">,</span> <span class="n">m_ptr</span><span class="p">);</span>
  <span class="p">}</span>
</pre></table></code></div></div><p>We are essentially repeating the body of our assignment and constructor, so for consistency, let us implement a little helper function we declare in private which shall be responsible for swapping the objects.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nl">private:</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_ptr</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">);</span>
  <span class="p">}</span>
</pre></table></code></div></div><p>Effectively, this results to:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>  <span class="k">explicit</span> <span class="nf">unique_reference</span><span class="p">(</span><span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">other</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="o">/</span> <span class="p">...</span> <span class="o">/</span>
  <span class="n">unique_reference</span><span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">other</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
</pre></table></code></div></div><p>Since we are discussing the constructors and assignment operators it is a good point to note about how to suppress them and why. The reason we want to suppress constructors are two folds: we want to explicitly mention that we do not intend this to happen, and we want the compiler to check if users try to access such modalities.</p><p>To do this, we simply write:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  <span class="k">explicit</span> <span class="n">unique_reference</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Type</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">unique_reference</span><span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</pre></table></code></div></div><p>Here, we suppressed copy-assignment and copy-construction since copying will defy the meaning of being unique.</p><h4 id="requirement-pointer-like-interface">Requirement: Pointer-like Interface</h4><p>We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer.</p><p>Recall that a pointer can be dereferenced with <code class="language-plaintext highlighter-rouge">*</code> and <code class="language-plaintext highlighter-rouge">-&gt;</code> operators. And we need <code class="language-plaintext highlighter-rouge">&amp;</code> operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span> <span class="o">*</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&amp;</span><span class="p">(</span><span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">other</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
</pre></table></code></div></div><p>Let us walk through the three lines.</p><p>The first line returns a reference of <code class="language-plaintext highlighter-rouge">*(this-&gt;m_ptr)</code> which means that the content of <code class="language-plaintext highlighter-rouge">m_ptr</code> is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to <code class="language-plaintext highlighter-rouge">m_ptr</code>’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. <a href="https://dcode.hashnode.dev/pointers-and-references-design-goals-and-use-cases">Recall</a> that a pointer has its own location in memory separate from the entities it points to.</p><h3 id="putting-it-all-together">Putting it all together:</h3><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">unique_reference</span> <span class="p">{</span>

<span class="nl">public:</span>
  <span class="n">T</span> <span class="o">*</span><span class="n">m_ptr</span><span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
  <span class="k">explicit</span> <span class="n">unique_reference</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">explicit</span> <span class="n">unique_reference</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Type</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="k">explicit</span> <span class="nf">unique_reference</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">Type</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_ptr</span><span class="p">(</span><span class="n">Type</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">explicit</span> <span class="nf">unique_reference</span><span class="p">(</span><span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">other</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">unique_reference</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">unique_reference</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">other</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">unique_reference</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_ptr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">m_ptr</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>
      <span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span> <span class="o">*</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&amp;</span><span class="p">(</span><span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">other</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">unique_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_ptr</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="test-cases">Test Cases</h3><p>Time to see if we satisfied our design requirements:</p><iframe height="700px" width="100%" src="https://replit.com/@delvinjohn/UniqueReference?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe><h3 id="summary">Summary</h3><p>We fleshed out our design requirements and implemented our version of the unique reference to satisfy what we intend to do with unique references. Upon testing, we found that it sufficiently did what we want it to do: we now have the first piece of our automatic resource management!</p><p>Since that we implemented a simple unique reference class, try to think about how we can extend this for an array-like interface as your homework. Doing this part on your own gives you room to re-think what we did with our <code class="language-plaintext highlighter-rouge">unique_reference</code>.</p><p>Have fun hacking!</p><hr /><h3 id="references">References</h3><ul><li><p>Wikipedia contributors. (2021, May 21). Resource acquisition is initialization. In Wikipedia, The Free Encyclopedia. Retrieved 07:06, August 17, 2021, from https://en.wikipedia.org/w/index.php?title=Resource_acquisition_is_initialization&amp;oldid=1024395395.</p><li><p>Python (2021). Python Initialization Configuration Reference Manual. https://docs.python.org/3/c-api/init_config.html.</p><li><p>Swift (2021). Swift Language Guide. https://docs.swift.org/swift-book/LanguageGuide/Initialization.html.</p><li><p>cppreference.com (2021). Destructors. https://en.cppreference.com/w/cpp/language/destructor.</p><li><p>cppreference.com (2021). Fundamental types. https://en.cppreference.com/w/cpp/language/types.</p><li><p>StackOverflow (2010). What is move semantics? https://stackoverflow.com/questions/3106110/what-is-move-semantics.</p><li><p>StackOverflow (2009). What does the explicit keyword mean? https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean.</p><li><p>Triangles (2019). C++ rvalue references and move semantics for beginners. https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners.</p><li><p>Amiana, D. (2021). Pointers and References: Design Goals and Use Cases. https://dcode.hashnode.dev/pointers-and-references-design-goals-and-use-cases.</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a>, <a href='/categories/computer-science/'>Computer Science</a>, <a href='/categories/c/'>C++</a>, <a href='/categories/ownership-semantics/'>Ownership Semantics</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/programming/" class="post-tag no-text-decoration" >programming</a> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/ownership-semantics/" class="post-tag no-text-decoration" >Ownership Semantics</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Unique References - Dave Amiana&url=https://adeeconometrics.github.io//posts/Unique-Reference/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Unique References - Dave Amiana&u=https://adeeconometrics.github.io//posts/Unique-Reference/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Unique References - Dave Amiana&url=https://adeeconometrics.github.io//posts/Unique-Reference/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/On-Pointer-Types/">On Pointer Types</a><li><a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/">Pointers and References: Design Goals and Use Cases</a><li><a href="/posts/Unique-Reference/">Unique References</a><li><a href="/posts/Shared-Reference/">Shared References</a><li><a href="/posts/Weak-Reference/">Weak References</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/On-Pointer-Types/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>On Pointer Types</h3><div class="text-muted small"><p> In this article, I aim to introduce the concept and motivation behind using pointers. There are breeds of C++ developers that only use smart pointers for safety reasons, others that only use raw po...</p></div></div></a></div><div class="card"> <a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Pointers and References: Design Goals and Use Cases</h3><div class="text-muted small"><p> At first, it seems that C++ makes things more complicated by introducing yet another layer of abstraction. References seem to encapsulate the same set of functionalities as pointers. Both of these ...</p></div></div></a></div><div class="card"> <a href="/posts/Shared-Reference/"><div class="card-body"> <span class="timeago small" > Aug 20, 2021 <i class="unloaded">2021-08-20T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Shared References</h3><div class="text-muted small"><p> In our previous discussion, we fleshed out the design requirements and took action into servicing them. In the same way, this article aims to flesh out the design requirement for shared reference. ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/" class="btn btn-outline-primary" prompt="Older"><p>Pointers and References: Design Goals and Use Cases</p></a> <a href="/posts/Shared-Reference/" class="btn btn-outline-primary" prompt="Newer"><p>Shared References</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/iamdeb25">Dave Amiana</a>.</p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://adeeconometrics.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
