<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Recursion is Recursion" /><meta name="author" content="Dave Amiana" /><meta property="og:locale" content="en_US" /><meta name="description" content="Let’s talk about one of the cornerstones of Computer Science The idea of recursion has a dedicated field in Computer Science called Recursion theory, since we can’t possibly cover the entirety of this field, we will just go over some of the key features that most computer science people have grown and love. The idea that self-referent entities can reproduce themselves resonates almost entirely in Computer Science. Let’s take simple examples and realize the elegance of recursion. Consider the \(n!\) function. [n! = n_k \times … \times n_1 \times n_0\ \ k\in \mathbb{N}] Another way of expressing this function is: [\operatorname {fact} (n)={\begin{cases}1&amp;{\mbox{if }}n=0 \\ n\cdot \operatorname {fact} (n-1)&amp;{\mbox{if }} n&gt;0 \end{cases}}] The computation of a factorial function takes in a number and binds that number with the resolution of a factorial function with a number - 1. Consider the pseudocode snippet below: 1 2 3 function factorial(int:a): if a == 0 return 1 return a * factorial(a-1) Let’s implement the recursive function using a while-loop – this approach is called iterative. 1 2 3 4 5 function factorial(int: a): int result = 1 while a &gt; 1: result *= a a -= 1 Let’s break down this code a little bit. Recursive function call mainly has two parts: a base case, and an inductive case. The base case specifies when the recursion reaches a halt while the inductive case sets the rules that reduce all successive cases toward the base case. Generally, there are two types of recursion: direct and indirect. The code we have seen above is direct recursion since the function directly calls itself. Indirect recursion happens when a function \(f(x)\) calls \(g(x)\) and \(g(x)\) calls \(f(x)\). Consider this: 1 2 3 4 5 6 7 function print(int: a): print a + &quot; × &quot; return a * factorial(a-1) function factorial(int: a): if a == 0 return 1 print(a) We can extend the category of indirect recursion through the chains of function calls that lead to a loop, that is: [g_1 (x_1) \underrightarrow{\ calls\ } g_2(x_2) \underrightarrow{\ calls\ } … \underrightarrow{\ calls\ } g_1(x_n)] Likewise, direct recursion can be stacked on top of each other forming what’s called a multiple recursion. The most common example of this is a tree traversal: 1 2 3 4 5 function preorder(Node: node): if node exists: print node-&gt;value preorder(node-&gt;right) preorder(node-&gt;left) Recursion and Iteration As we have seen earlier, we can express a factorial computation in a recursive manner as well as in an iterative manner. But when should we use one over the other? Let’s take a look at the difference between recursion and iteration in performance in terms of time and space complexity, consider running the code below. In the clang++ std=c++17 compiler for C++17, recursive functions tend to be more performant as it saves more time. However, in a recursive function, the stack frame keeps piling up 8 bytes of memory until it reaches the base case for which the recursive function resolves the value, and only until then, frees the memory allocated in the function’s stack frame. Observe: It is worth noting that this is generally not the case, some implementation of recursive functions, most notably in imperative languages, tend to be slower than the iterative approach. In functional programming languages, on the other hand, the implementation of a recursive function tends to be much faster than in iteration. However, some compilers have optimized for recursion to reduce the performance overhead. Moreover, recursion is a mathematical concept, when we talk about recursion in the context of programming, we are essentially talking about how efficient recursion algorithms are implemented. In a functional paradigm wherein a worldview of seeing everything in the guise of a mathematical function, recursion is natural to the language therein their implementation is more optimized. There are some algorithms that work well with recursion in a functional programming language but become unbearable to compute in some languages. The reason is implementation. Lucky for us, we can translate any recursive programs into an iterative algorithm. This is due to the idea of Turing equivalence: two computers \(P\) and \(Q\) are equivalent, if \( P \underleftrightarrow{\ simulates\ } Q \). And since all Turing complete calculi are strictly equivalent in their expressive power, we can express recursive programs in an iterative approach. Note that this is always possible if we have an infinite amount of memory. I intentionally left the proof of μ-recursion and iteration being Turing complete. If you are interested you can consult the Church-Turing thesis [1] and Beoehm-Jacopini’s structured program theorem[2]. This topic ultimately boils down to the context i.e. what language are you using and the manner in how you can conveniently express the solution of your problem. Recursion in the Wild A recursive entity unfolds itself until it reaches a halt, otherwise, infinitely many times. A language can be expressed using an elegant style of recursion. Take for example the grammar of the English language: 1 2 3 &lt;Sentence&gt;::= &lt;Noun Phrase&gt; | &lt;Verb Phrase&gt;; &lt;Noun Phrase&gt;::= &lt;determiner&gt; | &lt;noun&gt;; &lt;Verb Phrase&gt;::= &lt;verb&gt; | &lt;Noun Phrase&gt;; What we see here is a Backus-Naur Form (BNF) of English grammar. Grammatically speaking, we can generate an infinitely long chain of words forming one sentence. If we substitute the ordering of our BNF above we can construct the following: 1 the dog ate the dog ate the dog ate the dog ate the dog ate the dog ... Three words that unfold in an infinitely long sentence. To me, I find the idea of recursion particularly fascinating in grammars and formal languages for it bears the idea within which we can describe the world in our own languages. Links to further readings: Böhm, C., &amp; Jacopini, G. (1966). Flow diagrams, Turing machines and languages with only two formation rules. Communications of the ACM, 9(5), 366-371. Copeland, B. J. (1997). The Church-Turing thesis. Dean, Walter, “Recursive Functions”, The Stanford Encyclopedia of Philosophy (Spring 2021 Edition), Edward N. Zalta (ed.)." /><meta property="og:description" content="Let’s talk about one of the cornerstones of Computer Science The idea of recursion has a dedicated field in Computer Science called Recursion theory, since we can’t possibly cover the entirety of this field, we will just go over some of the key features that most computer science people have grown and love. The idea that self-referent entities can reproduce themselves resonates almost entirely in Computer Science. Let’s take simple examples and realize the elegance of recursion. Consider the \(n!\) function. [n! = n_k \times … \times n_1 \times n_0\ \ k\in \mathbb{N}] Another way of expressing this function is: [\operatorname {fact} (n)={\begin{cases}1&amp;{\mbox{if }}n=0 \\ n\cdot \operatorname {fact} (n-1)&amp;{\mbox{if }} n&gt;0 \end{cases}}] The computation of a factorial function takes in a number and binds that number with the resolution of a factorial function with a number - 1. Consider the pseudocode snippet below: 1 2 3 function factorial(int:a): if a == 0 return 1 return a * factorial(a-1) Let’s implement the recursive function using a while-loop – this approach is called iterative. 1 2 3 4 5 function factorial(int: a): int result = 1 while a &gt; 1: result *= a a -= 1 Let’s break down this code a little bit. Recursive function call mainly has two parts: a base case, and an inductive case. The base case specifies when the recursion reaches a halt while the inductive case sets the rules that reduce all successive cases toward the base case. Generally, there are two types of recursion: direct and indirect. The code we have seen above is direct recursion since the function directly calls itself. Indirect recursion happens when a function \(f(x)\) calls \(g(x)\) and \(g(x)\) calls \(f(x)\). Consider this: 1 2 3 4 5 6 7 function print(int: a): print a + &quot; × &quot; return a * factorial(a-1) function factorial(int: a): if a == 0 return 1 print(a) We can extend the category of indirect recursion through the chains of function calls that lead to a loop, that is: [g_1 (x_1) \underrightarrow{\ calls\ } g_2(x_2) \underrightarrow{\ calls\ } … \underrightarrow{\ calls\ } g_1(x_n)] Likewise, direct recursion can be stacked on top of each other forming what’s called a multiple recursion. The most common example of this is a tree traversal: 1 2 3 4 5 function preorder(Node: node): if node exists: print node-&gt;value preorder(node-&gt;right) preorder(node-&gt;left) Recursion and Iteration As we have seen earlier, we can express a factorial computation in a recursive manner as well as in an iterative manner. But when should we use one over the other? Let’s take a look at the difference between recursion and iteration in performance in terms of time and space complexity, consider running the code below. In the clang++ std=c++17 compiler for C++17, recursive functions tend to be more performant as it saves more time. However, in a recursive function, the stack frame keeps piling up 8 bytes of memory until it reaches the base case for which the recursive function resolves the value, and only until then, frees the memory allocated in the function’s stack frame. Observe: It is worth noting that this is generally not the case, some implementation of recursive functions, most notably in imperative languages, tend to be slower than the iterative approach. In functional programming languages, on the other hand, the implementation of a recursive function tends to be much faster than in iteration. However, some compilers have optimized for recursion to reduce the performance overhead. Moreover, recursion is a mathematical concept, when we talk about recursion in the context of programming, we are essentially talking about how efficient recursion algorithms are implemented. In a functional paradigm wherein a worldview of seeing everything in the guise of a mathematical function, recursion is natural to the language therein their implementation is more optimized. There are some algorithms that work well with recursion in a functional programming language but become unbearable to compute in some languages. The reason is implementation. Lucky for us, we can translate any recursive programs into an iterative algorithm. This is due to the idea of Turing equivalence: two computers \(P\) and \(Q\) are equivalent, if \( P \underleftrightarrow{\ simulates\ } Q \). And since all Turing complete calculi are strictly equivalent in their expressive power, we can express recursive programs in an iterative approach. Note that this is always possible if we have an infinite amount of memory. I intentionally left the proof of μ-recursion and iteration being Turing complete. If you are interested you can consult the Church-Turing thesis [1] and Beoehm-Jacopini’s structured program theorem[2]. This topic ultimately boils down to the context i.e. what language are you using and the manner in how you can conveniently express the solution of your problem. Recursion in the Wild A recursive entity unfolds itself until it reaches a halt, otherwise, infinitely many times. A language can be expressed using an elegant style of recursion. Take for example the grammar of the English language: 1 2 3 &lt;Sentence&gt;::= &lt;Noun Phrase&gt; | &lt;Verb Phrase&gt;; &lt;Noun Phrase&gt;::= &lt;determiner&gt; | &lt;noun&gt;; &lt;Verb Phrase&gt;::= &lt;verb&gt; | &lt;Noun Phrase&gt;; What we see here is a Backus-Naur Form (BNF) of English grammar. Grammatically speaking, we can generate an infinitely long chain of words forming one sentence. If we substitute the ordering of our BNF above we can construct the following: 1 the dog ate the dog ate the dog ate the dog ate the dog ate the dog ... Three words that unfold in an infinitely long sentence. To me, I find the idea of recursion particularly fascinating in grammars and formal languages for it bears the idea within which we can describe the world in our own languages. Links to further readings: Böhm, C., &amp; Jacopini, G. (1966). Flow diagrams, Turing machines and languages with only two formation rules. Communications of the ACM, 9(5), 366-371. Copeland, B. J. (1997). The Church-Turing thesis. Dean, Walter, “Recursive Functions”, The Stanford Encyclopedia of Philosophy (Spring 2021 Edition), Edward N. Zalta (ed.)." /><link rel="canonical" href="https://adeeconometrics.github.io//posts/Recursion-is-Recursion/" /><meta property="og:url" content="https://adeeconometrics.github.io//posts/Recursion-is-Recursion/" /><meta property="og:site_name" content="Dave Amiana" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-18T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Recursion is Recursion" /><meta name="twitter:site" content="@iamdeb25" /><meta name="twitter:creator" content="@Dave Amiana" /><meta name="google-site-verification" content="google-site-verification=28bVbRErS2VwJaonXuu3GbqmRlyNvizt6I00B2kQh88" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Dave Amiana"},"dateModified":"2022-10-22T22:11:50+08:00","datePublished":"2021-04-18T00:00:00+08:00","description":"Let’s talk about one of the cornerstones of Computer Science The idea of recursion has a dedicated field in Computer Science called Recursion theory, since we can’t possibly cover the entirety of this field, we will just go over some of the key features that most computer science people have grown and love. The idea that self-referent entities can reproduce themselves resonates almost entirely in Computer Science. Let’s take simple examples and realize the elegance of recursion. Consider the \\(n!\\) function. [n! = n_k \\times … \\times n_1 \\times n_0\\ \\ k\\in \\mathbb{N}] Another way of expressing this function is: [\\operatorname {fact} (n)={\\begin{cases}1&amp;{\\mbox{if }}n=0 \\\\ n\\cdot \\operatorname {fact} (n-1)&amp;{\\mbox{if }} n&gt;0 \\end{cases}}] The computation of a factorial function takes in a number and binds that number with the resolution of a factorial function with a number - 1. Consider the pseudocode snippet below: 1 2 3 function factorial(int:a): if a == 0 return 1 return a * factorial(a-1) Let’s implement the recursive function using a while-loop – this approach is called iterative. 1 2 3 4 5 function factorial(int: a): int result = 1 while a &gt; 1: result *= a a -= 1 Let’s break down this code a little bit. Recursive function call mainly has two parts: a base case, and an inductive case. The base case specifies when the recursion reaches a halt while the inductive case sets the rules that reduce all successive cases toward the base case. Generally, there are two types of recursion: direct and indirect. The code we have seen above is direct recursion since the function directly calls itself. Indirect recursion happens when a function \\(f(x)\\) calls \\(g(x)\\) and \\(g(x)\\) calls \\(f(x)\\). Consider this: 1 2 3 4 5 6 7 function print(int: a): print a + &quot; × &quot; return a * factorial(a-1) function factorial(int: a): if a == 0 return 1 print(a) We can extend the category of indirect recursion through the chains of function calls that lead to a loop, that is: [g_1 (x_1) \\underrightarrow{\\ calls\\ } g_2(x_2) \\underrightarrow{\\ calls\\ } … \\underrightarrow{\\ calls\\ } g_1(x_n)] Likewise, direct recursion can be stacked on top of each other forming what’s called a multiple recursion. The most common example of this is a tree traversal: 1 2 3 4 5 function preorder(Node: node): if node exists: print node-&gt;value preorder(node-&gt;right) preorder(node-&gt;left) Recursion and Iteration As we have seen earlier, we can express a factorial computation in a recursive manner as well as in an iterative manner. But when should we use one over the other? Let’s take a look at the difference between recursion and iteration in performance in terms of time and space complexity, consider running the code below. In the clang++ std=c++17 compiler for C++17, recursive functions tend to be more performant as it saves more time. However, in a recursive function, the stack frame keeps piling up 8 bytes of memory until it reaches the base case for which the recursive function resolves the value, and only until then, frees the memory allocated in the function’s stack frame. Observe: It is worth noting that this is generally not the case, some implementation of recursive functions, most notably in imperative languages, tend to be slower than the iterative approach. In functional programming languages, on the other hand, the implementation of a recursive function tends to be much faster than in iteration. However, some compilers have optimized for recursion to reduce the performance overhead. Moreover, recursion is a mathematical concept, when we talk about recursion in the context of programming, we are essentially talking about how efficient recursion algorithms are implemented. In a functional paradigm wherein a worldview of seeing everything in the guise of a mathematical function, recursion is natural to the language therein their implementation is more optimized. There are some algorithms that work well with recursion in a functional programming language but become unbearable to compute in some languages. The reason is implementation. Lucky for us, we can translate any recursive programs into an iterative algorithm. This is due to the idea of Turing equivalence: two computers \\(P\\) and \\(Q\\) are equivalent, if \\( P \\underleftrightarrow{\\ simulates\\ } Q \\). And since all Turing complete calculi are strictly equivalent in their expressive power, we can express recursive programs in an iterative approach. Note that this is always possible if we have an infinite amount of memory. I intentionally left the proof of μ-recursion and iteration being Turing complete. If you are interested you can consult the Church-Turing thesis [1] and Beoehm-Jacopini’s structured program theorem[2]. This topic ultimately boils down to the context i.e. what language are you using and the manner in how you can conveniently express the solution of your problem. Recursion in the Wild A recursive entity unfolds itself until it reaches a halt, otherwise, infinitely many times. A language can be expressed using an elegant style of recursion. Take for example the grammar of the English language: 1 2 3 &lt;Sentence&gt;::= &lt;Noun Phrase&gt; | &lt;Verb Phrase&gt;; &lt;Noun Phrase&gt;::= &lt;determiner&gt; | &lt;noun&gt;; &lt;Verb Phrase&gt;::= &lt;verb&gt; | &lt;Noun Phrase&gt;; What we see here is a Backus-Naur Form (BNF) of English grammar. Grammatically speaking, we can generate an infinitely long chain of words forming one sentence. If we substitute the ordering of our BNF above we can construct the following: 1 the dog ate the dog ate the dog ate the dog ate the dog ate the dog ... Three words that unfold in an infinitely long sentence. To me, I find the idea of recursion particularly fascinating in grammars and formal languages for it bears the idea within which we can describe the world in our own languages. Links to further readings: Böhm, C., &amp; Jacopini, G. (1966). Flow diagrams, Turing machines and languages with only two formation rules. Communications of the ACM, 9(5), 366-371. Copeland, B. J. (1997). The Church-Turing thesis. Dean, Walter, “Recursive Functions”, The Stanford Encyclopedia of Philosophy (Spring 2021 Edition), Edward N. Zalta (ed.).","headline":"Recursion is Recursion","mainEntityOfPage":{"@type":"WebPage","@id":"https://adeeconometrics.github.io//posts/Recursion-is-Recursion/"},"url":"https://adeeconometrics.github.io//posts/Recursion-is-Recursion/"}</script><title>Recursion is Recursion | Dave Amiana</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dave Amiana"><meta name="application-name" content="Dave Amiana"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0M61FBNQ0K"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0M61FBNQ0K'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/profile-picture.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dave Amiana</a></div><div class="site-subtitle font-italic">Open-source and Enterprise Software Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/adeeconometrics" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/dave-amiana/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['amiana.dave','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Recursion is Recursion</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Recursion is Recursion</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Dave Amiana </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Apr 18, 2021, 12:00 AM +0800" prep="on" > Apr 18, 2021 <i class="unloaded">2021-04-18T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 22, 2022, 10:11 PM +0800" prefix="Updated " > Oct 22, 2022 <i class="unloaded">2022-10-22T22:11:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="991 words">5 min</span></div></div><div class="post-content"><blockquote><p>Let’s talk about one of the cornerstones of Computer Science</p></blockquote><p>The idea of recursion has a dedicated field in Computer Science called <a href="https://en.wikipedia.org/wiki/Computability_theory">Recursion theory</a>, since we can’t possibly cover the entirety of this field, we will just go over some of the key features that most computer science people have grown and love.</p><p>The idea that self-referent entities can reproduce themselves resonates almost entirely in Computer Science. Let’s take simple examples and realize the elegance of recursion. Consider the \(n!\) function.</p>\[n! = n_k \times ... \times n_1 \times n_0\ |\ k\in \mathbb{N}\]<p>Another way of expressing this function is:</p>\[\operatorname {fact} (n)={\begin{cases}1&amp;{\mbox{if }}n=0 \\\\ n\cdot \operatorname {fact} (n-1)&amp;{\mbox{if }} n&gt;0 \end{cases}}\]<p>The computation of a factorial function takes in a number and binds that number with the resolution of a factorial function with a number - 1. Consider the pseudocode snippet below:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>function factorial(int:a):
    if a == 0 return 1
    return a * factorial(a-1)
</pre></table></code></div></div><p>Let’s implement the recursive function using a while-loop – this approach is called <em>iterative</em>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>function factorial(int: a):
    int result = 1
    while a &gt; 1:
        result *= a
        a -= 1
</pre></table></code></div></div><p>Let’s break down this code a little bit. Recursive function call mainly has two parts: a <em>base case</em>, and an <em>inductive case</em>. The base case specifies when the recursion reaches a halt while the inductive case sets the rules that reduce all successive cases toward the base case.</p><p>Generally, there are two types of recursion: <em>direct and indirect</em>. The code we have seen above is direct recursion since the function directly calls itself. Indirect recursion happens when a function \(f(x)\) calls \(g(x)\) and \(g(x)\) calls \(f(x)\). Consider this:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>function print(int: a):
    print a + " × "
    return a * factorial(a-1)

function factorial(int: a):
    if a == 0 return 1
    print(a)
</pre></table></code></div></div><p>We can extend the category of indirect recursion through the chains of function calls that lead to a loop, that is:</p>\[g_1 (x_1) \underrightarrow{\ calls\ } g_2(x_2) \underrightarrow{\ calls\ } ... \underrightarrow{\ calls\ } g_1(x_n)\]<p>Likewise, direct recursion can be stacked on top of each other forming what’s called a multiple recursion. The most common example of this is a tree traversal:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>function preorder(Node: node):
    if node exists:
        print node-&gt;value
        preorder(node-&gt;right)
        preorder(node-&gt;left)
</pre></table></code></div></div><hr /><h3 id="recursion-and-iteration">Recursion and Iteration</h3><p>As we have seen earlier, we can express a factorial computation in a recursive manner as well as in an iterative manner. But when should we use one over the other? Let’s take a look at the difference between recursion and iteration in performance in terms of time and space complexity, consider running the code below.</p><iframe height="600px" width="100%" src="https://replit.com/@dcode2021/dcodecppseries?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe><p>In the <code class="language-plaintext highlighter-rouge">clang++ std=c++17</code> compiler for C++17, recursive functions tend to be more performant as it saves more time. However, in a recursive function, the <a href="https://en.wikipedia.org/wiki/Call_stack">stack frame</a> keeps piling up 8 bytes of memory until it reaches the base case for which the recursive function resolves the value, and only until then, frees the memory allocated in the function’s stack frame. Observe:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1618729597185/BdcyY9Pdk.gif" alt="Real Python.gif" /></p><p>It is worth noting that this is generally not the case, some implementation of recursive functions, most notably in imperative languages, tend to be slower than the iterative approach. In functional programming languages, on the other hand, the implementation of a recursive function tends to be much faster than in iteration. However, some compilers have optimized for recursion to reduce the performance overhead.</p><p>Moreover, recursion is a mathematical concept, when we talk about recursion in the context of programming, we are essentially talking about how efficient recursion algorithms are implemented. In a functional paradigm wherein a worldview of seeing everything in the guise of a mathematical function, recursion is natural to the language therein their implementation is more optimized. There are some algorithms that work well with recursion in a functional programming language but become unbearable to compute in some languages. The reason is implementation.</p><p>Lucky for us, we can translate <em>any</em> recursive programs into an iterative algorithm. This is due to the idea of <strong>Turing equivalence</strong>: two computers \(P\) and \(Q\) are equivalent, if \( P \underleftrightarrow{\ simulates\ } Q \). And since all Turing complete calculi are strictly equivalent in their expressive power, we can express recursive programs in an iterative approach. Note that this is always possible if we have an infinite amount of memory.</p><blockquote><p>I intentionally left the proof of μ-recursion and iteration being Turing complete. If you are interested you can consult the Church-Turing thesis [1] and Beoehm-Jacopini’s structured program theorem[2].</p></blockquote><p>This topic ultimately boils down to the context i.e. what language are you using and the manner in how you can conveniently express the solution of your problem.</p><hr /><h3 id="recursion-in-the-wild">Recursion in the Wild</h3><p>A recursive entity unfolds itself until it reaches a halt, otherwise, infinitely many times. A language can be expressed using an elegant style of recursion. Take for example the grammar of the English language:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>&lt;Sentence&gt;::= &lt;Noun Phrase&gt; | &lt;Verb Phrase&gt;;
&lt;Noun Phrase&gt;::= &lt;determiner&gt; | &lt;noun&gt;;
&lt;Verb Phrase&gt;::= &lt;verb&gt; | &lt;Noun Phrase&gt;;
</pre></table></code></div></div><p>What we see here is a Backus-Naur Form (BNF) of English grammar. Grammatically speaking, we can generate an infinitely long chain of words forming one sentence. If we substitute the ordering of our BNF above we can construct the following:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>the dog ate the dog ate the dog ate the dog ate the dog ate the dog ...
</pre></table></code></div></div><p>Three words that unfold in an infinitely long sentence. To me, I find the idea of recursion particularly fascinating in grammars and formal languages for it bears the idea within which we can describe the world in our own languages.</p><hr /><h3 id="links-to-further-readings">Links to further readings:</h3><ol><li>Böhm, C., &amp; Jacopini, G. (1966). <a href="https://bityl.co/6Qjt">Flow diagrams, Turing machines and languages with only two formation rules</a>. Communications of the ACM, 9(5), 366-371.<li>Copeland, B. J. (1997). <a href="https://bityl.co/6Qju">The Church-Turing thesis</a>.<li>Dean, Walter, <a href="https://plato.stanford.edu/archives/spr2021/entries/recursive-functions">“Recursive Functions”</a>, The Stanford Encyclopedia of Philosophy (Spring 2021 Edition), Edward N. Zalta (ed.).</ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a>, <a href='/categories/computer-science/'>Computer Science</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/programming/" class="post-tag no-text-decoration" >programming</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Recursion is Recursion - Dave Amiana&url=https://adeeconometrics.github.io//posts/Recursion-is-Recursion/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Recursion is Recursion - Dave Amiana&u=https://adeeconometrics.github.io//posts/Recursion-is-Recursion/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Recursion is Recursion - Dave Amiana&url=https://adeeconometrics.github.io//posts/Recursion-is-Recursion/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/On-Pointer-Types/">On Pointer Types</a><li><a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/">Pointers and References: Design Goals and Use Cases</a><li><a href="/posts/Unique-Reference/">Unique References</a><li><a href="/posts/Shared-Reference/">Shared References</a><li><a href="/posts/Weak-Reference/">Weak References</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/On-Pointer-Types/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>On Pointer Types</h3><div class="text-muted small"><p> In this article, I aim to introduce the concept and motivation behind using pointers. There are breeds of C++ developers that only use smart pointers for safety reasons, others that only use raw po...</p></div></div></a></div><div class="card"> <a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Pointers and References: Design Goals and Use Cases</h3><div class="text-muted small"><p> At first, it seems that C++ makes things more complicated by introducing yet another layer of abstraction. References seem to encapsulate the same set of functionalities as pointers. Both of these ...</p></div></div></a></div><div class="card"> <a href="/posts/Unique-Reference/"><div class="card-body"> <span class="timeago small" > Aug 17, 2021 <i class="unloaded">2021-08-17T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Unique References</h3><div class="text-muted small"><p> Our previous discussion explores the anatomy of pointer types in C and C++ on par with hinting nuances of reference semantics. We discussed the use cases of raw pointers and smart pointers in moder...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Python-Typed-Annotations/" class="btn btn-outline-primary" prompt="Older"><p>Python Typed Annotations</p></a> <a href="/posts/World-Of-Forms-Introduction-to-OOP/" class="btn btn-outline-primary" prompt="Newer"><p>World of Forms: An Introduction to Object-Oriented Programming</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/iamdeb25">Dave Amiana</a>.</p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://adeeconometrics.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
