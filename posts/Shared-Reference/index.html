<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Shared References" /><meta name="author" content="Dave Amiana" /><meta property="og:locale" content="en_US" /><meta name="description" content="In our previous discussion, we fleshed out the design requirements and took action into servicing them. In the same way, this article aims to flesh out the design requirement for shared reference. Shared references make use of a reference counting mechanism that allows resources to be shared in different parts of the program. In some cases, this technique replaces the need for garbage collection as reference counting automatically cleans up the resources at the time it hits 0. The implementation of shared references has a performance cost which led implementers of garbage collection (GC) algorithms to weigh their choices in implementing automatic resource management. Dynamic languages such as Java, C#, and Dart implement more sophisticated GC’s to minimize the cost of developing applications. Some languages relied on reference counting techniques like C++ and Rust for system-level programming. And some languages like Python make use of both in combination. We can observe that the decision of choosing a resource management system depends on the intended use of the language. For instance, C++ supported smart pointers for automatic reference management while allowing manual resource management through raw pointers because the language is aimed at servicing problems that exist from the level of the silicon to the highest levels of abstraction – that is why C++ provide resource-safe automation and manual resource management. Before we implement our shared reference class, let first us discuss the advantages and disadvantages of implementing reference counting (RC). Advantages RC guarantees that resources are cleaned up as soon as their last reference is destroyed. RC is deterministic through RAII. RC is relatively simple to implement over more sophisticated GC algorithms. Disadvantages RC may leak resources in case of reference cycles. RC has space overhead for reference counting. RC is difficult to deal with in a multithreaded environment since it requires atomicity. Note that the disadvantages vary in the sophistication of RC implementation. In our last discussion, we showed the problem of reference cycles and resolved this by std::weak_ptr&lt;T&gt;. We will review this problem and work through solving the problem of reference cycles by implementing a weak_reference class. In the meantime, let us focus on implementing our simple model of shared reference. Design Goals Let us flesh out our design requirements. Our shared_reference class must satisfy the following: Must accept any types Automatic Resource Management Reference counting Pointer-like interface Implementation Now, we translate the design requirements into code. We will build up from it one by one. Requirement: Must Accept any Type This is trivial, but let us include it here. To put this into code, we simply make use of template parameters as follows: 1 template &lt;typename T&gt; class shared_reference; Simple right? Let’s keep going! Requirement: Automatic Resource Management and Reference Counting The idea is to make use of RAII – a programming idiom that gives us guarantees with resource-safe management. We simply need to fill out the resource acquisition upon construction and resource clean-up upon destruction. RAII is achieved through constructor-destructor pairs which are triggered to keep track of the object’s lifetime. 1 2 3 4 5 6 7 8 9 10 11 12 template&lt;typename T&gt; class shared_reference{ T* m_ptr{nullptr}; public: shared_reference() = default; ~shared_reference(){ if(m_ptr != nullptr){ m_ptr-&gt;~T(); m_ptr = nullptr; } } }; That seems, reasonable. We initialized m_ptr to null and we successfully cleaned up our resources at the time it went out of scope. But that is what we did with unique_reference, right? How is shared reference any different? The answer lies with the reference counting mechanism. To extend the lifetime of our objects, we have to know when it is appropriate to perform our clean-up. As mentioned, we perform our clean-up in the case where our reference count is 0. Now that we get the idea, let us put this in code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 template&lt;typename T&gt; class shared_reference{ size_t m_counter{1}; T *m_ptr{nullptr}; public: shared_reference() = default; ~shared_reference() { m_counter -= 1; if (m_counter == 0) { m_ptr-&gt;~T(); m_ptr = nullptr; } }; The idea is to count how many instances that refer to m_ptr are still active. With RAII, we can delegate this role to our constructor; that is, for each time it creates an instance of shared_reference it has to increment m_counter and for each time it goes out of scope, it has to decrement and check if it is time for clean-up. Let’s write a copy constructor and a special constructor that takes in a T* parameter. 1 2 3 4 5 6 shared_reference() = delete; explicit shared_reference(T* i_ptr): m_ptr(i_ptr){} explicit shared_reference(shared_reference&lt;T&gt;&amp; rhs){ rhs.m_ptr = m_ptr; rhs.m_counter = m_counter + 1; } The first constructor is designed to accommodate the initialization of our reference which takes away the need for our default constructor so we deleted it. We want to tell the compiler that it is not free to deduce the default constructor in the case where we need our class to initialize the user has to explicitly bind the content of its referent. Our copy constructor is not technically a copy-constructor because at the time we pass shared_reference&lt;T&gt;&amp; we only want it to share the contents of m_ptr and increment m_counter. What we want is to provide an interface for sharing references. To avoid confusion, I will refer to shared_reference(shared_reference&lt;T&gt;&amp;) as a reference constructor. But if we want to transfer the ownership to another entity and we don’t want it to have shared access to it anymore? This is the responsibility of our move constructor. 1 2 3 4 shared_reference(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept { std::swap(m_ptr, rhs.m_ptr); rhs.m_counter = 1; } Notice that we initialized rhs.m_counter to 1 and not swapped the values of m_counter, this is because we want to re-initialize the counter when it is transferred. That seems correct. But we ran into deep trouble when we decided to test this. Let us consider the following assertions: 1 2 3 4 5 6 7 shared_reference&lt;AnyType&gt;ptr_0(new AnyType()); { shared_reference&lt;AnyType&gt;ptr_1(ptr_0); { shared_reference&lt;AnyType&gt;ptr_2(ptr_1); } } For each time we instantiate an object, we reserve a representation of our model and record the states of its instances. But we do not share the states of our instances. So each time we call our reference constructor, we are actually populating unrelated state changes with our instances. That is a subtle bug, not a feature! What we actually want is to have a common ground for communication that updates all the instances of shared_reference&lt;T&gt; each time it goes out of scope. So, it seems reasonable to use static members. Let’s add the assignment overloads and debug! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 template&lt;typename T&gt; class shared_reference{ static size_t m_counter; T* m_ptr; public: shared_reference() = delete; explicit shared_reference(T* i_ptr): m_ptr(i_ptr){} explicit shared_reference(shared_reference&lt;T&gt;&amp; rhs) noexcept {rhs.copy(*this); } explicit shared_reference(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } ~shared_reference(){ m_counter -= 1; if(m_counter == 0){ m_ptr-&gt;~T(); } } T &amp;operator=(shared_reference&lt;T&gt;&amp; rhs)noexcept {rhs.copy(*this); } T &amp;operator=(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } private: void copy(shared_reference&lt;T&gt;&amp; rhs) noexcept{ m_counter += 1; rhs.m_ptr = m_ptr; } void swap(shared_reference&lt;T&gt;&amp; rhs) noexcept { std::swap(m_ptr, rhs.m_ptr); } }; template&lt;typename T&gt; size_t shared_reference&lt;T&gt;::m_counter = 1; We did it! We hit two birds with one stone. Let’s work on the pointer-like interface! Requirement: Pointer-like Interface We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer. Recall that a pointer can be dereferenced with * and -&gt; operators. And we need &amp; operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write: 1 2 3 T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(shared_reference&lt;T&gt; &amp;other) { return other.m_ptr; } Let us walk through the three lines. The first line returns a reference of *(this-&gt;m_ptr) which means that the content of m_ptr is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to m_ptr’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. Recall that a pointer has its own location in memory separate from the entities it points to. Let’s go beyond our requirement list and add little features that return the current count of our references and their contents. We call these functions count(), and get(). The implementation is equally trivial. Putting it all together 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 template&lt;typename T&gt; class shared_reference{ static size_t m_counter; T* m_ptr; public: shared_reference() = delete; explicit shared_reference(T* i_ptr): m_ptr(i_ptr){} explicit shared_reference(shared_reference&lt;T&gt;&amp; rhs) noexcept {rhs.copy(*this); } explicit shared_reference(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } ~shared_reference(){ m_counter -= 1; if(m_counter == 0){ m_ptr-&gt;~T(); } } T &amp;operator=(shared_reference&lt;T&gt;&amp; rhs)noexcept {rhs.copy(*this); } T &amp;operator=(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(shared_reference&lt;T&gt; &amp;other) { return other.m_ptr; } T *get(void) { return this-&gt;m_ptr; } size_t count() const { return m_counter; } private: void copy(shared_reference&lt;T&gt;&amp; rhs) noexcept{ m_counter += 1; rhs.m_ptr = m_ptr; } void swap(shared_reference&lt;T&gt;&amp; rhs) noexcept { std::swap(m_ptr, rhs.m_ptr); } }; template&lt;typename T&gt; size_t shared_reference&lt;T&gt;::m_counter = 1; Test Cases Time to see if we satisfied our design requirements: Summary We fleshed out our design requirements and implemented our version of the shared reference to satisfy what we intend to do with shared references. Upon testing, we found that it sufficiently did what we want it to do: we now have the second piece of our automatic resource management! Since we implemented a simple shared resource management, think about how you can extend this to support indexing in an array structure. Have fun hacking! References Wikipedia contributors. (2021, June 29). Garbage collection (computer science). https://en.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science). Oracle (n.d.). Java Garbage Collection Basics. https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html. Microsoft Docs (2020). Background garbage collection. https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/background-gc. Mrale.ph (n.d.). Introduction to Dart VM. https://mrale.ph/dartvm/. Rust (n.d.). Module alloc::rc. https://doc.rust-lang.org/alloc/rc/. cppreference.com (2021). std::shared_ptr. https://en.cppreference.com/w/cpp/memory/shared_ptr. Debrie, A. (2021). Python Garbage Collection: What It Is and How it works? https://stackify.com/python-garbage-collection/. Microsoft Docs (2020). Welcome back to C++ - Modern C++. https://bityl.co/8HD7. cppreference.com (2021). static members. https://en.cppreference.com/w/cpp/language/static." /><meta property="og:description" content="In our previous discussion, we fleshed out the design requirements and took action into servicing them. In the same way, this article aims to flesh out the design requirement for shared reference. Shared references make use of a reference counting mechanism that allows resources to be shared in different parts of the program. In some cases, this technique replaces the need for garbage collection as reference counting automatically cleans up the resources at the time it hits 0. The implementation of shared references has a performance cost which led implementers of garbage collection (GC) algorithms to weigh their choices in implementing automatic resource management. Dynamic languages such as Java, C#, and Dart implement more sophisticated GC’s to minimize the cost of developing applications. Some languages relied on reference counting techniques like C++ and Rust for system-level programming. And some languages like Python make use of both in combination. We can observe that the decision of choosing a resource management system depends on the intended use of the language. For instance, C++ supported smart pointers for automatic reference management while allowing manual resource management through raw pointers because the language is aimed at servicing problems that exist from the level of the silicon to the highest levels of abstraction – that is why C++ provide resource-safe automation and manual resource management. Before we implement our shared reference class, let first us discuss the advantages and disadvantages of implementing reference counting (RC). Advantages RC guarantees that resources are cleaned up as soon as their last reference is destroyed. RC is deterministic through RAII. RC is relatively simple to implement over more sophisticated GC algorithms. Disadvantages RC may leak resources in case of reference cycles. RC has space overhead for reference counting. RC is difficult to deal with in a multithreaded environment since it requires atomicity. Note that the disadvantages vary in the sophistication of RC implementation. In our last discussion, we showed the problem of reference cycles and resolved this by std::weak_ptr&lt;T&gt;. We will review this problem and work through solving the problem of reference cycles by implementing a weak_reference class. In the meantime, let us focus on implementing our simple model of shared reference. Design Goals Let us flesh out our design requirements. Our shared_reference class must satisfy the following: Must accept any types Automatic Resource Management Reference counting Pointer-like interface Implementation Now, we translate the design requirements into code. We will build up from it one by one. Requirement: Must Accept any Type This is trivial, but let us include it here. To put this into code, we simply make use of template parameters as follows: 1 template &lt;typename T&gt; class shared_reference; Simple right? Let’s keep going! Requirement: Automatic Resource Management and Reference Counting The idea is to make use of RAII – a programming idiom that gives us guarantees with resource-safe management. We simply need to fill out the resource acquisition upon construction and resource clean-up upon destruction. RAII is achieved through constructor-destructor pairs which are triggered to keep track of the object’s lifetime. 1 2 3 4 5 6 7 8 9 10 11 12 template&lt;typename T&gt; class shared_reference{ T* m_ptr{nullptr}; public: shared_reference() = default; ~shared_reference(){ if(m_ptr != nullptr){ m_ptr-&gt;~T(); m_ptr = nullptr; } } }; That seems, reasonable. We initialized m_ptr to null and we successfully cleaned up our resources at the time it went out of scope. But that is what we did with unique_reference, right? How is shared reference any different? The answer lies with the reference counting mechanism. To extend the lifetime of our objects, we have to know when it is appropriate to perform our clean-up. As mentioned, we perform our clean-up in the case where our reference count is 0. Now that we get the idea, let us put this in code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 template&lt;typename T&gt; class shared_reference{ size_t m_counter{1}; T *m_ptr{nullptr}; public: shared_reference() = default; ~shared_reference() { m_counter -= 1; if (m_counter == 0) { m_ptr-&gt;~T(); m_ptr = nullptr; } }; The idea is to count how many instances that refer to m_ptr are still active. With RAII, we can delegate this role to our constructor; that is, for each time it creates an instance of shared_reference it has to increment m_counter and for each time it goes out of scope, it has to decrement and check if it is time for clean-up. Let’s write a copy constructor and a special constructor that takes in a T* parameter. 1 2 3 4 5 6 shared_reference() = delete; explicit shared_reference(T* i_ptr): m_ptr(i_ptr){} explicit shared_reference(shared_reference&lt;T&gt;&amp; rhs){ rhs.m_ptr = m_ptr; rhs.m_counter = m_counter + 1; } The first constructor is designed to accommodate the initialization of our reference which takes away the need for our default constructor so we deleted it. We want to tell the compiler that it is not free to deduce the default constructor in the case where we need our class to initialize the user has to explicitly bind the content of its referent. Our copy constructor is not technically a copy-constructor because at the time we pass shared_reference&lt;T&gt;&amp; we only want it to share the contents of m_ptr and increment m_counter. What we want is to provide an interface for sharing references. To avoid confusion, I will refer to shared_reference(shared_reference&lt;T&gt;&amp;) as a reference constructor. But if we want to transfer the ownership to another entity and we don’t want it to have shared access to it anymore? This is the responsibility of our move constructor. 1 2 3 4 shared_reference(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept { std::swap(m_ptr, rhs.m_ptr); rhs.m_counter = 1; } Notice that we initialized rhs.m_counter to 1 and not swapped the values of m_counter, this is because we want to re-initialize the counter when it is transferred. That seems correct. But we ran into deep trouble when we decided to test this. Let us consider the following assertions: 1 2 3 4 5 6 7 shared_reference&lt;AnyType&gt;ptr_0(new AnyType()); { shared_reference&lt;AnyType&gt;ptr_1(ptr_0); { shared_reference&lt;AnyType&gt;ptr_2(ptr_1); } } For each time we instantiate an object, we reserve a representation of our model and record the states of its instances. But we do not share the states of our instances. So each time we call our reference constructor, we are actually populating unrelated state changes with our instances. That is a subtle bug, not a feature! What we actually want is to have a common ground for communication that updates all the instances of shared_reference&lt;T&gt; each time it goes out of scope. So, it seems reasonable to use static members. Let’s add the assignment overloads and debug! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 template&lt;typename T&gt; class shared_reference{ static size_t m_counter; T* m_ptr; public: shared_reference() = delete; explicit shared_reference(T* i_ptr): m_ptr(i_ptr){} explicit shared_reference(shared_reference&lt;T&gt;&amp; rhs) noexcept {rhs.copy(*this); } explicit shared_reference(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } ~shared_reference(){ m_counter -= 1; if(m_counter == 0){ m_ptr-&gt;~T(); } } T &amp;operator=(shared_reference&lt;T&gt;&amp; rhs)noexcept {rhs.copy(*this); } T &amp;operator=(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } private: void copy(shared_reference&lt;T&gt;&amp; rhs) noexcept{ m_counter += 1; rhs.m_ptr = m_ptr; } void swap(shared_reference&lt;T&gt;&amp; rhs) noexcept { std::swap(m_ptr, rhs.m_ptr); } }; template&lt;typename T&gt; size_t shared_reference&lt;T&gt;::m_counter = 1; We did it! We hit two birds with one stone. Let’s work on the pointer-like interface! Requirement: Pointer-like Interface We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer. Recall that a pointer can be dereferenced with * and -&gt; operators. And we need &amp; operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write: 1 2 3 T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(shared_reference&lt;T&gt; &amp;other) { return other.m_ptr; } Let us walk through the three lines. The first line returns a reference of *(this-&gt;m_ptr) which means that the content of m_ptr is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to m_ptr’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. Recall that a pointer has its own location in memory separate from the entities it points to. Let’s go beyond our requirement list and add little features that return the current count of our references and their contents. We call these functions count(), and get(). The implementation is equally trivial. Putting it all together 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 template&lt;typename T&gt; class shared_reference{ static size_t m_counter; T* m_ptr; public: shared_reference() = delete; explicit shared_reference(T* i_ptr): m_ptr(i_ptr){} explicit shared_reference(shared_reference&lt;T&gt;&amp; rhs) noexcept {rhs.copy(*this); } explicit shared_reference(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } ~shared_reference(){ m_counter -= 1; if(m_counter == 0){ m_ptr-&gt;~T(); } } T &amp;operator=(shared_reference&lt;T&gt;&amp; rhs)noexcept {rhs.copy(*this); } T &amp;operator=(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(shared_reference&lt;T&gt; &amp;other) { return other.m_ptr; } T *get(void) { return this-&gt;m_ptr; } size_t count() const { return m_counter; } private: void copy(shared_reference&lt;T&gt;&amp; rhs) noexcept{ m_counter += 1; rhs.m_ptr = m_ptr; } void swap(shared_reference&lt;T&gt;&amp; rhs) noexcept { std::swap(m_ptr, rhs.m_ptr); } }; template&lt;typename T&gt; size_t shared_reference&lt;T&gt;::m_counter = 1; Test Cases Time to see if we satisfied our design requirements: Summary We fleshed out our design requirements and implemented our version of the shared reference to satisfy what we intend to do with shared references. Upon testing, we found that it sufficiently did what we want it to do: we now have the second piece of our automatic resource management! Since we implemented a simple shared resource management, think about how you can extend this to support indexing in an array structure. Have fun hacking! References Wikipedia contributors. (2021, June 29). Garbage collection (computer science). https://en.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science). Oracle (n.d.). Java Garbage Collection Basics. https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html. Microsoft Docs (2020). Background garbage collection. https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/background-gc. Mrale.ph (n.d.). Introduction to Dart VM. https://mrale.ph/dartvm/. Rust (n.d.). Module alloc::rc. https://doc.rust-lang.org/alloc/rc/. cppreference.com (2021). std::shared_ptr. https://en.cppreference.com/w/cpp/memory/shared_ptr. Debrie, A. (2021). Python Garbage Collection: What It Is and How it works? https://stackify.com/python-garbage-collection/. Microsoft Docs (2020). Welcome back to C++ - Modern C++. https://bityl.co/8HD7. cppreference.com (2021). static members. https://en.cppreference.com/w/cpp/language/static." /><link rel="canonical" href="https://adeeconometrics.github.io//posts/Shared-Reference/" /><meta property="og:url" content="https://adeeconometrics.github.io//posts/Shared-Reference/" /><meta property="og:site_name" content="Dave Amiana" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-20T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Shared References" /><meta name="twitter:site" content="@iamdeb25" /><meta name="twitter:creator" content="@Dave Amiana" /><meta name="google-site-verification" content="google-site-verification=28bVbRErS2VwJaonXuu3GbqmRlyNvizt6I00B2kQh88" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Dave Amiana"},"dateModified":"2022-10-22T22:11:50+08:00","datePublished":"2021-08-20T00:00:00+08:00","description":"In our previous discussion, we fleshed out the design requirements and took action into servicing them. In the same way, this article aims to flesh out the design requirement for shared reference. Shared references make use of a reference counting mechanism that allows resources to be shared in different parts of the program. In some cases, this technique replaces the need for garbage collection as reference counting automatically cleans up the resources at the time it hits 0. The implementation of shared references has a performance cost which led implementers of garbage collection (GC) algorithms to weigh their choices in implementing automatic resource management. Dynamic languages such as Java, C#, and Dart implement more sophisticated GC’s to minimize the cost of developing applications. Some languages relied on reference counting techniques like C++ and Rust for system-level programming. And some languages like Python make use of both in combination. We can observe that the decision of choosing a resource management system depends on the intended use of the language. For instance, C++ supported smart pointers for automatic reference management while allowing manual resource management through raw pointers because the language is aimed at servicing problems that exist from the level of the silicon to the highest levels of abstraction – that is why C++ provide resource-safe automation and manual resource management. Before we implement our shared reference class, let first us discuss the advantages and disadvantages of implementing reference counting (RC). Advantages RC guarantees that resources are cleaned up as soon as their last reference is destroyed. RC is deterministic through RAII. RC is relatively simple to implement over more sophisticated GC algorithms. Disadvantages RC may leak resources in case of reference cycles. RC has space overhead for reference counting. RC is difficult to deal with in a multithreaded environment since it requires atomicity. Note that the disadvantages vary in the sophistication of RC implementation. In our last discussion, we showed the problem of reference cycles and resolved this by std::weak_ptr&lt;T&gt;. We will review this problem and work through solving the problem of reference cycles by implementing a weak_reference class. In the meantime, let us focus on implementing our simple model of shared reference. Design Goals Let us flesh out our design requirements. Our shared_reference class must satisfy the following: Must accept any types Automatic Resource Management Reference counting Pointer-like interface Implementation Now, we translate the design requirements into code. We will build up from it one by one. Requirement: Must Accept any Type This is trivial, but let us include it here. To put this into code, we simply make use of template parameters as follows: 1 template &lt;typename T&gt; class shared_reference; Simple right? Let’s keep going! Requirement: Automatic Resource Management and Reference Counting The idea is to make use of RAII – a programming idiom that gives us guarantees with resource-safe management. We simply need to fill out the resource acquisition upon construction and resource clean-up upon destruction. RAII is achieved through constructor-destructor pairs which are triggered to keep track of the object’s lifetime. 1 2 3 4 5 6 7 8 9 10 11 12 template&lt;typename T&gt; class shared_reference{ T* m_ptr{nullptr}; public: shared_reference() = default; ~shared_reference(){ if(m_ptr != nullptr){ m_ptr-&gt;~T(); m_ptr = nullptr; } } }; That seems, reasonable. We initialized m_ptr to null and we successfully cleaned up our resources at the time it went out of scope. But that is what we did with unique_reference, right? How is shared reference any different? The answer lies with the reference counting mechanism. To extend the lifetime of our objects, we have to know when it is appropriate to perform our clean-up. As mentioned, we perform our clean-up in the case where our reference count is 0. Now that we get the idea, let us put this in code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 template&lt;typename T&gt; class shared_reference{ size_t m_counter{1}; T *m_ptr{nullptr}; public: shared_reference() = default; ~shared_reference() { m_counter -= 1; if (m_counter == 0) { m_ptr-&gt;~T(); m_ptr = nullptr; } }; The idea is to count how many instances that refer to m_ptr are still active. With RAII, we can delegate this role to our constructor; that is, for each time it creates an instance of shared_reference it has to increment m_counter and for each time it goes out of scope, it has to decrement and check if it is time for clean-up. Let’s write a copy constructor and a special constructor that takes in a T* parameter. 1 2 3 4 5 6 shared_reference() = delete; explicit shared_reference(T* i_ptr): m_ptr(i_ptr){} explicit shared_reference(shared_reference&lt;T&gt;&amp; rhs){ rhs.m_ptr = m_ptr; rhs.m_counter = m_counter + 1; } The first constructor is designed to accommodate the initialization of our reference which takes away the need for our default constructor so we deleted it. We want to tell the compiler that it is not free to deduce the default constructor in the case where we need our class to initialize the user has to explicitly bind the content of its referent. Our copy constructor is not technically a copy-constructor because at the time we pass shared_reference&lt;T&gt;&amp; we only want it to share the contents of m_ptr and increment m_counter. What we want is to provide an interface for sharing references. To avoid confusion, I will refer to shared_reference(shared_reference&lt;T&gt;&amp;) as a reference constructor. But if we want to transfer the ownership to another entity and we don’t want it to have shared access to it anymore? This is the responsibility of our move constructor. 1 2 3 4 shared_reference(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept { std::swap(m_ptr, rhs.m_ptr); rhs.m_counter = 1; } Notice that we initialized rhs.m_counter to 1 and not swapped the values of m_counter, this is because we want to re-initialize the counter when it is transferred. That seems correct. But we ran into deep trouble when we decided to test this. Let us consider the following assertions: 1 2 3 4 5 6 7 shared_reference&lt;AnyType&gt;ptr_0(new AnyType()); { shared_reference&lt;AnyType&gt;ptr_1(ptr_0); { shared_reference&lt;AnyType&gt;ptr_2(ptr_1); } } For each time we instantiate an object, we reserve a representation of our model and record the states of its instances. But we do not share the states of our instances. So each time we call our reference constructor, we are actually populating unrelated state changes with our instances. That is a subtle bug, not a feature! What we actually want is to have a common ground for communication that updates all the instances of shared_reference&lt;T&gt; each time it goes out of scope. So, it seems reasonable to use static members. Let’s add the assignment overloads and debug! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 template&lt;typename T&gt; class shared_reference{ static size_t m_counter; T* m_ptr; public: shared_reference() = delete; explicit shared_reference(T* i_ptr): m_ptr(i_ptr){} explicit shared_reference(shared_reference&lt;T&gt;&amp; rhs) noexcept {rhs.copy(*this); } explicit shared_reference(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } ~shared_reference(){ m_counter -= 1; if(m_counter == 0){ m_ptr-&gt;~T(); } } T &amp;operator=(shared_reference&lt;T&gt;&amp; rhs)noexcept {rhs.copy(*this); } T &amp;operator=(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } private: void copy(shared_reference&lt;T&gt;&amp; rhs) noexcept{ m_counter += 1; rhs.m_ptr = m_ptr; } void swap(shared_reference&lt;T&gt;&amp; rhs) noexcept { std::swap(m_ptr, rhs.m_ptr); } }; template&lt;typename T&gt; size_t shared_reference&lt;T&gt;::m_counter = 1; We did it! We hit two birds with one stone. Let’s work on the pointer-like interface! Requirement: Pointer-like Interface We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer. Recall that a pointer can be dereferenced with * and -&gt; operators. And we need &amp; operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write: 1 2 3 T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(shared_reference&lt;T&gt; &amp;other) { return other.m_ptr; } Let us walk through the three lines. The first line returns a reference of *(this-&gt;m_ptr) which means that the content of m_ptr is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to m_ptr’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. Recall that a pointer has its own location in memory separate from the entities it points to. Let’s go beyond our requirement list and add little features that return the current count of our references and their contents. We call these functions count(), and get(). The implementation is equally trivial. Putting it all together 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 template&lt;typename T&gt; class shared_reference{ static size_t m_counter; T* m_ptr; public: shared_reference() = delete; explicit shared_reference(T* i_ptr): m_ptr(i_ptr){} explicit shared_reference(shared_reference&lt;T&gt;&amp; rhs) noexcept {rhs.copy(*this); } explicit shared_reference(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } ~shared_reference(){ m_counter -= 1; if(m_counter == 0){ m_ptr-&gt;~T(); } } T &amp;operator=(shared_reference&lt;T&gt;&amp; rhs)noexcept {rhs.copy(*this); } T &amp;operator=(shared_reference&lt;T&gt;&amp;&amp; rhs) noexcept {rhs.swap(*this); } T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(shared_reference&lt;T&gt; &amp;other) { return other.m_ptr; } T *get(void) { return this-&gt;m_ptr; } size_t count() const { return m_counter; } private: void copy(shared_reference&lt;T&gt;&amp; rhs) noexcept{ m_counter += 1; rhs.m_ptr = m_ptr; } void swap(shared_reference&lt;T&gt;&amp; rhs) noexcept { std::swap(m_ptr, rhs.m_ptr); } }; template&lt;typename T&gt; size_t shared_reference&lt;T&gt;::m_counter = 1; Test Cases Time to see if we satisfied our design requirements: Summary We fleshed out our design requirements and implemented our version of the shared reference to satisfy what we intend to do with shared references. Upon testing, we found that it sufficiently did what we want it to do: we now have the second piece of our automatic resource management! Since we implemented a simple shared resource management, think about how you can extend this to support indexing in an array structure. Have fun hacking! References Wikipedia contributors. (2021, June 29). Garbage collection (computer science). https://en.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science). Oracle (n.d.). Java Garbage Collection Basics. https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html. Microsoft Docs (2020). Background garbage collection. https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/background-gc. Mrale.ph (n.d.). Introduction to Dart VM. https://mrale.ph/dartvm/. Rust (n.d.). Module alloc::rc. https://doc.rust-lang.org/alloc/rc/. cppreference.com (2021). std::shared_ptr. https://en.cppreference.com/w/cpp/memory/shared_ptr. Debrie, A. (2021). Python Garbage Collection: What It Is and How it works? https://stackify.com/python-garbage-collection/. Microsoft Docs (2020). Welcome back to C++ - Modern C++. https://bityl.co/8HD7. cppreference.com (2021). static members. https://en.cppreference.com/w/cpp/language/static.","headline":"Shared References","mainEntityOfPage":{"@type":"WebPage","@id":"https://adeeconometrics.github.io//posts/Shared-Reference/"},"url":"https://adeeconometrics.github.io//posts/Shared-Reference/"}</script><title>Shared References | Dave Amiana</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dave Amiana"><meta name="application-name" content="Dave Amiana"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0M61FBNQ0K"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0M61FBNQ0K'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/profile-picture.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dave Amiana</a></div><div class="site-subtitle font-italic">Open-source and Enterprise Software Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/adeeconometrics" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/dave-amiana/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['amiana.dave','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Shared References</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Shared References</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Dave Amiana </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Aug 20, 2021, 12:00 AM +0800" prep="on" > Aug 20, 2021 <i class="unloaded">2021-08-20T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 22, 2022, 10:11 PM +0800" prefix="Updated " > Oct 22, 2022 <i class="unloaded">2022-10-22T22:11:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1739 words">9 min</span></div></div><div class="post-content"><p>In our previous discussion, we fleshed out the design requirements and took action into servicing them. In the same way, this article aims to flesh out the design requirement for shared reference.</p><p>Shared references make use of a reference counting mechanism that allows resources to be shared in different parts of the program. In some cases, this technique replaces the need for garbage collection as reference counting automatically cleans up the resources at the time it hits 0.</p><p>The implementation of shared references has a performance cost which led implementers of <a href="https://bityl.co/8H8r">garbage collection (GC) algorithms</a> to weigh their choices in implementing automatic resource management. Dynamic languages such as <a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">Java</a>, <a href="https://bityl.co/8H9G">C#</a>, and <a href="https://mrale.ph/dartvm/">Dart</a> implement more sophisticated GC’s to minimize the cost of developing applications. Some languages relied on reference counting techniques like C++ and <a href="https://doc.rust-lang.org/alloc/rc/">Rust</a> for system-level programming. And some languages like <a href="https://bityl.co/8H9l">Python</a> make use of both in combination. We can observe that the decision of choosing a resource management system depends on the intended use of the language. For instance, C++ supported smart pointers for automatic reference management while allowing manual resource management through raw pointers because the language is aimed at servicing problems that exist <a href="https://bityl.co/8HD7">from the level of the silicon to the highest levels of abstraction</a> – that is why C++ provide resource-safe automation and manual resource management.</p><p>Before we implement our shared reference class, let first us discuss the advantages and disadvantages of implementing reference counting (RC).</p><h4 id="advantages">Advantages</h4><ul><li>RC guarantees that resources are cleaned up as soon as their last reference is destroyed.<li>RC is deterministic through RAII.<li>RC is relatively simple to implement over more sophisticated GC algorithms.</ul><h4 id="disadvantages">Disadvantages</h4><ul><li>RC may leak resources in case of reference cycles.<li>RC has space overhead for reference counting.<li>RC is difficult to deal with in a multithreaded environment since it requires atomicity.</ul><p>Note that the disadvantages vary in the sophistication of RC implementation. In our last discussion, we showed the problem of reference cycles and resolved this by <code class="language-plaintext highlighter-rouge">std::weak_ptr&lt;T&gt;</code>. We will review this problem and work through solving the problem of reference cycles by implementing a <code class="language-plaintext highlighter-rouge">weak_reference</code> class.</p><p>In the meantime, let us focus on implementing our simple model of shared reference.</p><hr /><h3 id="design-goals">Design Goals</h3><p>Let us flesh out our design requirements. Our <code class="language-plaintext highlighter-rouge">shared_reference</code> class must satisfy the following:</p><ul><li>Must accept any types<li>Automatic Resource Management<li>Reference counting<li>Pointer-like interface</ul><hr /><h3 id="implementation">Implementation</h3><p>Now, we translate the design requirements into code. We will build up from it one by one.</p><h4 id="requirement-must-accept-any-type">Requirement: Must Accept any Type</h4><p>This is trivial, but let us include it here. To put this into code, we simply make use of template parameters as follows:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">shared_reference</span><span class="p">;</span>
</pre></table></code></div></div><p>Simple right? Let’s keep going!</p><h4 id="requirement-automatic-resource-management-and-reference-counting">Requirement: Automatic Resource Management and Reference Counting</h4><p>The idea is to make use of RAII – a programming idiom that gives us guarantees with resource-safe management. We simply need to fill out the resource acquisition upon construction and resource clean-up upon destruction. RAII is achieved through constructor-destructor pairs which are triggered to keep track of the object’s lifetime.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">shared_reference</span><span class="p">{</span>
<span class="n">T</span><span class="o">*</span> <span class="n">m_ptr</span><span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">shared_reference</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

   <span class="o">~</span><span class="n">shared_reference</span><span class="p">(){</span>
      <span class="k">if</span><span class="p">(</span><span class="n">m_ptr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span>
          <span class="n">m_ptr</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>
        <span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>That seems, reasonable. We initialized <code class="language-plaintext highlighter-rouge">m_ptr</code> to null and we successfully cleaned up our resources at the time it went out of scope. But that is what we did with <code class="language-plaintext highlighter-rouge">unique_reference</code>, right? How is shared reference any different?</p><p>The answer lies with the reference counting mechanism. To extend the lifetime of our objects, we have to know when it is appropriate to perform our clean-up. As mentioned, we perform our clean-up in the case where our reference count is 0. Now that we get the idea, let us put this in code.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">shared_reference</span><span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">m_counter</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
  <span class="n">T</span> <span class="o">*</span><span class="n">m_ptr</span><span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">shared_reference</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="o">~</span><span class="n">shared_reference</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">m_counter</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">m_ptr</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>
      <span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>The idea is to count how many instances that refer to <code class="language-plaintext highlighter-rouge">m_ptr</code> are still active. With RAII, we can delegate this role to our constructor; that is, for each time it creates an instance of <code class="language-plaintext highlighter-rouge">shared_reference</code> it has to increment <code class="language-plaintext highlighter-rouge">m_counter</code> and for each time it goes out of scope, it has to decrement and check if it is time for clean-up. Let’s write a copy constructor and a special constructor that takes in a <code class="language-plaintext highlighter-rouge">T*</code> parameter.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">shared_reference</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="k">explicit</span> <span class="nf">shared_reference</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">i_ptr</span><span class="p">)</span><span class="o">:</span> <span class="n">m_ptr</span><span class="p">(</span><span class="n">i_ptr</span><span class="p">){}</span>
<span class="k">explicit</span> <span class="nf">shared_reference</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">){</span>
  <span class="n">rhs</span><span class="p">.</span><span class="n">m_ptr</span> <span class="o">=</span> <span class="n">m_ptr</span><span class="p">;</span>
  <span class="n">rhs</span><span class="p">.</span><span class="n">m_counter</span> <span class="o">=</span> <span class="n">m_counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The first constructor is designed to accommodate the initialization of our reference which takes away the need for our default constructor so we deleted it. We want to tell the compiler that it is not free to deduce the default constructor in the case where we need our class to initialize the user has to explicitly bind the content of its referent.</p><p>Our <em>copy constructor</em> is not technically a copy-constructor because at the time we pass <code class="language-plaintext highlighter-rouge">shared_reference&lt;T&gt;&amp;</code> we only want it to <strong>share</strong> the contents of <code class="language-plaintext highlighter-rouge">m_ptr</code> and increment <code class="language-plaintext highlighter-rouge">m_counter</code>. What we want is to provide an interface for <em>sharing</em> references. To avoid confusion, I will refer to <code class="language-plaintext highlighter-rouge">shared_reference(shared_reference&lt;T&gt;&amp;)</code> as a reference constructor.</p><p>But if we want to transfer the ownership to another entity and we don’t want it to have shared access to it anymore? This is the responsibility of our move constructor.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">shared_reference</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_ptr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">);</span>
  <span class="n">rhs</span><span class="p">.</span><span class="n">m_counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Notice that we initialized <code class="language-plaintext highlighter-rouge">rhs.m_counter</code> to 1 and not swapped the values of <code class="language-plaintext highlighter-rouge">m_counter</code>, this is because we want to re-initialize the counter when it is transferred.</p><p>That seems correct. But we ran into deep trouble when we decided to test this. Let us consider the following assertions:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>shared_reference&lt;AnyType&gt;ptr_0(new AnyType());
{
shared_reference&lt;AnyType&gt;ptr_1(ptr_0);
  {
    shared_reference&lt;AnyType&gt;ptr_2(ptr_1);
  }
}
</pre></table></code></div></div><p>For each time we instantiate an object, we reserve a representation of our model and record the states of its instances. <strong>But we do not share the states of our instances</strong>. So each time we call our reference constructor, we are actually populating unrelated state changes with our instances.</p><blockquote><p>That is a subtle bug, not a feature!</p></blockquote><p>What we actually want is to have a common ground for communication that updates all the instances of <code class="language-plaintext highlighter-rouge">shared_reference&lt;T&gt;</code> each time it goes out of scope. So, it seems reasonable to use <a href="https://bityl.co/8JKe">static</a> members. Let’s add the assignment overloads and debug!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">shared_reference</span><span class="p">{</span>
  <span class="k">static</span> <span class="kt">size_t</span> <span class="n">m_counter</span><span class="p">;</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">m_ptr</span><span class="p">;</span>

  <span class="nl">public:</span>
    <span class="n">shared_reference</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">shared_reference</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">i_ptr</span><span class="p">)</span><span class="o">:</span> <span class="n">m_ptr</span><span class="p">(</span><span class="n">i_ptr</span><span class="p">){}</span>
    <span class="k">explicit</span> <span class="nf">shared_reference</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span>
      <span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">explicit</span> <span class="nf">shared_reference</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span>
      <span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>

    <span class="o">~</span><span class="n">shared_reference</span><span class="p">(){</span>
      <span class="n">m_counter</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">m_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">m_ptr</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="k">noexcept</span> <span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>

  <span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">copy</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">{</span>
      <span class="n">m_counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">rhs</span><span class="p">.</span><span class="n">m_ptr</span> <span class="o">=</span> <span class="n">m_ptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_ptr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">size_t</span> <span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">m_counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></table></code></div></div><p>We did it! We hit two birds with one stone. Let’s work on the pointer-like interface!</p><h4 id="requirement-pointer-like-interface">Requirement: Pointer-like Interface</h4><p>We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer.</p><p>Recall that a pointer can be dereferenced with <code class="language-plaintext highlighter-rouge">*</code> and <code class="language-plaintext highlighter-rouge">-&gt;</code> operators. And we need <code class="language-plaintext highlighter-rouge">&amp;</code> operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">T</span> <span class="o">*</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&amp;</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">other</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
</pre></table></code></div></div><p>Let us walk through the three lines.</p><p>The first line returns a reference of <code class="language-plaintext highlighter-rouge">*(this-&gt;m_ptr)</code> which means that the content of <code class="language-plaintext highlighter-rouge">m_ptr</code> is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to <code class="language-plaintext highlighter-rouge">m_ptr</code>’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. <a href="https://dcode.hashnode.dev/pointers-and-references-design-goals-and-use-cases">Recall</a> that a pointer has its own location in memory separate from the entities it points to.</p><p>Let’s go beyond our requirement list and add little features that return the current count of our references and their contents. We call these functions <code class="language-plaintext highlighter-rouge">count()</code>, and <code class="language-plaintext highlighter-rouge">get()</code>. The implementation is equally trivial.</p><hr /><h3 id="putting-it-all-together">Putting it all together</h3><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">shared_reference</span><span class="p">{</span>
  <span class="k">static</span> <span class="kt">size_t</span> <span class="n">m_counter</span><span class="p">;</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">m_ptr</span><span class="p">;</span>

  <span class="nl">public:</span>
    <span class="n">shared_reference</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">shared_reference</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">i_ptr</span><span class="p">)</span><span class="o">:</span> <span class="n">m_ptr</span><span class="p">(</span><span class="n">i_ptr</span><span class="p">){}</span>
    <span class="k">explicit</span> <span class="nf">shared_reference</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span>
      <span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
    <span class="k">explicit</span> <span class="nf">shared_reference</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span>
      <span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>

    <span class="o">~</span><span class="n">shared_reference</span><span class="p">(){</span>
      <span class="n">m_counter</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="n">m_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">m_ptr</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="k">noexcept</span> <span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">T</span> <span class="o">*</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&amp;</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">other</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">T</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">count</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_counter</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">copy</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">{</span>
      <span class="n">m_counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">rhs</span><span class="p">.</span><span class="n">m_ptr</span> <span class="o">=</span> <span class="n">m_ptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m_ptr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">size_t</span> <span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">m_counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></table></code></div></div><hr /><h3 id="test-cases">Test Cases</h3><p>Time to see if we satisfied our design requirements:</p><iframe height="700px" width="100%" src="https://replit.com/@delvinjohn/SharedReference?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe><hr /><h3 id="summary">Summary</h3><p>We fleshed out our design requirements and implemented our version of the shared reference to satisfy what we intend to do with shared references. Upon testing, we found that it sufficiently did what we want it to do: we now have the second piece of our automatic resource management!</p><p>Since we implemented a simple shared resource management, think about how you can extend this to support indexing in an array structure.</p><p>Have fun hacking!</p><hr /><h3 id="references">References</h3><ul><li><p>Wikipedia contributors. (2021, June 29). Garbage collection (computer science). https://en.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science).</p><li><p>Oracle (n.d.). Java Garbage Collection Basics. https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html.</p><li><p>Microsoft Docs (2020). Background garbage collection. https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/background-gc.</p><li><p>Mrale.ph (n.d.). Introduction to Dart VM. https://mrale.ph/dartvm/.</p><li><p>Rust (n.d.). Module alloc::rc. https://doc.rust-lang.org/alloc/rc/.</p><li><p>cppreference.com (2021). std::shared_ptr. https://en.cppreference.com/w/cpp/memory/shared_ptr.</p><li><p>Debrie, A. (2021). Python Garbage Collection: What It Is and How it works? https://stackify.com/python-garbage-collection/.</p><li><p>Microsoft Docs (2020). Welcome back to C++ - Modern C++. https://bityl.co/8HD7.</p><li><p>cppreference.com (2021). static members. https://en.cppreference.com/w/cpp/language/static.</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a>, <a href='/categories/computer-science/'>Computer Science</a>, <a href='/categories/c/'>C++</a>, <a href='/categories/ownership-semantics/'>Ownership Semantics</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/programming/" class="post-tag no-text-decoration" >programming</a> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/ownership-semantics/" class="post-tag no-text-decoration" >Ownership Semantics</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Shared References - Dave Amiana&url=https://adeeconometrics.github.io//posts/Shared-Reference/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Shared References - Dave Amiana&u=https://adeeconometrics.github.io//posts/Shared-Reference/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Shared References - Dave Amiana&url=https://adeeconometrics.github.io//posts/Shared-Reference/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/On-Pointer-Types/">On Pointer Types</a><li><a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/">Pointers and References: Design Goals and Use Cases</a><li><a href="/posts/Unique-Reference/">Unique References</a><li><a href="/posts/Shared-Reference/">Shared References</a><li><a href="/posts/Weak-Reference/">Weak References</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/On-Pointer-Types/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>On Pointer Types</h3><div class="text-muted small"><p> In this article, I aim to introduce the concept and motivation behind using pointers. There are breeds of C++ developers that only use smart pointers for safety reasons, others that only use raw po...</p></div></div></a></div><div class="card"> <a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Pointers and References: Design Goals and Use Cases</h3><div class="text-muted small"><p> At first, it seems that C++ makes things more complicated by introducing yet another layer of abstraction. References seem to encapsulate the same set of functionalities as pointers. Both of these ...</p></div></div></a></div><div class="card"> <a href="/posts/Unique-Reference/"><div class="card-body"> <span class="timeago small" > Aug 17, 2021 <i class="unloaded">2021-08-17T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Unique References</h3><div class="text-muted small"><p> Our previous discussion explores the anatomy of pointer types in C and C++ on par with hinting nuances of reference semantics. We discussed the use cases of raw pointers and smart pointers in moder...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Unique-Reference/" class="btn btn-outline-primary" prompt="Older"><p>Unique References</p></a> <a href="/posts/Weak-Reference/" class="btn btn-outline-primary" prompt="Newer"><p>Weak References</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/iamdeb25">Dave Amiana</a>.</p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://adeeconometrics.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
