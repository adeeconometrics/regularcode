<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Programming for Beginners" /><meta name="author" content="Dave Amiana" /><meta property="og:locale" content="en_US" /><meta name="description" content="Programming is a form of communication as it attempts to convey your idea to a recipient, but you have to be direct and unambiguous with your statements. The languages we use to converse with another person are languages with much ambiguity than the kinds of languages we use to communicate with computers. Humans can understand the context and the manner of delivering a message. Computers, on the other hand, are very pedantic as it requires you have to get into their language and talk with them otherwise they will never understand you. The idea is simple: reorganize your thoughts in a language a computer can understand. But why should you do this? There are two good reasons that I can think of: (1) it is an intellectually engaging activity that improves how you think of a problem; (2) it is a place to preserve your ideas and fiddle around with them. Computer languages, like mathematics, have a rigid set of rules that we call grammar. It has the property of preserving meaning and structure, and for this reason, we call them formal languages. Unlike natural languages, which we speak with people, formal languages are definite. It is meant to disambiguate and keep their structures intact. This is a whole area of discussion, so I’ll leave this hanging for now. When I started programming, the very first question I had in mind was to think about what constitutes a programming language and how does it work? I asked my friends in CS the sorts of questions they had when they first started programming, and most of them thought of the applications they can do in a programming language. So let’s dive into these questions a little bit: A programming language is composed of a set of symbols, rules, and the corresponding meaning of their combinations – we call this syntax and semantics. Such a combination should be expressive enough in performing an algorithm that is essential for solving a particular problem in a particular domain. Languages that extend on multiple domains may be broadly categorized as general-purpose programming languages. In other words, a programming language is composed of a set of elementary concepts that extends their support for a particular problem domain – such a domain tailors the set of applications a programming language supports. For instance, SQL is a domain-specific language that is meant for data management – it is specialized for that purpose, therein exclusively for database transactions. On the other hand, consider Python, a general-purpose programming language as it supports multiple programming paradigms for a broad range of problem domains like numerical analysis, web development, and the things in between. Let’s look at some code snippets from SQL and Python. 1 2 --- SQL code for searching customers in &#39;Mexico&#39; SELECT * FROM Customers WHERE country = &#39;Mexico&#39;; The code snippet above describes an objective which is to find customers from Mexico, whereas the code snippet below specifies how to filter a string from a file assuming that a file is organized into a tuple of (customer, country). 1 2 3 4 5 6 7 # python function for retrieving a match given a file def find_match(fname:str, country = &#39;Mexico&#39;)-&gt;list[tuple]: with open(fname, &#39;r&#39;, encoding = &#39;utf8&#39;) as rf: customers = rf.read().split(&#39;\n&#39;) match = [(element[0], element[1]) for element in customers if element[1] == country] return match As we can observe, imperative programming in Python specifies the computational steps to get the desired output, where the declarative style of SQL describes the output. Another thing to mention is that Python does support a (functional) declarative style of programming and SQL-like interface with the use of some modules such as Pandas. Python does even extend for other features of programming such as object-oriented and functional programming, making it a general-purpose language. Now that we know that there can be different styles of programming, and each of these styles varies per our application domain, let’s turn our focus on these styles and some of their noteworthy features. What is a programming paradigm? Programming paradigms are means to organize programming languages based on their features. A programming language can support multiple paradigms like in Python – it supports* object-oriented programming, functional programming, and procedural programming* to name a few. While SQL is designed to be declarative. Let’s break down these paradigms for a bit. While the list we discuss here is by no means exhaustive, they are the most common which should be sufficient as we grow familiar with these concepts: imperative programming focus on specifying the computational steps to get through a process. Two prominent styles encapsulate the spirit of imperative programming: procedural object-oriented declarative programming focus on describing the desired result of a computational process. Two prominent styles capture the essence of declarative programming: functional logic Let’s begin with imperative programming. As we have seen earlier, imperative programming tends to specify how a computational process might achieve a goal. Given our language, take Python, for instance, we can combine strings for tuning our (imperative) logic forming a control system for guiding our program in achieving a particular goal. As we can imagine, there are nearly infinite combinations of strings that essentially capture the essence of your process. Because of the broad design space, we require organization. That is where procedural programming and object-oriented programming comes in. Procedural and Object-oriented programming is a means to organize our process. We can think of them as two different worldviews where our code lives. In the lens of procedural programming, we break down the process using their functionalities – often this is called functional programming but it that can only lead us to confusion for a functional programming language is fundamentally different as we will see later. Here’s a snippet of a procedure in Python: 1 2 def add(a:int, b:int)-&gt;int: return a+b In the code above, we take two integers and add them together. The function then returns the sum of our inputs as a result of the process. In object-oriented programming, we think of everything as objects: a collection of attributes and behaviors. Object-oriented programming neatly supports an organization a chunk of code by its concepts which is essentially how we naturally associate concepts. Consider the code below: 1 2 3 4 5 6 7 8 9 10 11 12 13 class Humans: def __init__(self, name:str, age:int) -&gt;None: self.name = name self.age = age def eat(food:str)-&gt;None: print(&quot;eating &quot; + food) def sleep()-&gt;None: print(&quot;sleeping&quot;) def talk()-&gt;None: print(&quot;I&#39;m talking&quot;) def poop()-&gt;None: print(&quot;I&#39;m pooping&quot;) Whereas imperative programming commands for certain actions, a declarative language we demands for an output. We do not care how a process is implemented, instead, we focus on describing our output and getting it right. Let’s introduce a new language called Haskell. Haskell is a purely functional programming language, and we’ll see what we meant by purely functional in a bit. Consider this code: 1 2 3 4 5 6 7 in_range :: Integer-&gt;Integer-&gt;Bool in_range min max x = let in_lower_bound = min &lt;= x in_upper_bound = max&lt;= y in lower_bound &amp;&amp; upper_bound -- returns true if x is in range Haskell is a purely functional language, which means that functions generally have no side effects. A distinct construct exists to represent side effects, orthogonal to the type of functions. A pure function can return a side effect that is subsequently executed, modeling the impure functions of other languages [1]. In functional programming, you don’t have objects or methods, as we introduced earlier. You only have functions. The idea came from mathematics which makes languages such as Haskell known among mathematicians. The declarative style of functional language allows you to focus on what to solve rather than how to solve it. It stems from the idea that we can break down everything as functions. Since functional programming has drawn inspiration from mathematics, functions are expected to have no side effects. What are these side effects? In imperative languages such as Python or C++, there can be objects that are left unresolved. I think of them as ghosts from the future past since they live freely in your program. Creeping, undetected. The trouble with this is that they can introduce unforeseen bugs that could ruin your program. Moving on with logic programming. Let’s introduce another language called Prolog. Prolog has drawn inspiration from first-order logic and was designed to be declarative. Let’s not worry about what first-order logic is, for now, all we need to know is that prolog has drawn inspiration from (declarative) logic, unlike imperative languages which came from imperative logic which is procedure-oriented. let’s focus on the declarative style of logic programming 1 2 3 4 5 6 7 8 9 10 /*facts: characters and their relationships*/ characters(ted). characters(marshall). characters(barney). characters(lily). characters(robin). likes(marshall, lily). likes(ted, robin). likes(barney, robin). In Prolog, program logic is expressed in terms of relations, and computation is initiated by running a query over these relations. Relations and queries are constructed using Prolog’s single data type, the term [2]. The above code contains the characters of How I Met Your Mother. We can query from that file that contains the characters and verify their relationships. For instance 1 2 3 4 character(chandler). /*outputs &quot;false.&quot;*/ likes(Wholikes, barney) /*outputs &quot;Wholikes = robin.&quot;*/ Let’s look at one can represent such a relationship in predicate logic: \(Likes(x,y) | \ x = \text{barney}, y = \text{robin}\) If ever you worry about the new languages I keep throwing in, keep in mind that you should only focus on how it was written and some of the inspirations that led to programming syntax for this will give you a sense of navigating the space of programming languages. We will have deeper dives into these topics in the future. Another way of mapping through the space of programming languages Another way to categorize programming language is through the lens of compiled or interpreted. A compiled language tends to be much faster than an interpreted language. During compilation, the compiler scans the whole program and translates the whole of it into a machine code that a computer can process. An interpreter, on the other hand, translates one statement of the program into a machine code, one at a time. If you worry about performance, you might look into the language specification either they are compiled or interpreted. What makes a language worth it to learn? Take the words from world-class developers for this: At the end of the day, what keeps you learning and working on language will be based on your own interests. What sorts of things fascinate you? What application domain should you focus on? and what territories should you explore further? As you move towards the direction of your interest, you find a set of ideas that are familiar to you, possibly because you had fiddled with some concepts on functional programming. This insight will be very helpful as you think about the design of your program. So, having a little knowledge of different programming paradigms will be helpful for your intuition. References: Wikipedia contributors. (2021, April 13). Haskell (programming language). In Wikipedia, The Free Encyclopedia. Retrieved 06:56, April 16, 2021, from https://en.wikipedia.org/w/index.php?title=Haskell_(programming_language)&amp;oldid=1017562573 Lloyd, J. W. (1984). Foundations of logic programming. Berlin: Springer-Verlag. ISBN 978-3-540-13299-8." /><meta property="og:description" content="Programming is a form of communication as it attempts to convey your idea to a recipient, but you have to be direct and unambiguous with your statements. The languages we use to converse with another person are languages with much ambiguity than the kinds of languages we use to communicate with computers. Humans can understand the context and the manner of delivering a message. Computers, on the other hand, are very pedantic as it requires you have to get into their language and talk with them otherwise they will never understand you. The idea is simple: reorganize your thoughts in a language a computer can understand. But why should you do this? There are two good reasons that I can think of: (1) it is an intellectually engaging activity that improves how you think of a problem; (2) it is a place to preserve your ideas and fiddle around with them. Computer languages, like mathematics, have a rigid set of rules that we call grammar. It has the property of preserving meaning and structure, and for this reason, we call them formal languages. Unlike natural languages, which we speak with people, formal languages are definite. It is meant to disambiguate and keep their structures intact. This is a whole area of discussion, so I’ll leave this hanging for now. When I started programming, the very first question I had in mind was to think about what constitutes a programming language and how does it work? I asked my friends in CS the sorts of questions they had when they first started programming, and most of them thought of the applications they can do in a programming language. So let’s dive into these questions a little bit: A programming language is composed of a set of symbols, rules, and the corresponding meaning of their combinations – we call this syntax and semantics. Such a combination should be expressive enough in performing an algorithm that is essential for solving a particular problem in a particular domain. Languages that extend on multiple domains may be broadly categorized as general-purpose programming languages. In other words, a programming language is composed of a set of elementary concepts that extends their support for a particular problem domain – such a domain tailors the set of applications a programming language supports. For instance, SQL is a domain-specific language that is meant for data management – it is specialized for that purpose, therein exclusively for database transactions. On the other hand, consider Python, a general-purpose programming language as it supports multiple programming paradigms for a broad range of problem domains like numerical analysis, web development, and the things in between. Let’s look at some code snippets from SQL and Python. 1 2 --- SQL code for searching customers in &#39;Mexico&#39; SELECT * FROM Customers WHERE country = &#39;Mexico&#39;; The code snippet above describes an objective which is to find customers from Mexico, whereas the code snippet below specifies how to filter a string from a file assuming that a file is organized into a tuple of (customer, country). 1 2 3 4 5 6 7 # python function for retrieving a match given a file def find_match(fname:str, country = &#39;Mexico&#39;)-&gt;list[tuple]: with open(fname, &#39;r&#39;, encoding = &#39;utf8&#39;) as rf: customers = rf.read().split(&#39;\n&#39;) match = [(element[0], element[1]) for element in customers if element[1] == country] return match As we can observe, imperative programming in Python specifies the computational steps to get the desired output, where the declarative style of SQL describes the output. Another thing to mention is that Python does support a (functional) declarative style of programming and SQL-like interface with the use of some modules such as Pandas. Python does even extend for other features of programming such as object-oriented and functional programming, making it a general-purpose language. Now that we know that there can be different styles of programming, and each of these styles varies per our application domain, let’s turn our focus on these styles and some of their noteworthy features. What is a programming paradigm? Programming paradigms are means to organize programming languages based on their features. A programming language can support multiple paradigms like in Python – it supports* object-oriented programming, functional programming, and procedural programming* to name a few. While SQL is designed to be declarative. Let’s break down these paradigms for a bit. While the list we discuss here is by no means exhaustive, they are the most common which should be sufficient as we grow familiar with these concepts: imperative programming focus on specifying the computational steps to get through a process. Two prominent styles encapsulate the spirit of imperative programming: procedural object-oriented declarative programming focus on describing the desired result of a computational process. Two prominent styles capture the essence of declarative programming: functional logic Let’s begin with imperative programming. As we have seen earlier, imperative programming tends to specify how a computational process might achieve a goal. Given our language, take Python, for instance, we can combine strings for tuning our (imperative) logic forming a control system for guiding our program in achieving a particular goal. As we can imagine, there are nearly infinite combinations of strings that essentially capture the essence of your process. Because of the broad design space, we require organization. That is where procedural programming and object-oriented programming comes in. Procedural and Object-oriented programming is a means to organize our process. We can think of them as two different worldviews where our code lives. In the lens of procedural programming, we break down the process using their functionalities – often this is called functional programming but it that can only lead us to confusion for a functional programming language is fundamentally different as we will see later. Here’s a snippet of a procedure in Python: 1 2 def add(a:int, b:int)-&gt;int: return a+b In the code above, we take two integers and add them together. The function then returns the sum of our inputs as a result of the process. In object-oriented programming, we think of everything as objects: a collection of attributes and behaviors. Object-oriented programming neatly supports an organization a chunk of code by its concepts which is essentially how we naturally associate concepts. Consider the code below: 1 2 3 4 5 6 7 8 9 10 11 12 13 class Humans: def __init__(self, name:str, age:int) -&gt;None: self.name = name self.age = age def eat(food:str)-&gt;None: print(&quot;eating &quot; + food) def sleep()-&gt;None: print(&quot;sleeping&quot;) def talk()-&gt;None: print(&quot;I&#39;m talking&quot;) def poop()-&gt;None: print(&quot;I&#39;m pooping&quot;) Whereas imperative programming commands for certain actions, a declarative language we demands for an output. We do not care how a process is implemented, instead, we focus on describing our output and getting it right. Let’s introduce a new language called Haskell. Haskell is a purely functional programming language, and we’ll see what we meant by purely functional in a bit. Consider this code: 1 2 3 4 5 6 7 in_range :: Integer-&gt;Integer-&gt;Bool in_range min max x = let in_lower_bound = min &lt;= x in_upper_bound = max&lt;= y in lower_bound &amp;&amp; upper_bound -- returns true if x is in range Haskell is a purely functional language, which means that functions generally have no side effects. A distinct construct exists to represent side effects, orthogonal to the type of functions. A pure function can return a side effect that is subsequently executed, modeling the impure functions of other languages [1]. In functional programming, you don’t have objects or methods, as we introduced earlier. You only have functions. The idea came from mathematics which makes languages such as Haskell known among mathematicians. The declarative style of functional language allows you to focus on what to solve rather than how to solve it. It stems from the idea that we can break down everything as functions. Since functional programming has drawn inspiration from mathematics, functions are expected to have no side effects. What are these side effects? In imperative languages such as Python or C++, there can be objects that are left unresolved. I think of them as ghosts from the future past since they live freely in your program. Creeping, undetected. The trouble with this is that they can introduce unforeseen bugs that could ruin your program. Moving on with logic programming. Let’s introduce another language called Prolog. Prolog has drawn inspiration from first-order logic and was designed to be declarative. Let’s not worry about what first-order logic is, for now, all we need to know is that prolog has drawn inspiration from (declarative) logic, unlike imperative languages which came from imperative logic which is procedure-oriented. let’s focus on the declarative style of logic programming 1 2 3 4 5 6 7 8 9 10 /*facts: characters and their relationships*/ characters(ted). characters(marshall). characters(barney). characters(lily). characters(robin). likes(marshall, lily). likes(ted, robin). likes(barney, robin). In Prolog, program logic is expressed in terms of relations, and computation is initiated by running a query over these relations. Relations and queries are constructed using Prolog’s single data type, the term [2]. The above code contains the characters of How I Met Your Mother. We can query from that file that contains the characters and verify their relationships. For instance 1 2 3 4 character(chandler). /*outputs &quot;false.&quot;*/ likes(Wholikes, barney) /*outputs &quot;Wholikes = robin.&quot;*/ Let’s look at one can represent such a relationship in predicate logic: \(Likes(x,y) | \ x = \text{barney}, y = \text{robin}\) If ever you worry about the new languages I keep throwing in, keep in mind that you should only focus on how it was written and some of the inspirations that led to programming syntax for this will give you a sense of navigating the space of programming languages. We will have deeper dives into these topics in the future. Another way of mapping through the space of programming languages Another way to categorize programming language is through the lens of compiled or interpreted. A compiled language tends to be much faster than an interpreted language. During compilation, the compiler scans the whole program and translates the whole of it into a machine code that a computer can process. An interpreter, on the other hand, translates one statement of the program into a machine code, one at a time. If you worry about performance, you might look into the language specification either they are compiled or interpreted. What makes a language worth it to learn? Take the words from world-class developers for this: At the end of the day, what keeps you learning and working on language will be based on your own interests. What sorts of things fascinate you? What application domain should you focus on? and what territories should you explore further? As you move towards the direction of your interest, you find a set of ideas that are familiar to you, possibly because you had fiddled with some concepts on functional programming. This insight will be very helpful as you think about the design of your program. So, having a little knowledge of different programming paradigms will be helpful for your intuition. References: Wikipedia contributors. (2021, April 13). Haskell (programming language). In Wikipedia, The Free Encyclopedia. Retrieved 06:56, April 16, 2021, from https://en.wikipedia.org/w/index.php?title=Haskell_(programming_language)&amp;oldid=1017562573 Lloyd, J. W. (1984). Foundations of logic programming. Berlin: Springer-Verlag. ISBN 978-3-540-13299-8." /><link rel="canonical" href="https://adeeconometrics.github.io//posts/Programming-for-Beginners/" /><meta property="og:url" content="https://adeeconometrics.github.io//posts/Programming-for-Beginners/" /><meta property="og:site_name" content="Dave Amiana" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-02-16T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Programming for Beginners" /><meta name="twitter:site" content="@iamdeb25" /><meta name="twitter:creator" content="@Dave Amiana" /><meta name="google-site-verification" content="google-site-verification=28bVbRErS2VwJaonXuu3GbqmRlyNvizt6I00B2kQh88" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Dave Amiana"},"dateModified":"2022-10-22T22:11:50+08:00","datePublished":"2021-02-16T00:00:00+08:00","description":"Programming is a form of communication as it attempts to convey your idea to a recipient, but you have to be direct and unambiguous with your statements. The languages we use to converse with another person are languages with much ambiguity than the kinds of languages we use to communicate with computers. Humans can understand the context and the manner of delivering a message. Computers, on the other hand, are very pedantic as it requires you have to get into their language and talk with them otherwise they will never understand you. The idea is simple: reorganize your thoughts in a language a computer can understand. But why should you do this? There are two good reasons that I can think of: (1) it is an intellectually engaging activity that improves how you think of a problem; (2) it is a place to preserve your ideas and fiddle around with them. Computer languages, like mathematics, have a rigid set of rules that we call grammar. It has the property of preserving meaning and structure, and for this reason, we call them formal languages. Unlike natural languages, which we speak with people, formal languages are definite. It is meant to disambiguate and keep their structures intact. This is a whole area of discussion, so I’ll leave this hanging for now. When I started programming, the very first question I had in mind was to think about what constitutes a programming language and how does it work? I asked my friends in CS the sorts of questions they had when they first started programming, and most of them thought of the applications they can do in a programming language. So let’s dive into these questions a little bit: A programming language is composed of a set of symbols, rules, and the corresponding meaning of their combinations – we call this syntax and semantics. Such a combination should be expressive enough in performing an algorithm that is essential for solving a particular problem in a particular domain. Languages that extend on multiple domains may be broadly categorized as general-purpose programming languages. In other words, a programming language is composed of a set of elementary concepts that extends their support for a particular problem domain – such a domain tailors the set of applications a programming language supports. For instance, SQL is a domain-specific language that is meant for data management – it is specialized for that purpose, therein exclusively for database transactions. On the other hand, consider Python, a general-purpose programming language as it supports multiple programming paradigms for a broad range of problem domains like numerical analysis, web development, and the things in between. Let’s look at some code snippets from SQL and Python. 1 2 --- SQL code for searching customers in &#39;Mexico&#39; SELECT * FROM Customers WHERE country = &#39;Mexico&#39;; The code snippet above describes an objective which is to find customers from Mexico, whereas the code snippet below specifies how to filter a string from a file assuming that a file is organized into a tuple of (customer, country). 1 2 3 4 5 6 7 # python function for retrieving a match given a file def find_match(fname:str, country = &#39;Mexico&#39;)-&gt;list[tuple]: with open(fname, &#39;r&#39;, encoding = &#39;utf8&#39;) as rf: customers = rf.read().split(&#39;\\n&#39;) match = [(element[0], element[1]) for element in customers if element[1] == country] return match As we can observe, imperative programming in Python specifies the computational steps to get the desired output, where the declarative style of SQL describes the output. Another thing to mention is that Python does support a (functional) declarative style of programming and SQL-like interface with the use of some modules such as Pandas. Python does even extend for other features of programming such as object-oriented and functional programming, making it a general-purpose language. Now that we know that there can be different styles of programming, and each of these styles varies per our application domain, let’s turn our focus on these styles and some of their noteworthy features. What is a programming paradigm? Programming paradigms are means to organize programming languages based on their features. A programming language can support multiple paradigms like in Python – it supports* object-oriented programming, functional programming, and procedural programming* to name a few. While SQL is designed to be declarative. Let’s break down these paradigms for a bit. While the list we discuss here is by no means exhaustive, they are the most common which should be sufficient as we grow familiar with these concepts: imperative programming focus on specifying the computational steps to get through a process. Two prominent styles encapsulate the spirit of imperative programming: procedural object-oriented declarative programming focus on describing the desired result of a computational process. Two prominent styles capture the essence of declarative programming: functional logic Let’s begin with imperative programming. As we have seen earlier, imperative programming tends to specify how a computational process might achieve a goal. Given our language, take Python, for instance, we can combine strings for tuning our (imperative) logic forming a control system for guiding our program in achieving a particular goal. As we can imagine, there are nearly infinite combinations of strings that essentially capture the essence of your process. Because of the broad design space, we require organization. That is where procedural programming and object-oriented programming comes in. Procedural and Object-oriented programming is a means to organize our process. We can think of them as two different worldviews where our code lives. In the lens of procedural programming, we break down the process using their functionalities – often this is called functional programming but it that can only lead us to confusion for a functional programming language is fundamentally different as we will see later. Here’s a snippet of a procedure in Python: 1 2 def add(a:int, b:int)-&gt;int: return a+b In the code above, we take two integers and add them together. The function then returns the sum of our inputs as a result of the process. In object-oriented programming, we think of everything as objects: a collection of attributes and behaviors. Object-oriented programming neatly supports an organization a chunk of code by its concepts which is essentially how we naturally associate concepts. Consider the code below: 1 2 3 4 5 6 7 8 9 10 11 12 13 class Humans: def __init__(self, name:str, age:int) -&gt;None: self.name = name self.age = age def eat(food:str)-&gt;None: print(&quot;eating &quot; + food) def sleep()-&gt;None: print(&quot;sleeping&quot;) def talk()-&gt;None: print(&quot;I&#39;m talking&quot;) def poop()-&gt;None: print(&quot;I&#39;m pooping&quot;) Whereas imperative programming commands for certain actions, a declarative language we demands for an output. We do not care how a process is implemented, instead, we focus on describing our output and getting it right. Let’s introduce a new language called Haskell. Haskell is a purely functional programming language, and we’ll see what we meant by purely functional in a bit. Consider this code: 1 2 3 4 5 6 7 in_range :: Integer-&gt;Integer-&gt;Bool in_range min max x = let in_lower_bound = min &lt;= x in_upper_bound = max&lt;= y in lower_bound &amp;&amp; upper_bound -- returns true if x is in range Haskell is a purely functional language, which means that functions generally have no side effects. A distinct construct exists to represent side effects, orthogonal to the type of functions. A pure function can return a side effect that is subsequently executed, modeling the impure functions of other languages [1]. In functional programming, you don’t have objects or methods, as we introduced earlier. You only have functions. The idea came from mathematics which makes languages such as Haskell known among mathematicians. The declarative style of functional language allows you to focus on what to solve rather than how to solve it. It stems from the idea that we can break down everything as functions. Since functional programming has drawn inspiration from mathematics, functions are expected to have no side effects. What are these side effects? In imperative languages such as Python or C++, there can be objects that are left unresolved. I think of them as ghosts from the future past since they live freely in your program. Creeping, undetected. The trouble with this is that they can introduce unforeseen bugs that could ruin your program. Moving on with logic programming. Let’s introduce another language called Prolog. Prolog has drawn inspiration from first-order logic and was designed to be declarative. Let’s not worry about what first-order logic is, for now, all we need to know is that prolog has drawn inspiration from (declarative) logic, unlike imperative languages which came from imperative logic which is procedure-oriented. let’s focus on the declarative style of logic programming 1 2 3 4 5 6 7 8 9 10 /*facts: characters and their relationships*/ characters(ted). characters(marshall). characters(barney). characters(lily). characters(robin). likes(marshall, lily). likes(ted, robin). likes(barney, robin). In Prolog, program logic is expressed in terms of relations, and computation is initiated by running a query over these relations. Relations and queries are constructed using Prolog’s single data type, the term [2]. The above code contains the characters of How I Met Your Mother. We can query from that file that contains the characters and verify their relationships. For instance 1 2 3 4 character(chandler). /*outputs &quot;false.&quot;*/ likes(Wholikes, barney) /*outputs &quot;Wholikes = robin.&quot;*/ Let’s look at one can represent such a relationship in predicate logic: \\(Likes(x,y) | \\ x = \\text{barney}, y = \\text{robin}\\) If ever you worry about the new languages I keep throwing in, keep in mind that you should only focus on how it was written and some of the inspirations that led to programming syntax for this will give you a sense of navigating the space of programming languages. We will have deeper dives into these topics in the future. Another way of mapping through the space of programming languages Another way to categorize programming language is through the lens of compiled or interpreted. A compiled language tends to be much faster than an interpreted language. During compilation, the compiler scans the whole program and translates the whole of it into a machine code that a computer can process. An interpreter, on the other hand, translates one statement of the program into a machine code, one at a time. If you worry about performance, you might look into the language specification either they are compiled or interpreted. What makes a language worth it to learn? Take the words from world-class developers for this: At the end of the day, what keeps you learning and working on language will be based on your own interests. What sorts of things fascinate you? What application domain should you focus on? and what territories should you explore further? As you move towards the direction of your interest, you find a set of ideas that are familiar to you, possibly because you had fiddled with some concepts on functional programming. This insight will be very helpful as you think about the design of your program. So, having a little knowledge of different programming paradigms will be helpful for your intuition. References: Wikipedia contributors. (2021, April 13). Haskell (programming language). In Wikipedia, The Free Encyclopedia. Retrieved 06:56, April 16, 2021, from https://en.wikipedia.org/w/index.php?title=Haskell_(programming_language)&amp;oldid=1017562573 Lloyd, J. W. (1984). Foundations of logic programming. Berlin: Springer-Verlag. ISBN 978-3-540-13299-8.","headline":"Programming for Beginners","mainEntityOfPage":{"@type":"WebPage","@id":"https://adeeconometrics.github.io//posts/Programming-for-Beginners/"},"url":"https://adeeconometrics.github.io//posts/Programming-for-Beginners/"}</script><title>Programming for Beginners | Dave Amiana</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dave Amiana"><meta name="application-name" content="Dave Amiana"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0M61FBNQ0K"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0M61FBNQ0K'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/profile-picture.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dave Amiana</a></div><div class="site-subtitle font-italic">Open-source and Enterprise Software Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/adeeconometrics" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/dave-amiana/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['amiana.dave','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Programming for Beginners</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Programming for Beginners</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Dave Amiana </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Feb 16, 2021, 12:00 AM +0800" prep="on" > Feb 16, 2021 <i class="unloaded">2021-02-16T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 22, 2022, 10:11 PM +0800" prefix="Updated " > Oct 22, 2022 <i class="unloaded">2022-10-22T22:11:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1861 words">10 min</span></div></div><div class="post-content"><p>Programming is a form of communication as it attempts to convey your idea to a recipient, but you have to be direct and unambiguous with your statements. The languages we use to converse with another person are languages with much ambiguity than the kinds of languages we use to communicate with computers. Humans can understand the context and the manner of delivering a message. Computers, on the other hand, are very pedantic as it requires you have to get into their language and talk with them otherwise they will never understand you.</p><p>The idea is simple: <strong>reorganize your thoughts in a language a computer can understand</strong>. But why should you do this? There are two good reasons that I can think of: (1) it is an intellectually engaging activity that improves how you think of a problem; (2) it is a place to preserve your ideas and fiddle around with them.</p><p>Computer languages, like mathematics, have a rigid set of rules that we call grammar. It has the property of preserving meaning and structure, and for this reason, we call them formal languages. Unlike natural languages, which we speak with people, formal languages are definite. It is meant to disambiguate and keep their structures intact.</p><blockquote><p>This is a whole <a href="https://en.wikipedia.org/wiki/Formal_language">area of discussion</a>, so I’ll leave this hanging for now.</p></blockquote><p>When I started programming, the very first question I had in mind was to think about what constitutes a programming language and how does it work? I asked my friends in CS the sorts of questions they had when they first started programming, and most of them thought of the applications they can do in a programming language. So let’s dive into these questions a little bit:</p><blockquote><p>A programming language is composed of a set of symbols, rules, and the corresponding meaning of their combinations – we call this syntax and semantics. Such a combination should be expressive enough in performing an algorithm that is essential for solving a particular problem in a particular domain. Languages that extend on multiple domains may be broadly categorized as general-purpose programming languages.</p></blockquote><p>In other words, a programming language is composed of a set of elementary concepts that extends their support for a particular problem domain – such a domain tailors the set of applications a programming language supports.</p><p>For instance, <code class="language-plaintext highlighter-rouge">SQL</code> is a domain-specific language that is meant for data management – it is specialized for that purpose, therein exclusively for database transactions. On the other hand, consider <code class="language-plaintext highlighter-rouge">Python</code>, a general-purpose programming language as it supports multiple programming paradigms for a broad range of problem domains like numerical analysis, web development, and the things in between.</p><p>Let’s look at some code snippets from <code class="language-plaintext highlighter-rouge">SQL</code> and <code class="language-plaintext highlighter-rouge">Python</code>.</p><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">--- SQL code for searching customers in 'Mexico'</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">Customers</span> <span class="k">WHERE</span> <span class="n">country</span> <span class="o">=</span> <span class="s1">'Mexico'</span><span class="p">;</span>
</pre></table></code></div></div><p>The code snippet above <em>describes</em> an objective which is to find customers from Mexico, whereas the code snippet below <em>specifies</em> how to filter a string from a file assuming that a file is organized into a <code class="language-plaintext highlighter-rouge">tuple</code> of <code class="language-plaintext highlighter-rouge">(customer, country)</code>.</p><div class="language-py highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1"># python function for retrieving a match given a file
</span><span class="k">def</span> <span class="nf">find_match</span><span class="p">(</span><span class="n">fname</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">country</span> <span class="o">=</span> <span class="sh">'</span><span class="s">Mexico</span><span class="sh">'</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">,</span> <span class="n">encoding</span> <span class="o">=</span> <span class="sh">'</span><span class="s">utf8</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">rf</span><span class="p">:</span>
        <span class="n">customers</span> <span class="o">=</span> <span class="n">rf</span><span class="p">.</span><span class="nf">read</span><span class="p">().</span><span class="nf">split</span><span class="p">(</span><span class="sh">'</span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">match</span> <span class="o">=</span> <span class="p">[(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">customers</span>
                                          <span class="k">if</span> <span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">country</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">match</span>
</pre></table></code></div></div><p>As we can observe, imperative programming in Python specifies the computational steps to get the desired output, where the declarative style of SQL describes the output. Another thing to mention is that Python does support a (functional) declarative style of programming and SQL-like interface with the use of some modules such as <a href="http://pandas.pydata.org/">Pandas</a>. Python does even extend for other features of programming such as <em>object-oriented and functional programming</em>, making it a general-purpose language.</p><p>Now that we know that there can be different <em>styles</em> of programming, and each of these styles varies per our application domain, let’s turn our focus on these styles and some of their noteworthy features.</p><h2 id="what-is-a-programming-paradigm">What is a programming paradigm?</h2><p>Programming paradigms are means to organize programming languages based on their features. A programming language can support multiple paradigms like in <code class="language-plaintext highlighter-rouge">Python</code> – it supports* object-oriented programming, functional programming, and procedural programming* to name a few. While <code class="language-plaintext highlighter-rouge">SQL</code> is designed to be declarative. Let’s break down these paradigms for a bit.</p><p>While the list we discuss here is by no means exhaustive, they are the most common which should be sufficient as we grow familiar with these concepts:</p><ul><li>imperative programming focus on specifying the computational steps to get through a process. Two prominent styles encapsulate the spirit of imperative programming:<ul><li>procedural<li>object-oriented</ul><li>declarative programming focus on describing the desired result of a computational process. Two prominent styles capture the essence of declarative programming:<ul><li>functional<li>logic</ul></ul><p>Let’s begin with <strong>imperative programming</strong>. As we have seen earlier, imperative programming tends to specify how a computational process might achieve a goal. Given our language, take Python, for instance, we can combine strings for tuning our (imperative) logic forming a control system for guiding our program in achieving a particular goal. As we can imagine, there are nearly infinite combinations of strings that essentially capture the essence of your process. Because of the broad <em>design space</em>, we require organization. That is where procedural programming and object-oriented programming comes in.</p><p>Procedural and Object-oriented programming is a means to organize our process. We can think of them as two different worldviews where our code lives. In the lens of procedural programming, we break down the process using their functionalities – often this is called <em>functional programming</em> but it that can only lead us to confusion for a functional programming language is fundamentally different as we will see later. Here’s a snippet of a <em>procedure</em> in Python:</p><div class="language-py highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</pre></table></code></div></div><p>In the code above, we take two integers and add them together. The function then returns the sum of our inputs as a result of the process. In object-oriented programming, we think of everything as objects: a collection of attributes and behaviors. Object-oriented programming neatly supports an organization a chunk of code by its concepts which is essentially how we naturally associate concepts. Consider the code below:</p><div class="language-py highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Humans</span><span class="p">:</span>
      <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span><span class="bp">None</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">self</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>

      <span class="k">def</span> <span class="nf">eat</span><span class="p">(</span><span class="n">food</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span><span class="o">-&gt;</span><span class="bp">None</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">eating </span><span class="sh">"</span> <span class="o">+</span> <span class="n">food</span><span class="p">)</span>
      <span class="k">def</span> <span class="nf">sleep</span><span class="p">()</span><span class="o">-&gt;</span><span class="bp">None</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">sleeping</span><span class="sh">"</span><span class="p">)</span>
      <span class="k">def</span> <span class="nf">talk</span><span class="p">()</span><span class="o">-&gt;</span><span class="bp">None</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">I</span><span class="sh">'</span><span class="s">m talking</span><span class="sh">"</span><span class="p">)</span>
      <span class="k">def</span> <span class="nf">poop</span><span class="p">()</span><span class="o">-&gt;</span><span class="bp">None</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">I</span><span class="sh">'</span><span class="s">m pooping</span><span class="sh">"</span><span class="p">)</span>
</pre></table></code></div></div><p>Whereas imperative programming <em>commands</em> for certain actions, a declarative language we <em>demands</em> for an output. We do not care how a process is implemented, instead, we focus on describing our output and getting it right.</p><p>Let’s introduce a new language called <em>Haskell</em>. Haskell is a purely functional programming language, and we’ll see what we meant by purely functional in a bit. Consider this code:</p><div class="language-hs highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">in_range</span> <span class="o">::</span> <span class="kt">Integer</span><span class="o">-&gt;</span><span class="kt">Integer</span><span class="o">-&gt;</span><span class="kt">Bool</span>
<span class="n">in_range</span> <span class="n">min</span> <span class="n">max</span> <span class="n">x</span> <span class="o">=</span>
    <span class="kr">let</span> <span class="n">in_lower_bound</span> <span class="o">=</span> <span class="n">min</span> <span class="o">&lt;=</span> <span class="n">x</span>
        <span class="n">in_upper_bound</span> <span class="o">=</span> <span class="n">max</span><span class="o">&lt;=</span> <span class="n">y</span>
    <span class="kr">in</span>
        <span class="n">lower_bound</span> <span class="o">&amp;&amp;</span> <span class="n">upper_bound</span>
<span class="c1">-- returns true if x is in range</span>
</pre></table></code></div></div><blockquote><p>Haskell is a purely functional language, which means that functions generally have no side effects. A distinct construct exists to represent side effects, orthogonal to the type of functions. A pure function can return a side effect that is subsequently executed, modeling the impure functions of other languages [1].</p></blockquote><p>In functional programming, you don’t have objects or methods, as we introduced earlier. You only have functions. The idea came from mathematics which makes languages such as Haskell known among mathematicians. The declarative style of functional language allows you to focus on what to solve rather than how to solve it. It stems from the idea that we can break down everything as functions.</p><p>Since functional programming has drawn inspiration from mathematics, functions are expected to have no side effects. What are these side effects? In imperative languages such as Python or C++, there can be objects that are left unresolved. I think of them as <em>ghosts from the future past</em> since they live freely in your program. Creeping, undetected. The trouble with this is that they can introduce unforeseen bugs that could ruin your program.</p><iframe width="100%" height="600px" src="https://www.youtube.com/embed/miW7N2RsYpI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><p>Moving on with logic programming. Let’s introduce another language called <strong>Prolog</strong>. Prolog has drawn inspiration from first-order logic and was designed to be declarative. Let’s not worry about what first-order logic is, for now, all we need to know is that prolog has drawn inspiration from (declarative) logic, unlike imperative languages which came from imperative logic which is procedure-oriented.</p><blockquote><p>let’s focus on the declarative style of logic programming</p></blockquote><div class="language-pl highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="sr">/*facts: characters and their relationships*/</span>
<span class="nv">characters</span><span class="p">(</span><span class="nv">ted</span><span class="p">)</span><span class="o">.</span>
<span class="nv">characters</span><span class="p">(</span><span class="nv">marshall</span><span class="p">)</span><span class="o">.</span>
<span class="nv">characters</span><span class="p">(</span><span class="nv">barney</span><span class="p">)</span><span class="o">.</span>
<span class="nv">characters</span><span class="p">(</span><span class="nv">lily</span><span class="p">)</span><span class="o">.</span>
<span class="nv">characters</span><span class="p">(</span><span class="nv">robin</span><span class="p">)</span><span class="o">.</span>

<span class="nv">likes</span><span class="p">(</span><span class="nv">marshall</span><span class="p">,</span> <span class="nv">lily</span><span class="p">)</span><span class="o">.</span>
<span class="nv">likes</span><span class="p">(</span><span class="nv">ted</span><span class="p">,</span> <span class="nv">robin</span><span class="p">)</span><span class="o">.</span>
<span class="nv">likes</span><span class="p">(</span><span class="nv">barney</span><span class="p">,</span> <span class="nv">robin</span><span class="p">)</span><span class="o">.</span>
</pre></table></code></div></div><blockquote><p>In Prolog, program logic is expressed in terms of relations, and computation is initiated by running a query over these relations. Relations and queries are constructed using Prolog’s single data type, the term [2].</p></blockquote><p>The above code contains the characters of How I Met Your Mother. We can query from that file that contains the characters and verify their relationships. For instance</p><div class="language-pl highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">character</span><span class="p">(</span><span class="nv">chandler</span><span class="p">)</span><span class="o">.</span>
<span class="sr">/*outputs "false."*/</span>
<span class="nv">likes</span><span class="p">(</span><span class="nv">Wholikes</span><span class="p">,</span> <span class="nv">barney</span><span class="p">)</span>
<span class="sr">/*outputs "Wholikes = robin."*/</span>
</pre></table></code></div></div><p>Let’s look at one can represent such a relationship in <a href="https://brilliant.org/wiki/predicate-logic/">predicate logic</a>: \(Likes(x,y) | \ x = \text{barney}, y = \text{robin}\)</p><p>If ever you worry about the new languages I keep throwing in, keep in mind that you should only focus on how it was written and some of the inspirations that led to programming syntax for this will give you a sense of navigating the space of programming languages. We will have deeper dives into these topics in the future.</p><hr /><h2 id="another-way-of-mapping-through-the-space-of-programming-languages">Another way of mapping through the space of programming languages</h2><p>Another way to categorize programming language is through the lens of compiled or interpreted. A compiled language tends to be much faster than an interpreted language. During compilation, the compiler scans the whole program and translates the whole of it into a machine code that a computer can process. An interpreter, on the other hand, translates one statement of the program into a machine code, one at a time. If you worry about performance, you might look into the language specification either they are compiled or interpreted.</p><h2 id="what-makes-a-language-worth-it-to-learn">What makes a language worth it to learn?</h2><p>Take the words from world-class developers for this:</p><iframe width="100%" height="600px" src="https://www.youtube.com/embed/5An1sNznblQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <iframe width="100%" height="600px" src="https://www.youtube.com/embed/LR8fQiskYII" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <iframe width="100%" height="600px" src="https://www.youtube.com/embed/V_6l0fNtfK8?t=116" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <iframe width="100%" height="600px" src="https://www.youtube.com/embed/XlvfHOrF26M" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><p>At the end of the day, what keeps you learning and working on language will be based on your own interests. What sorts of things fascinate you? What application domain should you focus on? and what territories should you explore further? As you move towards the direction of your interest, you find a set of ideas that are familiar to you, possibly because you had fiddled with some concepts on functional programming. This insight will be very helpful as you think about the design of your program. So, having a little knowledge of different programming paradigms will be helpful for your intuition.</p><hr /><h1 id="references">References:</h1><ol><li>Wikipedia contributors. (2021, April 13). Haskell (programming language). In Wikipedia, The Free Encyclopedia. Retrieved 06:56, April 16, 2021, from https://en.wikipedia.org/w/index.php?title=Haskell_(programming_language)&amp;oldid=1017562573<li>Lloyd, J. W. (1984). Foundations of logic programming. Berlin: Springer-Verlag. ISBN 978-3-540-13299-8.</ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/computer-science/'>Computer Science</a>, <a href='/categories/programming/'>Programming</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/programming/" class="post-tag no-text-decoration" >Programming</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Programming for Beginners - Dave Amiana&url=https://adeeconometrics.github.io//posts/Programming-for-Beginners/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Programming for Beginners - Dave Amiana&u=https://adeeconometrics.github.io//posts/Programming-for-Beginners/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Programming for Beginners - Dave Amiana&url=https://adeeconometrics.github.io//posts/Programming-for-Beginners/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/On-Pointer-Types/">On Pointer Types</a><li><a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/">Pointers and References: Design Goals and Use Cases</a><li><a href="/posts/Unique-Reference/">Unique References</a><li><a href="/posts/Shared-Reference/">Shared References</a><li><a href="/posts/Weak-Reference/">Weak References</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Parameter-Passing-in-Cpp/"><div class="card-body"> <span class="timeago small" > Apr 10, 2021 <i class="unloaded">2021-04-10T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Parameter Passing in C++</h3><div class="text-muted small"><p> C++ offers a myriad of configuration that enhances performance. Most of these can be traced with the idea of pointers and references. Pointers and references are tools for memory management that al...</p></div></div></a></div><div class="card"> <a href="/posts/World-Of-Forms-Introduction-to-OOP/"><div class="card-body"> <span class="timeago small" > Apr 21, 2021 <i class="unloaded">2021-04-21T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>World of Forms: An Introduction to Object-Oriented Programming</h3><div class="text-muted small"><p> Object-oriented programming (OOP) has become one of the most used programming paradigms since its conception. Part of the reason why the object-oriented approach is widely practiced is code-reusabi...</p></div></div></a></div><div class="card"> <a href="/posts/The-Java-Language/"><div class="card-body"> <span class="timeago small" > Apr 22, 2021 <i class="unloaded">2021-04-22T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The Java Language: Overview</h3><div class="text-muted small"><p> In this article, we will briefly introduce the Java language for beginners. Let’s begin with an overview of the language. Java is a class-based object-oriented programming language that is designe...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Making-Sense-of-Algorithms/" class="btn btn-outline-primary" prompt="Older"><p>Making Sense of Algorithms: General Perspective</p></a> <a href="/posts/Parameter-Passing-in-Cpp/" class="btn btn-outline-primary" prompt="Newer"><p>Parameter Passing in C++</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/iamdeb25">Dave Amiana</a>.</p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://adeeconometrics.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
