<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="On Pointer Types" /><meta name="author" content="Dave Amiana" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this article, I aim to introduce the concept and motivation behind using pointers. There are breeds of C++ developers that only use smart pointers for safety reasons, others that only use raw pointers for performance benefits, and some that use both whenever they provide the utmost benefits. In this article, I aim to highlight the use-cases of pointers so you can decide when to use one. Conceptually, a pointer is a kind of reference. That is, a pointer refers to a certain block of memory of which acts as an entry point. To access the contents or modify the value of a pointer, we dereference it. Many languages have pointer-like features. Our concern revolves around the context of C and C++. Note that all C functions are valid in C++ but the opposite is not true. For this reason, our section on smart pointers is only applicable to C++. Pointers are the basic structure to achieve reference semantics. Pointers are handy for naming another entity to be attributed by the contents of the referent entity. A pointer may access and manipulate the contents of the entity that it is pointed to, consider: 1 2 3 int x = 5; int *y = &amp;x; *y = 10; Pointers are introduced in C for the following reasons: Inexpensive parameter passing. Allocate memory for new objects on the heap. Passing a function reference to a function. Iterate over data structures. The same thing is true in C++. In fact, iterators (a component for iterating over C++ Containers) resemble the interface of a pointer. But C++ has more to offer with a different set of modalities one can express reference semantics. We will focus on the set of reference modalities known as smart pointers. But before that, let us present a compelling reason for using smart pointers by enumerating the problems of raw pointers. Raw Pointers Raw pointers are low-level types that pertain to a certain block of memory. As mentioned, pointers are entry points to access a value or modify it in a specific location in memory. Some languages have restrictions on pointer types to a varying degree. For example, Ada initializes a default value of their pointer types to null and makes a restriction for type conversions involving pointers mostly for type safety. While languages like Java have banned the use of low-level pointer types to reduce programming error. Therein creeps in the subtle shades of pointers. Now we ask what is the scene of pointer types in C? In languages like C and C++, pointer types are very much used for low-level programming. Type conversion of pointer types has a varying degree of restrictions. In C, void * types are considered as raw pointer types which can be morphed into any type by an operation called typecasting. 1 2 3 4 5 6 void* function(int&amp; i){return &amp;i; } int main(){ int i = 10; std::cout &lt;&lt; *((int*)function(i)); } The above snippet demonstrates that a void * type can be cast into an int *, or any type in that regard. Albeit not apparent with the above example, this is useful for abstraction which is a matter that we will not talk about here. Raw pointers are concrete implementation of the more abstract concept of reference. Unlike Ada, raw pointers in C/C++ are not initialized in a null value, although they can refer to null which is a safer way of using raw pointers: if not initialized with the address of a referent, initialize it with nullptr (in C++) and NULL (in C). The reason behind this is to achieve well-defined behavior and avoid bugs that can be very difficult to fix, let alone find. Raw pointers will not impose anything so misusing or abusing it are very easy to commit. The Dangling Problem: Let us consider an instance that we are likely to encounter the dangling pointer problem. Let’s take a look at allocating and deallocating resources using new and delete function in C++ and malloc (calloc) or free in C. 1 2 3 4 5 6 7 8 9 10 int main(){ // (int*)malloc(sizeof(int)) or (int*)calloc(1, sizeof(int)) in C int* i = new int(100); std::cout &lt;&lt;&quot;contends of i: &quot;&lt;&lt; *i &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\n&#39;; // free(i) in C delete i; std::cout &lt;&lt;&quot;contents of i: &quot; &lt;&lt;*i &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\n&#39;; } Note that delete or free functions only removes the contents of an entity, in this case, i. That is, dereferencing i still returns the memory location of i before it was deleted. This is problematic for it may introduce undefined behavior: dereferencing to an already freed memory is dangerous. To resolve this, we have to make sure that the i references to a well-defined location in memory hence we put i = nullptr (in C++) and i = NULL (in C) after deleting the contents of i to avoid critical mistakes. 1 2 3 4 5 6 7 8 9 int main(){ int* i = new int(100); std::cout &lt;&lt;&quot;contends of i: &quot;&lt;&lt; *i &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\n&#39;; delete i; i = nullptr; std::cout &lt;&lt;&quot;contents of i: &quot; &lt;&lt;*i &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\n&#39;; } Another problem comes with determining the owning pointer which can result in serious issues from resource leaks, undefined behaviors to security vulnerabilities. Which pointer is responsible for which entity? It is difficult to keep track of multiple references and make sure that at the end of the scope such references are correctly managed. There has to be a clear expression to determine the owning pointer. Because of this, C++ introduced a reference management system that revolves around the idea of RAII. Smart Pointers From the C++ Standard : Enforcing the lifetime safety profile eliminates leaks. When combined with resource safety provided by RAII, it eliminates the need for “garbage collection” (by generating no garbage). Combine this with enforcement of the type and bounds profiles and you get complete type- and resource-safety, guaranteed by tools. C++ introduced a set of classes for automatic resource management with very minimal to zero-cost performance penalties. Using these set of pointers has the following set of benefits: clarity of expressing ownership guarantees that resources will not leak When appropriate, we should be using smart pointers for clearly expressing our intent with the kind of ownership we want to establish between the pointer and the entity it refers to. We have three smart pointers: std::unique_ptr&lt;T&gt;, std::shared_ptr&lt;T&gt;, and std::weak_ptr&lt;T&gt;. We can access these modalities in the &lt;memory&gt; header file. Let us walk through and discover what these reference modalities have to offer. For our demonstration let us consider a class named Entity defined as: 1 2 3 4 5 6 7 8 class Entity{ const char* str = &quot;message from Entity. \n&quot;; public: Entity(){ std::cout &lt;&lt; &quot;Resources of Entity are acquired. \n&quot;; } ~Entity(){ std::cout &lt;&lt; &quot;Resources of Entity is cleaned up. \n&quot;; } const char* function(void){ return str; } }; Unique Pointer Unique pointer maintains that there is only one pointer responsible for a given resource in memory. The owning pointer is responsible for the clean-up and resource management. Let us define an instance of Entity. 1 std::unique_ptr&lt;E&gt; e (new Entity()); Now, let us consider passing the pointer by reference and with move constructors to see its effect on where Entity is destroyed. Passing the unique pointer by reference means that the unique pointer is extended to a function, hence the clean-up happens after the unique pointer goes out of scope from the main function where it has been declared. 1 2 3 4 5 6 7 8 9 void f(std::unique_ptr&lt;Entity&gt;&amp; entity){ std::cout &lt;&lt; entity-&gt;function(); } int main(){ std::unique_ptr&lt;Entity&gt; e(new Entity()); f(e); std::cout &lt;&lt; &quot;... \n&quot;; } 1 2 3 4 Resources of Entity are acquired. message from Entity. ... Resources of Entity is cleaned up. Passing the unique pointer with move constructors is transferring ownership to the unique pointer defined in function f(). We can notice the behavior has we run the following snippet: 1 2 3 4 5 6 7 8 9 void f(std::unique_ptr&lt;Entity&gt; entity){ std::cout &lt;&lt; entity-&gt;function(); } int main(){ std::unique_ptr&lt;Entity&gt; e(new Entity()); f(std::move(e)); std::cout &lt;&lt; &quot;... \n&quot;; } 1 2 3 4 Resources of Entity are acquired. message from Entity. Resources of Entity is cleaned up. ... Since we transferred the ownership of e to entity, the clean-up happened as soon as the entity exits the function. Shared Pointer The shared pointer has an additional mechanism called reference counting where it keeps track of pointers that request for sharing resources. Each time another pointer asks for shared resources, the reference counter adds one and for every time it goes out of scope it removes one. At the time where the reference count is 0, it calls for the clean-up. We can observe this mechanism with the following code snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 void f(std::shared_ptr&lt;Entity&gt; entity){ std::cout&lt;&lt;&quot;ref count: &quot; &lt;&lt; entity.use_count() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; entity-&gt;function(); } int main(){ std::shared_ptr&lt;Entity&gt; e(new Entity()); std::cout&lt;&lt;&quot;ref count: &quot; &lt;&lt; e.use_count() &lt;&lt; &#39;\n&#39;; f(e); std::cout &lt;&lt; &quot;f went out of scope. \n&quot;; std::cout &lt;&lt;&quot;ref count: &quot; &lt;&lt;e.use_count() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;... \n&quot;; } 1 2 3 4 5 6 7 8 Resources of Entity are acquired. ref count: 1 ref count: 2 message from Entity. f went out of scope. ref count: 1 ... Resources of Entity is cleaned up. When I first encountered this, I thought that is all I need, unique pointers and shared pointers are all there is to it. Until I encountered this problem called circular references where the troubles of shared references kick in. It is possible to break the guarantees of the shared pointer by forming a loop of circular references which results in resource leaks. The Circular Reference Problem A circular reference has the form $A \to B$, $B \to A$. Let us put this into code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct B; struct A{ std::shared_ptr&lt;B&gt; ab; A(){ std::cout &lt;&lt; &quot;Resources of A are acquired. \n&quot;; } ~A(){ std::cout &lt;&lt; &quot;Resources of A are cleaned up. \n&quot;; } }; struct B{ std::shared_ptr&lt;A&gt; ba; B(){ std::cout &lt;&lt; &quot;Resources of B are acquired. \n&quot;; } ~B(){ std::cout &lt;&lt; &quot;Resources of B are cleaned up. \n&quot;; } }; int main(){ std::shared_ptr&lt;A&gt; sa (new A()); std::shared_ptr&lt;B&gt; sb (new B()); sa-&gt;ab=sb; sb-&gt;ba=sa; } 1 2 Resources of A are acquired. Resources of B are acquired. Since $A \to B$ and $B \to A$, the reference count will never resolve to zero – the condition which std::shared_ptr&lt;T&gt; does its clean-up. We can observe the reference counts by theuse_count() function. Let is modify the main function: 1 2 3 4 5 6 7 8 9 int main(){ std::shared_ptr&lt;A&gt; sa (new A()); std::shared_ptr&lt;B&gt; sb (new B()); sa-&gt;ab=sb; std::cout &lt;&lt; &quot;count of ab: &quot; &lt;&lt; sa-&gt;ab.use_count() &lt;&lt; &#39;\n&#39;; sb-&gt;ba=sa; std::cout &lt;&lt; &quot;count of ba: &quot; &lt;&lt; sb-&gt;ba.use_count() &lt;&lt; &#39;\n&#39;; } 1 2 3 4 Resources of A are acquired. Resources of B are acquired. count of ab: 2 count of ba: 2 How do we break the curse? Introducing Weak Pointers. Weak Pointer A weak pointer is a special type of pointer in conjunction with shared pointers. With weak pointers, you can access the contents of the shared pointer without increasing the reference count. This is useful for observing the contents of a shared resource and most notably resolving the problem of circular reference. Let us solve the problem of circular reference through weak pointers. This can be achieved by modifying either A::ab or B::ba pointers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct A{ std::shared_ptr&lt;B&gt; ab; A(){ std::cout &lt;&lt; &quot;Resources of A are acquired. \n&quot;; } ~A(){ std::cout &lt;&lt; &quot;Resources of A are cleaned up. \n&quot;; } }; struct B{ std::weak_ptr&lt;A&gt; ba; B(){ std::cout &lt;&lt; &quot;Resources of B are acquired. \n&quot;; } ~B(){ std::cout &lt;&lt; &quot;Resources of B are cleaned up. \n&quot;; } }; int main(){ std::shared_ptr&lt;A&gt; sa (new A()); std::shared_ptr&lt;B&gt; sb (new B()); sa-&gt;ab=sb; std::cout &lt;&lt; &quot;count of ab: &quot; &lt;&lt; sa-&gt;ab.use_count() &lt;&lt; &#39;\n&#39;; sb-&gt;ba=sa; std::cout &lt;&lt; &quot;count of ba: &quot; &lt;&lt; sb-&gt;ba.use_count() &lt;&lt; &#39;\n&#39;; } 1 2 3 4 5 6 Resources of A are acquired. Resources of B are acquired. count of ab: 2 count of ba: 1 Resources of A are cleaned up. Resources of B are cleaned up. Summary C++ does not use automatic reference management by default following their design philosophy of the zero-overhead principle. One can enable automatic reference management in C++ by making use of smart pointers defined in the standard library. It gives you resource guarantees and safety. Other languages such as Swift and Rust have adhered to the same concept instead of making sophisticated garbage collectors, they do not produce any garbage at all. This memory management model makes a very compelling case of using smart pointers. But raw pointers still have their brightest moments up to date. Prefer using pointers for performance-critical loops or when the scope is clear enough to determine which is the owning pointer for a given resource. Raw pointers give you few performance benefits, but it comes with the cost of manually keeping track of your pointers, resource safety becomes your responsibility. Prefer using smart pointers for expressing ownership clearly. Smart pointers give you resource guarantees which get rid of your task to make sure that there will be no leaks. The standard recommends the following: Look at pointers: Classify them into non-owners (the default) and owners. Where feasible, replace owners with standard-library resource handles (as in the example above). Alternatively, mark an owner as such using owner from the GSL. Look for naked new and delete Look for known resource allocating functions returning raw pointers (such as fopen, malloc, and strdup) References Barnes, J. (2005). Safe Pointers. AdaCore. Retrieved from: https://www.adacore.com/uploads_gems/03_safe_secure_ada_2005_safe_pointers.pdf. Computerphile (2017). Why C is so Influential? Retrieved from: https://www.youtube.com/watch?v=ci1PJexnfNE. Microsoft Docs (2020). Raw Pointers (C++). Microsoft Docs (2020). Smart Pointers (Modern C++). Microsoft Docs (2019). Object lifetime and resource management (RAII). Stroustrup, B. &amp; Sutter, H. (2021). C++ Core Guidelines. Retrieved from: http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#??? Stroustrup, B. (2013). The C++ programming language. Pearson Education." /><meta property="og:description" content="In this article, I aim to introduce the concept and motivation behind using pointers. There are breeds of C++ developers that only use smart pointers for safety reasons, others that only use raw pointers for performance benefits, and some that use both whenever they provide the utmost benefits. In this article, I aim to highlight the use-cases of pointers so you can decide when to use one. Conceptually, a pointer is a kind of reference. That is, a pointer refers to a certain block of memory of which acts as an entry point. To access the contents or modify the value of a pointer, we dereference it. Many languages have pointer-like features. Our concern revolves around the context of C and C++. Note that all C functions are valid in C++ but the opposite is not true. For this reason, our section on smart pointers is only applicable to C++. Pointers are the basic structure to achieve reference semantics. Pointers are handy for naming another entity to be attributed by the contents of the referent entity. A pointer may access and manipulate the contents of the entity that it is pointed to, consider: 1 2 3 int x = 5; int *y = &amp;x; *y = 10; Pointers are introduced in C for the following reasons: Inexpensive parameter passing. Allocate memory for new objects on the heap. Passing a function reference to a function. Iterate over data structures. The same thing is true in C++. In fact, iterators (a component for iterating over C++ Containers) resemble the interface of a pointer. But C++ has more to offer with a different set of modalities one can express reference semantics. We will focus on the set of reference modalities known as smart pointers. But before that, let us present a compelling reason for using smart pointers by enumerating the problems of raw pointers. Raw Pointers Raw pointers are low-level types that pertain to a certain block of memory. As mentioned, pointers are entry points to access a value or modify it in a specific location in memory. Some languages have restrictions on pointer types to a varying degree. For example, Ada initializes a default value of their pointer types to null and makes a restriction for type conversions involving pointers mostly for type safety. While languages like Java have banned the use of low-level pointer types to reduce programming error. Therein creeps in the subtle shades of pointers. Now we ask what is the scene of pointer types in C? In languages like C and C++, pointer types are very much used for low-level programming. Type conversion of pointer types has a varying degree of restrictions. In C, void * types are considered as raw pointer types which can be morphed into any type by an operation called typecasting. 1 2 3 4 5 6 void* function(int&amp; i){return &amp;i; } int main(){ int i = 10; std::cout &lt;&lt; *((int*)function(i)); } The above snippet demonstrates that a void * type can be cast into an int *, or any type in that regard. Albeit not apparent with the above example, this is useful for abstraction which is a matter that we will not talk about here. Raw pointers are concrete implementation of the more abstract concept of reference. Unlike Ada, raw pointers in C/C++ are not initialized in a null value, although they can refer to null which is a safer way of using raw pointers: if not initialized with the address of a referent, initialize it with nullptr (in C++) and NULL (in C). The reason behind this is to achieve well-defined behavior and avoid bugs that can be very difficult to fix, let alone find. Raw pointers will not impose anything so misusing or abusing it are very easy to commit. The Dangling Problem: Let us consider an instance that we are likely to encounter the dangling pointer problem. Let’s take a look at allocating and deallocating resources using new and delete function in C++ and malloc (calloc) or free in C. 1 2 3 4 5 6 7 8 9 10 int main(){ // (int*)malloc(sizeof(int)) or (int*)calloc(1, sizeof(int)) in C int* i = new int(100); std::cout &lt;&lt;&quot;contends of i: &quot;&lt;&lt; *i &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\n&#39;; // free(i) in C delete i; std::cout &lt;&lt;&quot;contents of i: &quot; &lt;&lt;*i &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\n&#39;; } Note that delete or free functions only removes the contents of an entity, in this case, i. That is, dereferencing i still returns the memory location of i before it was deleted. This is problematic for it may introduce undefined behavior: dereferencing to an already freed memory is dangerous. To resolve this, we have to make sure that the i references to a well-defined location in memory hence we put i = nullptr (in C++) and i = NULL (in C) after deleting the contents of i to avoid critical mistakes. 1 2 3 4 5 6 7 8 9 int main(){ int* i = new int(100); std::cout &lt;&lt;&quot;contends of i: &quot;&lt;&lt; *i &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\n&#39;; delete i; i = nullptr; std::cout &lt;&lt;&quot;contents of i: &quot; &lt;&lt;*i &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\n&#39;; } Another problem comes with determining the owning pointer which can result in serious issues from resource leaks, undefined behaviors to security vulnerabilities. Which pointer is responsible for which entity? It is difficult to keep track of multiple references and make sure that at the end of the scope such references are correctly managed. There has to be a clear expression to determine the owning pointer. Because of this, C++ introduced a reference management system that revolves around the idea of RAII. Smart Pointers From the C++ Standard : Enforcing the lifetime safety profile eliminates leaks. When combined with resource safety provided by RAII, it eliminates the need for “garbage collection” (by generating no garbage). Combine this with enforcement of the type and bounds profiles and you get complete type- and resource-safety, guaranteed by tools. C++ introduced a set of classes for automatic resource management with very minimal to zero-cost performance penalties. Using these set of pointers has the following set of benefits: clarity of expressing ownership guarantees that resources will not leak When appropriate, we should be using smart pointers for clearly expressing our intent with the kind of ownership we want to establish between the pointer and the entity it refers to. We have three smart pointers: std::unique_ptr&lt;T&gt;, std::shared_ptr&lt;T&gt;, and std::weak_ptr&lt;T&gt;. We can access these modalities in the &lt;memory&gt; header file. Let us walk through and discover what these reference modalities have to offer. For our demonstration let us consider a class named Entity defined as: 1 2 3 4 5 6 7 8 class Entity{ const char* str = &quot;message from Entity. \n&quot;; public: Entity(){ std::cout &lt;&lt; &quot;Resources of Entity are acquired. \n&quot;; } ~Entity(){ std::cout &lt;&lt; &quot;Resources of Entity is cleaned up. \n&quot;; } const char* function(void){ return str; } }; Unique Pointer Unique pointer maintains that there is only one pointer responsible for a given resource in memory. The owning pointer is responsible for the clean-up and resource management. Let us define an instance of Entity. 1 std::unique_ptr&lt;E&gt; e (new Entity()); Now, let us consider passing the pointer by reference and with move constructors to see its effect on where Entity is destroyed. Passing the unique pointer by reference means that the unique pointer is extended to a function, hence the clean-up happens after the unique pointer goes out of scope from the main function where it has been declared. 1 2 3 4 5 6 7 8 9 void f(std::unique_ptr&lt;Entity&gt;&amp; entity){ std::cout &lt;&lt; entity-&gt;function(); } int main(){ std::unique_ptr&lt;Entity&gt; e(new Entity()); f(e); std::cout &lt;&lt; &quot;... \n&quot;; } 1 2 3 4 Resources of Entity are acquired. message from Entity. ... Resources of Entity is cleaned up. Passing the unique pointer with move constructors is transferring ownership to the unique pointer defined in function f(). We can notice the behavior has we run the following snippet: 1 2 3 4 5 6 7 8 9 void f(std::unique_ptr&lt;Entity&gt; entity){ std::cout &lt;&lt; entity-&gt;function(); } int main(){ std::unique_ptr&lt;Entity&gt; e(new Entity()); f(std::move(e)); std::cout &lt;&lt; &quot;... \n&quot;; } 1 2 3 4 Resources of Entity are acquired. message from Entity. Resources of Entity is cleaned up. ... Since we transferred the ownership of e to entity, the clean-up happened as soon as the entity exits the function. Shared Pointer The shared pointer has an additional mechanism called reference counting where it keeps track of pointers that request for sharing resources. Each time another pointer asks for shared resources, the reference counter adds one and for every time it goes out of scope it removes one. At the time where the reference count is 0, it calls for the clean-up. We can observe this mechanism with the following code snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 void f(std::shared_ptr&lt;Entity&gt; entity){ std::cout&lt;&lt;&quot;ref count: &quot; &lt;&lt; entity.use_count() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; entity-&gt;function(); } int main(){ std::shared_ptr&lt;Entity&gt; e(new Entity()); std::cout&lt;&lt;&quot;ref count: &quot; &lt;&lt; e.use_count() &lt;&lt; &#39;\n&#39;; f(e); std::cout &lt;&lt; &quot;f went out of scope. \n&quot;; std::cout &lt;&lt;&quot;ref count: &quot; &lt;&lt;e.use_count() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;... \n&quot;; } 1 2 3 4 5 6 7 8 Resources of Entity are acquired. ref count: 1 ref count: 2 message from Entity. f went out of scope. ref count: 1 ... Resources of Entity is cleaned up. When I first encountered this, I thought that is all I need, unique pointers and shared pointers are all there is to it. Until I encountered this problem called circular references where the troubles of shared references kick in. It is possible to break the guarantees of the shared pointer by forming a loop of circular references which results in resource leaks. The Circular Reference Problem A circular reference has the form $A \to B$, $B \to A$. Let us put this into code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct B; struct A{ std::shared_ptr&lt;B&gt; ab; A(){ std::cout &lt;&lt; &quot;Resources of A are acquired. \n&quot;; } ~A(){ std::cout &lt;&lt; &quot;Resources of A are cleaned up. \n&quot;; } }; struct B{ std::shared_ptr&lt;A&gt; ba; B(){ std::cout &lt;&lt; &quot;Resources of B are acquired. \n&quot;; } ~B(){ std::cout &lt;&lt; &quot;Resources of B are cleaned up. \n&quot;; } }; int main(){ std::shared_ptr&lt;A&gt; sa (new A()); std::shared_ptr&lt;B&gt; sb (new B()); sa-&gt;ab=sb; sb-&gt;ba=sa; } 1 2 Resources of A are acquired. Resources of B are acquired. Since $A \to B$ and $B \to A$, the reference count will never resolve to zero – the condition which std::shared_ptr&lt;T&gt; does its clean-up. We can observe the reference counts by theuse_count() function. Let is modify the main function: 1 2 3 4 5 6 7 8 9 int main(){ std::shared_ptr&lt;A&gt; sa (new A()); std::shared_ptr&lt;B&gt; sb (new B()); sa-&gt;ab=sb; std::cout &lt;&lt; &quot;count of ab: &quot; &lt;&lt; sa-&gt;ab.use_count() &lt;&lt; &#39;\n&#39;; sb-&gt;ba=sa; std::cout &lt;&lt; &quot;count of ba: &quot; &lt;&lt; sb-&gt;ba.use_count() &lt;&lt; &#39;\n&#39;; } 1 2 3 4 Resources of A are acquired. Resources of B are acquired. count of ab: 2 count of ba: 2 How do we break the curse? Introducing Weak Pointers. Weak Pointer A weak pointer is a special type of pointer in conjunction with shared pointers. With weak pointers, you can access the contents of the shared pointer without increasing the reference count. This is useful for observing the contents of a shared resource and most notably resolving the problem of circular reference. Let us solve the problem of circular reference through weak pointers. This can be achieved by modifying either A::ab or B::ba pointers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct A{ std::shared_ptr&lt;B&gt; ab; A(){ std::cout &lt;&lt; &quot;Resources of A are acquired. \n&quot;; } ~A(){ std::cout &lt;&lt; &quot;Resources of A are cleaned up. \n&quot;; } }; struct B{ std::weak_ptr&lt;A&gt; ba; B(){ std::cout &lt;&lt; &quot;Resources of B are acquired. \n&quot;; } ~B(){ std::cout &lt;&lt; &quot;Resources of B are cleaned up. \n&quot;; } }; int main(){ std::shared_ptr&lt;A&gt; sa (new A()); std::shared_ptr&lt;B&gt; sb (new B()); sa-&gt;ab=sb; std::cout &lt;&lt; &quot;count of ab: &quot; &lt;&lt; sa-&gt;ab.use_count() &lt;&lt; &#39;\n&#39;; sb-&gt;ba=sa; std::cout &lt;&lt; &quot;count of ba: &quot; &lt;&lt; sb-&gt;ba.use_count() &lt;&lt; &#39;\n&#39;; } 1 2 3 4 5 6 Resources of A are acquired. Resources of B are acquired. count of ab: 2 count of ba: 1 Resources of A are cleaned up. Resources of B are cleaned up. Summary C++ does not use automatic reference management by default following their design philosophy of the zero-overhead principle. One can enable automatic reference management in C++ by making use of smart pointers defined in the standard library. It gives you resource guarantees and safety. Other languages such as Swift and Rust have adhered to the same concept instead of making sophisticated garbage collectors, they do not produce any garbage at all. This memory management model makes a very compelling case of using smart pointers. But raw pointers still have their brightest moments up to date. Prefer using pointers for performance-critical loops or when the scope is clear enough to determine which is the owning pointer for a given resource. Raw pointers give you few performance benefits, but it comes with the cost of manually keeping track of your pointers, resource safety becomes your responsibility. Prefer using smart pointers for expressing ownership clearly. Smart pointers give you resource guarantees which get rid of your task to make sure that there will be no leaks. The standard recommends the following: Look at pointers: Classify them into non-owners (the default) and owners. Where feasible, replace owners with standard-library resource handles (as in the example above). Alternatively, mark an owner as such using owner from the GSL. Look for naked new and delete Look for known resource allocating functions returning raw pointers (such as fopen, malloc, and strdup) References Barnes, J. (2005). Safe Pointers. AdaCore. Retrieved from: https://www.adacore.com/uploads_gems/03_safe_secure_ada_2005_safe_pointers.pdf. Computerphile (2017). Why C is so Influential? Retrieved from: https://www.youtube.com/watch?v=ci1PJexnfNE. Microsoft Docs (2020). Raw Pointers (C++). Microsoft Docs (2020). Smart Pointers (Modern C++). Microsoft Docs (2019). Object lifetime and resource management (RAII). Stroustrup, B. &amp; Sutter, H. (2021). C++ Core Guidelines. Retrieved from: http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#??? Stroustrup, B. (2013). The C++ programming language. Pearson Education." /><link rel="canonical" href="https://adeeconometrics.github.io//posts/On-Pointer-Types/" /><meta property="og:url" content="https://adeeconometrics.github.io//posts/On-Pointer-Types/" /><meta property="og:site_name" content="Dave Amiana" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-12T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="On Pointer Types" /><meta name="twitter:site" content="@iamdeb25" /><meta name="twitter:creator" content="@Dave Amiana" /><meta name="google-site-verification" content="google-site-verification=28bVbRErS2VwJaonXuu3GbqmRlyNvizt6I00B2kQh88" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Dave Amiana"},"dateModified":"2022-10-22T22:11:50+08:00","datePublished":"2021-08-12T00:00:00+08:00","description":"In this article, I aim to introduce the concept and motivation behind using pointers. There are breeds of C++ developers that only use smart pointers for safety reasons, others that only use raw pointers for performance benefits, and some that use both whenever they provide the utmost benefits. In this article, I aim to highlight the use-cases of pointers so you can decide when to use one. Conceptually, a pointer is a kind of reference. That is, a pointer refers to a certain block of memory of which acts as an entry point. To access the contents or modify the value of a pointer, we dereference it. Many languages have pointer-like features. Our concern revolves around the context of C and C++. Note that all C functions are valid in C++ but the opposite is not true. For this reason, our section on smart pointers is only applicable to C++. Pointers are the basic structure to achieve reference semantics. Pointers are handy for naming another entity to be attributed by the contents of the referent entity. A pointer may access and manipulate the contents of the entity that it is pointed to, consider: 1 2 3 int x = 5; int *y = &amp;x; *y = 10; Pointers are introduced in C for the following reasons: Inexpensive parameter passing. Allocate memory for new objects on the heap. Passing a function reference to a function. Iterate over data structures. The same thing is true in C++. In fact, iterators (a component for iterating over C++ Containers) resemble the interface of a pointer. But C++ has more to offer with a different set of modalities one can express reference semantics. We will focus on the set of reference modalities known as smart pointers. But before that, let us present a compelling reason for using smart pointers by enumerating the problems of raw pointers. Raw Pointers Raw pointers are low-level types that pertain to a certain block of memory. As mentioned, pointers are entry points to access a value or modify it in a specific location in memory. Some languages have restrictions on pointer types to a varying degree. For example, Ada initializes a default value of their pointer types to null and makes a restriction for type conversions involving pointers mostly for type safety. While languages like Java have banned the use of low-level pointer types to reduce programming error. Therein creeps in the subtle shades of pointers. Now we ask what is the scene of pointer types in C? In languages like C and C++, pointer types are very much used for low-level programming. Type conversion of pointer types has a varying degree of restrictions. In C, void * types are considered as raw pointer types which can be morphed into any type by an operation called typecasting. 1 2 3 4 5 6 void* function(int&amp; i){return &amp;i; } int main(){ int i = 10; std::cout &lt;&lt; *((int*)function(i)); } The above snippet demonstrates that a void * type can be cast into an int *, or any type in that regard. Albeit not apparent with the above example, this is useful for abstraction which is a matter that we will not talk about here. Raw pointers are concrete implementation of the more abstract concept of reference. Unlike Ada, raw pointers in C/C++ are not initialized in a null value, although they can refer to null which is a safer way of using raw pointers: if not initialized with the address of a referent, initialize it with nullptr (in C++) and NULL (in C). The reason behind this is to achieve well-defined behavior and avoid bugs that can be very difficult to fix, let alone find. Raw pointers will not impose anything so misusing or abusing it are very easy to commit. The Dangling Problem: Let us consider an instance that we are likely to encounter the dangling pointer problem. Let’s take a look at allocating and deallocating resources using new and delete function in C++ and malloc (calloc) or free in C. 1 2 3 4 5 6 7 8 9 10 int main(){ // (int*)malloc(sizeof(int)) or (int*)calloc(1, sizeof(int)) in C int* i = new int(100); std::cout &lt;&lt;&quot;contends of i: &quot;&lt;&lt; *i &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\\n&#39;; // free(i) in C delete i; std::cout &lt;&lt;&quot;contents of i: &quot; &lt;&lt;*i &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\\n&#39;; } Note that delete or free functions only removes the contents of an entity, in this case, i. That is, dereferencing i still returns the memory location of i before it was deleted. This is problematic for it may introduce undefined behavior: dereferencing to an already freed memory is dangerous. To resolve this, we have to make sure that the i references to a well-defined location in memory hence we put i = nullptr (in C++) and i = NULL (in C) after deleting the contents of i to avoid critical mistakes. 1 2 3 4 5 6 7 8 9 int main(){ int* i = new int(100); std::cout &lt;&lt;&quot;contends of i: &quot;&lt;&lt; *i &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\\n&#39;; delete i; i = nullptr; std::cout &lt;&lt;&quot;contents of i: &quot; &lt;&lt;*i &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt;&quot;address of i: &quot; &lt;&lt; &amp;i &lt;&lt; &#39;\\n&#39;; } Another problem comes with determining the owning pointer which can result in serious issues from resource leaks, undefined behaviors to security vulnerabilities. Which pointer is responsible for which entity? It is difficult to keep track of multiple references and make sure that at the end of the scope such references are correctly managed. There has to be a clear expression to determine the owning pointer. Because of this, C++ introduced a reference management system that revolves around the idea of RAII. Smart Pointers From the C++ Standard : Enforcing the lifetime safety profile eliminates leaks. When combined with resource safety provided by RAII, it eliminates the need for “garbage collection” (by generating no garbage). Combine this with enforcement of the type and bounds profiles and you get complete type- and resource-safety, guaranteed by tools. C++ introduced a set of classes for automatic resource management with very minimal to zero-cost performance penalties. Using these set of pointers has the following set of benefits: clarity of expressing ownership guarantees that resources will not leak When appropriate, we should be using smart pointers for clearly expressing our intent with the kind of ownership we want to establish between the pointer and the entity it refers to. We have three smart pointers: std::unique_ptr&lt;T&gt;, std::shared_ptr&lt;T&gt;, and std::weak_ptr&lt;T&gt;. We can access these modalities in the &lt;memory&gt; header file. Let us walk through and discover what these reference modalities have to offer. For our demonstration let us consider a class named Entity defined as: 1 2 3 4 5 6 7 8 class Entity{ const char* str = &quot;message from Entity. \\n&quot;; public: Entity(){ std::cout &lt;&lt; &quot;Resources of Entity are acquired. \\n&quot;; } ~Entity(){ std::cout &lt;&lt; &quot;Resources of Entity is cleaned up. \\n&quot;; } const char* function(void){ return str; } }; Unique Pointer Unique pointer maintains that there is only one pointer responsible for a given resource in memory. The owning pointer is responsible for the clean-up and resource management. Let us define an instance of Entity. 1 std::unique_ptr&lt;E&gt; e (new Entity()); Now, let us consider passing the pointer by reference and with move constructors to see its effect on where Entity is destroyed. Passing the unique pointer by reference means that the unique pointer is extended to a function, hence the clean-up happens after the unique pointer goes out of scope from the main function where it has been declared. 1 2 3 4 5 6 7 8 9 void f(std::unique_ptr&lt;Entity&gt;&amp; entity){ std::cout &lt;&lt; entity-&gt;function(); } int main(){ std::unique_ptr&lt;Entity&gt; e(new Entity()); f(e); std::cout &lt;&lt; &quot;... \\n&quot;; } 1 2 3 4 Resources of Entity are acquired. message from Entity. ... Resources of Entity is cleaned up. Passing the unique pointer with move constructors is transferring ownership to the unique pointer defined in function f(). We can notice the behavior has we run the following snippet: 1 2 3 4 5 6 7 8 9 void f(std::unique_ptr&lt;Entity&gt; entity){ std::cout &lt;&lt; entity-&gt;function(); } int main(){ std::unique_ptr&lt;Entity&gt; e(new Entity()); f(std::move(e)); std::cout &lt;&lt; &quot;... \\n&quot;; } 1 2 3 4 Resources of Entity are acquired. message from Entity. Resources of Entity is cleaned up. ... Since we transferred the ownership of e to entity, the clean-up happened as soon as the entity exits the function. Shared Pointer The shared pointer has an additional mechanism called reference counting where it keeps track of pointers that request for sharing resources. Each time another pointer asks for shared resources, the reference counter adds one and for every time it goes out of scope it removes one. At the time where the reference count is 0, it calls for the clean-up. We can observe this mechanism with the following code snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 void f(std::shared_ptr&lt;Entity&gt; entity){ std::cout&lt;&lt;&quot;ref count: &quot; &lt;&lt; entity.use_count() &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; entity-&gt;function(); } int main(){ std::shared_ptr&lt;Entity&gt; e(new Entity()); std::cout&lt;&lt;&quot;ref count: &quot; &lt;&lt; e.use_count() &lt;&lt; &#39;\\n&#39;; f(e); std::cout &lt;&lt; &quot;f went out of scope. \\n&quot;; std::cout &lt;&lt;&quot;ref count: &quot; &lt;&lt;e.use_count() &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;... \\n&quot;; } 1 2 3 4 5 6 7 8 Resources of Entity are acquired. ref count: 1 ref count: 2 message from Entity. f went out of scope. ref count: 1 ... Resources of Entity is cleaned up. When I first encountered this, I thought that is all I need, unique pointers and shared pointers are all there is to it. Until I encountered this problem called circular references where the troubles of shared references kick in. It is possible to break the guarantees of the shared pointer by forming a loop of circular references which results in resource leaks. The Circular Reference Problem A circular reference has the form $A \\to B$, $B \\to A$. Let us put this into code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct B; struct A{ std::shared_ptr&lt;B&gt; ab; A(){ std::cout &lt;&lt; &quot;Resources of A are acquired. \\n&quot;; } ~A(){ std::cout &lt;&lt; &quot;Resources of A are cleaned up. \\n&quot;; } }; struct B{ std::shared_ptr&lt;A&gt; ba; B(){ std::cout &lt;&lt; &quot;Resources of B are acquired. \\n&quot;; } ~B(){ std::cout &lt;&lt; &quot;Resources of B are cleaned up. \\n&quot;; } }; int main(){ std::shared_ptr&lt;A&gt; sa (new A()); std::shared_ptr&lt;B&gt; sb (new B()); sa-&gt;ab=sb; sb-&gt;ba=sa; } 1 2 Resources of A are acquired. Resources of B are acquired. Since $A \\to B$ and $B \\to A$, the reference count will never resolve to zero – the condition which std::shared_ptr&lt;T&gt; does its clean-up. We can observe the reference counts by theuse_count() function. Let is modify the main function: 1 2 3 4 5 6 7 8 9 int main(){ std::shared_ptr&lt;A&gt; sa (new A()); std::shared_ptr&lt;B&gt; sb (new B()); sa-&gt;ab=sb; std::cout &lt;&lt; &quot;count of ab: &quot; &lt;&lt; sa-&gt;ab.use_count() &lt;&lt; &#39;\\n&#39;; sb-&gt;ba=sa; std::cout &lt;&lt; &quot;count of ba: &quot; &lt;&lt; sb-&gt;ba.use_count() &lt;&lt; &#39;\\n&#39;; } 1 2 3 4 Resources of A are acquired. Resources of B are acquired. count of ab: 2 count of ba: 2 How do we break the curse? Introducing Weak Pointers. Weak Pointer A weak pointer is a special type of pointer in conjunction with shared pointers. With weak pointers, you can access the contents of the shared pointer without increasing the reference count. This is useful for observing the contents of a shared resource and most notably resolving the problem of circular reference. Let us solve the problem of circular reference through weak pointers. This can be achieved by modifying either A::ab or B::ba pointers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct A{ std::shared_ptr&lt;B&gt; ab; A(){ std::cout &lt;&lt; &quot;Resources of A are acquired. \\n&quot;; } ~A(){ std::cout &lt;&lt; &quot;Resources of A are cleaned up. \\n&quot;; } }; struct B{ std::weak_ptr&lt;A&gt; ba; B(){ std::cout &lt;&lt; &quot;Resources of B are acquired. \\n&quot;; } ~B(){ std::cout &lt;&lt; &quot;Resources of B are cleaned up. \\n&quot;; } }; int main(){ std::shared_ptr&lt;A&gt; sa (new A()); std::shared_ptr&lt;B&gt; sb (new B()); sa-&gt;ab=sb; std::cout &lt;&lt; &quot;count of ab: &quot; &lt;&lt; sa-&gt;ab.use_count() &lt;&lt; &#39;\\n&#39;; sb-&gt;ba=sa; std::cout &lt;&lt; &quot;count of ba: &quot; &lt;&lt; sb-&gt;ba.use_count() &lt;&lt; &#39;\\n&#39;; } 1 2 3 4 5 6 Resources of A are acquired. Resources of B are acquired. count of ab: 2 count of ba: 1 Resources of A are cleaned up. Resources of B are cleaned up. Summary C++ does not use automatic reference management by default following their design philosophy of the zero-overhead principle. One can enable automatic reference management in C++ by making use of smart pointers defined in the standard library. It gives you resource guarantees and safety. Other languages such as Swift and Rust have adhered to the same concept instead of making sophisticated garbage collectors, they do not produce any garbage at all. This memory management model makes a very compelling case of using smart pointers. But raw pointers still have their brightest moments up to date. Prefer using pointers for performance-critical loops or when the scope is clear enough to determine which is the owning pointer for a given resource. Raw pointers give you few performance benefits, but it comes with the cost of manually keeping track of your pointers, resource safety becomes your responsibility. Prefer using smart pointers for expressing ownership clearly. Smart pointers give you resource guarantees which get rid of your task to make sure that there will be no leaks. The standard recommends the following: Look at pointers: Classify them into non-owners (the default) and owners. Where feasible, replace owners with standard-library resource handles (as in the example above). Alternatively, mark an owner as such using owner from the GSL. Look for naked new and delete Look for known resource allocating functions returning raw pointers (such as fopen, malloc, and strdup) References Barnes, J. (2005). Safe Pointers. AdaCore. Retrieved from: https://www.adacore.com/uploads_gems/03_safe_secure_ada_2005_safe_pointers.pdf. Computerphile (2017). Why C is so Influential? Retrieved from: https://www.youtube.com/watch?v=ci1PJexnfNE. Microsoft Docs (2020). Raw Pointers (C++). Microsoft Docs (2020). Smart Pointers (Modern C++). Microsoft Docs (2019). Object lifetime and resource management (RAII). Stroustrup, B. &amp; Sutter, H. (2021). C++ Core Guidelines. Retrieved from: http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#??? Stroustrup, B. (2013). The C++ programming language. Pearson Education.","headline":"On Pointer Types","mainEntityOfPage":{"@type":"WebPage","@id":"https://adeeconometrics.github.io//posts/On-Pointer-Types/"},"url":"https://adeeconometrics.github.io//posts/On-Pointer-Types/"}</script><title>On Pointer Types | Dave Amiana</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dave Amiana"><meta name="application-name" content="Dave Amiana"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0M61FBNQ0K"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0M61FBNQ0K'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/profile-picture.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dave Amiana</a></div><div class="site-subtitle font-italic">Open-source and Enterprise Software Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/adeeconometrics" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/dave-amiana/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['amiana.dave','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>On Pointer Types</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>On Pointer Types</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Dave Amiana </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Aug 12, 2021, 12:00 AM +0800" prep="on" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 22, 2022, 10:11 PM +0800" prefix="Updated " > Oct 22, 2022 <i class="unloaded">2022-10-22T22:11:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2400 words">13 min</span></div></div><div class="post-content"><p>In this article, I aim to introduce the concept and motivation behind using pointers. There are breeds of C++ developers that only use smart pointers for safety reasons, others that only use raw pointers for performance benefits, and some that use both whenever they provide the utmost benefits. In this article, I aim to highlight the use-cases of pointers so you can decide when to use one.</p><hr /><p>Conceptually, a pointer is a kind of reference. That is, a pointer refers to a certain block of memory of which acts as an entry point. To access the contents or modify the value of a pointer, we <em>dereference</em> it. Many languages have pointer-like features. Our concern revolves around the context of C and C++. Note that all C functions are valid in C++ but the opposite is not true. For this reason, our section on smart pointers is only applicable to C++.</p><p>Pointers are the basic structure to achieve reference semantics. Pointers are handy for naming another entity to be attributed by the contents of the referent entity. A pointer may access and manipulate the contents of the entity that it is <em>pointed</em> to, consider:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>int x = 5;
int *y = &amp;x;
*y = 10;
</pre></table></code></div></div><p>Pointers are introduced in C for the following reasons:</p><ul><li>Inexpensive parameter passing.<li>Allocate memory for new objects on the heap.<li>Passing a function reference to a function.<li>Iterate over data structures.</ul><p>The same thing is true in C++. In fact, iterators (a component for iterating over C++ Containers) resemble the interface of a pointer. But C++ has more to offer with a different set of modalities one can express reference semantics. We will focus on the set of reference modalities known as smart pointers. But before that, let us present a compelling reason for using smart pointers by enumerating the problems of raw pointers.</p><h2 id="raw-pointers">Raw Pointers</h2><p>Raw pointers are low-level types that pertain to a certain block of memory. As mentioned, pointers are entry points to access a value or modify it in a specific location in memory.</p><p>Some languages have restrictions on pointer types to a varying degree. For example, <a href="https://www.adacore.com/uploads_gems/03_safe_secure_ada_2005_safe_pointers.pdf">Ada</a> initializes a default value of their pointer types to null and makes a restriction for type conversions involving pointers mostly for type safety. While languages like <a href="https://www.youtube.com/watch?v=ci1PJexnfNE">Java </a> have banned the use of low-level pointer types to reduce programming error.</p><p>Therein creeps in the subtle shades of pointers. Now we ask what is the scene of pointer types in C?</p><p>In languages like C and C++, pointer types are very much used for low-level programming. Type conversion of pointer types has a varying degree of restrictions. In C, <code class="language-plaintext highlighter-rouge">void *</code> types are considered as raw pointer types which can be morphed into any type by an operation called typecasting.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">void</span><span class="o">*</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">){</span><span class="k">return</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">function</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The above snippet demonstrates that a <code class="language-plaintext highlighter-rouge">void *</code> type can be cast into an <code class="language-plaintext highlighter-rouge">int *</code>, or <em>any</em> type in that regard. Albeit not apparent with the above example, this is useful for abstraction which is a matter that we will not talk about here.</p><p>Raw pointers are concrete implementation of the more abstract concept of reference. Unlike Ada, raw pointers in C/C++ are not initialized in a null value, although they can refer to null which is a safer way of using raw pointers: if not initialized with the address of a referent, initialize it with <code class="language-plaintext highlighter-rouge">nullptr</code> (in C++) and <code class="language-plaintext highlighter-rouge">NULL</code> (in C). The reason behind this is to achieve well-defined behavior and avoid bugs that can be very difficult to fix, let alone find.</p><p>Raw pointers will not impose anything so misusing or abusing it are very easy to commit.</p><h3 id="the-dangling-problem">The Dangling Problem:</h3><p>Let us consider an instance that we are likely to encounter the dangling pointer problem. Let’s take a look at allocating and deallocating resources using <code class="language-plaintext highlighter-rouge">new</code> and <code class="language-plaintext highlighter-rouge">delete</code> function in C++ and <code class="language-plaintext highlighter-rouge">malloc</code> (<code class="language-plaintext highlighter-rouge">calloc</code>) or <code class="language-plaintext highlighter-rouge">free</code> in C.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="c1">// (int*)malloc(sizeof(int)) or (int*)calloc(1, sizeof(int)) in C</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"contends of i: "</span><span class="o">&lt;&lt;</span>  <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"address of i: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="c1">// free(i) in C</span>
    <span class="k">delete</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"contents of i: "</span> <span class="o">&lt;&lt;*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"address of i: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Note that <code class="language-plaintext highlighter-rouge">delete</code> or <code class="language-plaintext highlighter-rouge">free</code> functions only <em>removes</em> the contents of an entity, in this case, <code class="language-plaintext highlighter-rouge">i</code>. That is, dereferencing <code class="language-plaintext highlighter-rouge">i</code> still returns the memory location of <code class="language-plaintext highlighter-rouge">i</code> before it was deleted. This is problematic for it may introduce undefined behavior: dereferencing to an already freed memory is dangerous. To resolve this, we have to make sure that the <code class="language-plaintext highlighter-rouge">i</code> references to a well-defined location in memory hence we put <code class="language-plaintext highlighter-rouge">i = nullptr</code> (in C++) and <code class="language-plaintext highlighter-rouge">i = NULL</code> (in C) after deleting the contents of <code class="language-plaintext highlighter-rouge">i</code> to avoid critical mistakes.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"contends of i: "</span><span class="o">&lt;&lt;</span>  <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"address of i: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"contents of i: "</span> <span class="o">&lt;&lt;*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"address of i: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Another problem comes with determining the owning pointer which can result in serious issues from resource leaks, undefined behaviors to security vulnerabilities. Which pointer is responsible for which entity? It is difficult to keep track of multiple references and make sure that at the end of the scope such references are correctly managed. There has to be a clear expression to determine the owning pointer. Because of this, C++ introduced a reference management system that revolves around the idea of <a href="https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-160">RAII</a>.</p><h2 id="smart-pointers">Smart Pointers</h2><p>From the <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#???">C++ Standard</a> :</p><blockquote><p>Enforcing the lifetime safety profile eliminates leaks. When combined with resource safety provided by RAII, it eliminates the need for “garbage collection” (by generating no garbage). Combine this with enforcement of the type and bounds profiles and you get complete type- and resource-safety, guaranteed by tools.</p></blockquote><p>C++ introduced a set of classes for automatic resource management with very minimal to <strong>zero-cost</strong> performance penalties. Using these set of pointers has the following set of benefits:</p><ul><li>clarity of expressing ownership<li>guarantees that resources will not leak</ul><p>When appropriate, we should be using smart pointers for clearly expressing our intent with the kind of ownership we want to establish between the pointer and the entity it refers to. We have three smart pointers: <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;T&gt;</code>, and <code class="language-plaintext highlighter-rouge">std::weak_ptr&lt;T&gt;</code>. We can access these modalities in the <code class="language-plaintext highlighter-rouge">&lt;memory&gt;</code> header file.</p><p>Let us walk through and discover what these reference modalities have to offer. For our demonstration let us consider a class named <code class="language-plaintext highlighter-rouge">Entity</code> defined as:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Entity</span><span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"message from Entity. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="nl">public:</span>
        <span class="n">Entity</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of Entity are acquired. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
        <span class="o">~</span><span class="n">Entity</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of Entity is cleaned up. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">function</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span> <span class="k">return</span> <span class="n">str</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="unique-pointer">Unique Pointer</h3><p>Unique pointer maintains that there is only one pointer responsible for a given resource in memory. The owning pointer is responsible for the clean-up and resource management.</p><p>Let us define an instance of <code class="language-plaintext highlighter-rouge">Entity</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">e</span> <span class="p">(</span><span class="k">new</span> <span class="nf">Entity</span><span class="p">());</span>
</pre></table></code></div></div><p>Now, let us consider passing the pointer by reference and with move constructors to see its effect on where <code class="language-plaintext highlighter-rouge">Entity</code> is destroyed. Passing the unique pointer by reference means that the unique pointer is extended to a function, hence the clean-up happens after the unique pointer goes out of scope from the main function where it has been declared.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;&amp;</span> <span class="n">entity</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">entity</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span> <span class="n">e</span><span class="p">(</span><span class="k">new</span> <span class="n">Entity</span><span class="p">());</span>
    <span class="n">f</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"... </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Resources of Entity are acquired.
message from Entity.
...
Resources of Entity is cleaned up.
</pre></table></code></div></div><p>Passing the unique pointer with move constructors is transferring ownership to the unique pointer defined in function <code class="language-plaintext highlighter-rouge">f()</code>. We can notice the behavior has we run the following snippet:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span> <span class="n">entity</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">entity</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span> <span class="n">e</span><span class="p">(</span><span class="k">new</span> <span class="n">Entity</span><span class="p">());</span>
    <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"... </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Resources of Entity are acquired.
message from Entity.
Resources of Entity is cleaned up.
...
</pre></table></code></div></div><p>Since we transferred the ownership of <code class="language-plaintext highlighter-rouge">e</code> to <code class="language-plaintext highlighter-rouge">entity</code>, the clean-up happened as soon as the entity exits the function.</p><h3 id="shared-pointer">Shared Pointer</h3><p>The shared pointer has an additional mechanism called reference counting where it keeps track of pointers that request for sharing resources. Each time another pointer asks for shared resources, the reference counter adds one and for every time it goes out of scope it removes one. At the time where the reference count is 0, it calls for the clean-up. We can observe this mechanism with the following code snippet:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span> <span class="n">entity</span><span class="p">){</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"ref count: "</span> <span class="o">&lt;&lt;</span> <span class="n">entity</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">entity</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span> <span class="n">e</span><span class="p">(</span><span class="k">new</span> <span class="n">Entity</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"ref count: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f went out of scope. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"ref count: "</span> <span class="o">&lt;&lt;</span><span class="n">e</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"... </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Resources of Entity are acquired.
ref count: 1
ref count: 2
message from Entity.
f went out of scope.
ref count: 1
...
Resources of Entity is cleaned up.
</pre></table></code></div></div><p>When I first encountered this, I thought that is all I need, unique pointers and shared pointers are all there is to it. Until I encountered this problem called <strong>circular references</strong> where the troubles of shared references kick in. It is possible to break the guarantees of the shared pointer by forming a loop of circular references which results in resource leaks.</p><h4 id="the-circular-reference-problem">The Circular Reference Problem</h4><p>A circular reference has the form $A \to B$, $B \to A$. Let us put this into code.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">B</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">ab</span><span class="p">;</span>
	<span class="n">A</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of A are acquired. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
	<span class="o">~</span><span class="n">A</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of A are cleaned up. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="nc">B</span><span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">ba</span><span class="p">;</span>
	<span class="n">B</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of B are acquired. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
	<span class="o">~</span><span class="n">B</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of B are cleaned up. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">sa</span> <span class="p">(</span><span class="k">new</span> <span class="n">A</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">sb</span> <span class="p">(</span><span class="k">new</span> <span class="n">B</span><span class="p">());</span>

	<span class="n">sa</span><span class="o">-&gt;</span><span class="n">ab</span><span class="o">=</span><span class="n">sb</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">ba</span><span class="o">=</span><span class="n">sa</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>Resources of A are acquired.
Resources of B are acquired.
</pre></table></code></div></div><p>Since $A \to B$ and $B \to A$, the reference count will never resolve to zero – the condition which <code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;T&gt;</code> does its clean-up. We can observe the reference counts by the<code class="language-plaintext highlighter-rouge">use_count()</code> function. Let is modify the main function:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">sa</span> <span class="p">(</span><span class="k">new</span> <span class="n">A</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">sb</span> <span class="p">(</span><span class="k">new</span> <span class="n">B</span><span class="p">());</span>

	<span class="n">sa</span><span class="o">-&gt;</span><span class="n">ab</span><span class="o">=</span><span class="n">sb</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"count of ab: "</span> <span class="o">&lt;&lt;</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">ab</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">ba</span><span class="o">=</span><span class="n">sa</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"count of ba: "</span> <span class="o">&lt;&lt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">ba</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>Resources of A are acquired.
Resources of B are acquired.
count of ab: 2
count of ba: 2
</pre></table></code></div></div><p><strong>How do we break the curse?</strong> Introducing Weak Pointers.</p><h3 id="weak-pointer">Weak Pointer</h3><p>A weak pointer is a special type of pointer in conjunction with shared pointers. With weak pointers, you can access the contents of the shared pointer without increasing the reference count. This is useful for observing the contents of a shared resource and most notably resolving the problem of circular reference.</p><p>Let us solve the problem of circular reference through weak pointers. This can be achieved by modifying either <code class="language-plaintext highlighter-rouge">A::ab</code> or <code class="language-plaintext highlighter-rouge">B::ba</code> pointers.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">ab</span><span class="p">;</span>
	<span class="n">A</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of A are acquired. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
	<span class="o">~</span><span class="n">A</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of A are cleaned up. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

<span class="p">};</span>


<span class="k">struct</span> <span class="nc">B</span><span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">ba</span><span class="p">;</span>
	<span class="n">B</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of B are acquired. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
	<span class="o">~</span><span class="n">B</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of B are cleaned up. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">sa</span> <span class="p">(</span><span class="k">new</span> <span class="n">A</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">sb</span> <span class="p">(</span><span class="k">new</span> <span class="n">B</span><span class="p">());</span>

	<span class="n">sa</span><span class="o">-&gt;</span><span class="n">ab</span><span class="o">=</span><span class="n">sb</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"count of ab: "</span> <span class="o">&lt;&lt;</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">ab</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">ba</span><span class="o">=</span><span class="n">sa</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"count of ba: "</span> <span class="o">&lt;&lt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">ba</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Resources of A are acquired.
Resources of B are acquired.
count of ab: 2
count of ba: 1
Resources of A are cleaned up.
Resources of B are cleaned up.
</pre></table></code></div></div><hr /><h2 id="summary">Summary</h2><p>C++ does not use automatic reference management by default following their design philosophy of the <a href="https://bit.ly/2VMyrka">zero-overhead principle</a>. One can enable automatic reference management in C++ by making use of smart pointers defined in the standard library. It gives you resource guarantees and safety. Other languages such as <a href="https://bit.ly/3s9LNTI">Swift</a> and <a href="https://bit.ly/2U8hlwM">Rust</a> have adhered to the same concept instead of making sophisticated garbage collectors, they do not produce any garbage at all. This memory management model makes a very compelling case of using smart pointers. But raw pointers still have their brightest moments up to date.</p><p>Prefer using pointers for performance-critical loops or when the scope is clear enough to determine which is the owning pointer for a given resource. Raw pointers give you few performance benefits, but it comes with the cost of manually keeping track of your pointers, resource safety becomes your responsibility.</p><p>Prefer using smart pointers for expressing ownership clearly. Smart pointers give you resource guarantees which get rid of your task to make sure that there will be no leaks.</p><p>The <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#???">standard</a> recommends the following:</p><ul><li>Look at pointers: Classify them into non-owners (the default) and owners. Where feasible, replace owners with standard-library resource handles (as in the example above). Alternatively, mark an owner as such using owner from the <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl">GSL</a>.<li>Look for naked <code class="language-plaintext highlighter-rouge">new</code> and <code class="language-plaintext highlighter-rouge">delete</code><li>Look for known resource allocating functions returning raw pointers (such as <code class="language-plaintext highlighter-rouge">fopen</code>, <code class="language-plaintext highlighter-rouge">malloc</code>, and <code class="language-plaintext highlighter-rouge">strdup</code>)</ul><hr /><h2 id="references">References</h2><ol><li>Barnes, J. (2005). Safe Pointers. AdaCore. Retrieved from: https://www.adacore.com/uploads_gems/03_safe_secure_ada_2005_safe_pointers.pdf.<li>Computerphile (2017). Why C is so Influential? Retrieved from: https://www.youtube.com/watch?v=ci1PJexnfNE.<li>Microsoft Docs (2020). Raw Pointers (C++).<li>Microsoft Docs (2020). Smart Pointers (Modern C++).<li>Microsoft Docs (2019). Object lifetime and resource management (RAII).<li>Stroustrup, B. &amp; Sutter, H. (2021). C++ Core Guidelines. Retrieved from: http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#???<li>Stroustrup, B. (2013). The C++ programming language. Pearson Education.</ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a>, <a href='/categories/computer-science/'>Computer Science</a>, <a href='/categories/c/'>C++</a>, <a href='/categories/ownership-semantics/'>Ownership Semantics</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/programming/" class="post-tag no-text-decoration" >programming</a> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/ownership-semantics/" class="post-tag no-text-decoration" >Ownership Semantics</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=On Pointer Types - Dave Amiana&url=https://adeeconometrics.github.io//posts/On-Pointer-Types/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=On Pointer Types - Dave Amiana&u=https://adeeconometrics.github.io//posts/On-Pointer-Types/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=On Pointer Types - Dave Amiana&url=https://adeeconometrics.github.io//posts/On-Pointer-Types/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/On-Pointer-Types/">On Pointer Types</a><li><a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/">Pointers and References: Design Goals and Use Cases</a><li><a href="/posts/Unique-Reference/">Unique References</a><li><a href="/posts/Shared-Reference/">Shared References</a><li><a href="/posts/Weak-Reference/">Weak References</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Pointers and References: Design Goals and Use Cases</h3><div class="text-muted small"><p> At first, it seems that C++ makes things more complicated by introducing yet another layer of abstraction. References seem to encapsulate the same set of functionalities as pointers. Both of these ...</p></div></div></a></div><div class="card"> <a href="/posts/Unique-Reference/"><div class="card-body"> <span class="timeago small" > Aug 17, 2021 <i class="unloaded">2021-08-17T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Unique References</h3><div class="text-muted small"><p> Our previous discussion explores the anatomy of pointer types in C and C++ on par with hinting nuances of reference semantics. We discussed the use cases of raw pointers and smart pointers in moder...</p></div></div></a></div><div class="card"> <a href="/posts/Shared-Reference/"><div class="card-body"> <span class="timeago small" > Aug 20, 2021 <i class="unloaded">2021-08-20T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Shared References</h3><div class="text-muted small"><p> In our previous discussion, we fleshed out the design requirements and took action into servicing them. In the same way, this article aims to flesh out the design requirement for shared reference. ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Designing-Functions/" class="btn btn-outline-primary" prompt="Older"><p>Designing Functions</p></a> <a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/" class="btn btn-outline-primary" prompt="Newer"><p>Pointers and References: Design Goals and Use Cases</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/iamdeb25">Dave Amiana</a>.</p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://adeeconometrics.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
