<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Parameter Passing in C++" /><meta name="author" content="Dave Amiana" /><meta property="og:locale" content="en_US" /><meta name="description" content="C++ offers a myriad of configuration that enhances performance. Most of these can be traced with the idea of pointers and references. Pointers and references are tools for memory management that allow us to work closely with the hardware. They are beneficial in many ways but using them introduces overhead for the programmer. In other words, using pointers and references adds more responsibility for the programmer as they must assure what values their pointers are referencing towards, whatever happens when the value changes, and what resources will get affected. In large projects, it can be very difficult to keep track of the resources that depend on your function, class, or variable. To resolve this, the programmer must familiarize themselves with the techniques the language supported for maintaining efficiency and ease of use. After all, pointers and references deserve their own right to be included in a high-performing language like C/C++. In this blog, I’ll introduce different types of parameter passing and their use-cases. Since this topic is closely related to the scopes of variables and stack frames, it is important to note that resources that are local to the function are freed after the function is executed. So, returning references to local resources within a function can be problematic which often causes a compilation error. Generally, there two means of passing an argument to a function: pass by value, and pass by reference. But the concept of constness in C++ deserves its room for this discussion and we shall see more of that later. passing by value void function(Type _type); Passing an argument by value requires the program to copy the value of the type the argument has taken on. The main benefit of this method to the programmer is that they would not have to worry about incurring unintended changes anywhere else in their program. Local changes on the _type are ensured to only live within the scope of a function. Consider the code below: 1 2 3 4 5 6 7 void function(int _a){ std::cout&lt;&lt; a &lt;&lt;std::endl; } int main(){ int a = 5; function(a); } In the program, the function has copied the value of a, whenever we make changes on the value of _a within the scope of the program, that will not incur changes on the variable a that we declared on our main function. On the other hand, for enormous types, copying can take time. We pay for this extra amount of resources as they take a toll on our performance, and we don’t want that. So, what can we do? passing by reference void function(Type *_type) or void function(Type &amp;_type) Passing by reference allows seamless transaction of resources between functions. By seamless, I meant the program no longer copies the value of _type. Instead, it takes note of the memory address of that type and uses it thereafter. The catch is: whenever we make changes on _type, it manifests anywhere else on our program within which _type is used. Think of sharing a sheet of paper with your friend, any kind of changes done on that sheet of paper may be irreversible. And that’s what we ought to look for since our responsibility extends to keeping track of the functions that share on one piece of resources. In passing by reference, we are allowing our functions to rewrite _type. Consider the code below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void function(int *ptr){ std::cout&lt;&lt; *(ptr) &lt;&lt;std::endl; *ptr += 1; } void function(int &amp;a){ std::cout&lt;&lt; a &lt;&lt;std::endl; a += 1; } int main(){ int *ptr = nullptr; int a = 5; ptr = &amp;a; function(ptr); function(a); std::cout&lt;&lt; a &lt;&lt; std::endl; } The program outputs 5,6,7 as we updated the value of ptr and a which points to the same memory address where the initial value was 5. In many situations, we may want to consider the concept of sharing a single piece of resources. For instance, we may want to update _type such as keeping a record of time per transaction. But what if we want to restrict our references in a way that we guarantee that a function cannot change whatever the initial value of that reference? In this situation, we should consider passing an argument by const reference. passing by const reference void function(const Type &amp;_type) or void function(const Type *_type) Passing by const reference imposes a restriction that the value of our references is not allowed to be changed. This makes them read-only. Consider the code below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void function(const int *ptr){*ptr += 1;} void function(const int &amp;a){a += 1;} int main(){ int *ptr = nullptr; int a = 5; ptr = &amp;a; function(ptr); function(a); std::cout&lt;&lt; a &lt;&lt; std::endl; } The program throws a compiler error indicating that references cannot be updated. This type of parameter passing is useful whenever a large _type is passed on a function as we want to guarantee that the function cannot update the values of _type. Takeaways In summary, for small types such as primitive types, passing by value is apt. In situations where we may want to update the values or enormous types, we should consider passing by reference whereas in situations where we want to guarantee that a function cannot change the value of _type, passing by const reference impose the rule that _type cannot be updated." /><meta property="og:description" content="C++ offers a myriad of configuration that enhances performance. Most of these can be traced with the idea of pointers and references. Pointers and references are tools for memory management that allow us to work closely with the hardware. They are beneficial in many ways but using them introduces overhead for the programmer. In other words, using pointers and references adds more responsibility for the programmer as they must assure what values their pointers are referencing towards, whatever happens when the value changes, and what resources will get affected. In large projects, it can be very difficult to keep track of the resources that depend on your function, class, or variable. To resolve this, the programmer must familiarize themselves with the techniques the language supported for maintaining efficiency and ease of use. After all, pointers and references deserve their own right to be included in a high-performing language like C/C++. In this blog, I’ll introduce different types of parameter passing and their use-cases. Since this topic is closely related to the scopes of variables and stack frames, it is important to note that resources that are local to the function are freed after the function is executed. So, returning references to local resources within a function can be problematic which often causes a compilation error. Generally, there two means of passing an argument to a function: pass by value, and pass by reference. But the concept of constness in C++ deserves its room for this discussion and we shall see more of that later. passing by value void function(Type _type); Passing an argument by value requires the program to copy the value of the type the argument has taken on. The main benefit of this method to the programmer is that they would not have to worry about incurring unintended changes anywhere else in their program. Local changes on the _type are ensured to only live within the scope of a function. Consider the code below: 1 2 3 4 5 6 7 void function(int _a){ std::cout&lt;&lt; a &lt;&lt;std::endl; } int main(){ int a = 5; function(a); } In the program, the function has copied the value of a, whenever we make changes on the value of _a within the scope of the program, that will not incur changes on the variable a that we declared on our main function. On the other hand, for enormous types, copying can take time. We pay for this extra amount of resources as they take a toll on our performance, and we don’t want that. So, what can we do? passing by reference void function(Type *_type) or void function(Type &amp;_type) Passing by reference allows seamless transaction of resources between functions. By seamless, I meant the program no longer copies the value of _type. Instead, it takes note of the memory address of that type and uses it thereafter. The catch is: whenever we make changes on _type, it manifests anywhere else on our program within which _type is used. Think of sharing a sheet of paper with your friend, any kind of changes done on that sheet of paper may be irreversible. And that’s what we ought to look for since our responsibility extends to keeping track of the functions that share on one piece of resources. In passing by reference, we are allowing our functions to rewrite _type. Consider the code below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void function(int *ptr){ std::cout&lt;&lt; *(ptr) &lt;&lt;std::endl; *ptr += 1; } void function(int &amp;a){ std::cout&lt;&lt; a &lt;&lt;std::endl; a += 1; } int main(){ int *ptr = nullptr; int a = 5; ptr = &amp;a; function(ptr); function(a); std::cout&lt;&lt; a &lt;&lt; std::endl; } The program outputs 5,6,7 as we updated the value of ptr and a which points to the same memory address where the initial value was 5. In many situations, we may want to consider the concept of sharing a single piece of resources. For instance, we may want to update _type such as keeping a record of time per transaction. But what if we want to restrict our references in a way that we guarantee that a function cannot change whatever the initial value of that reference? In this situation, we should consider passing an argument by const reference. passing by const reference void function(const Type &amp;_type) or void function(const Type *_type) Passing by const reference imposes a restriction that the value of our references is not allowed to be changed. This makes them read-only. Consider the code below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void function(const int *ptr){*ptr += 1;} void function(const int &amp;a){a += 1;} int main(){ int *ptr = nullptr; int a = 5; ptr = &amp;a; function(ptr); function(a); std::cout&lt;&lt; a &lt;&lt; std::endl; } The program throws a compiler error indicating that references cannot be updated. This type of parameter passing is useful whenever a large _type is passed on a function as we want to guarantee that the function cannot update the values of _type. Takeaways In summary, for small types such as primitive types, passing by value is apt. In situations where we may want to update the values or enormous types, we should consider passing by reference whereas in situations where we want to guarantee that a function cannot change the value of _type, passing by const reference impose the rule that _type cannot be updated." /><link rel="canonical" href="https://adeeconometrics.github.io//posts/Parameter-Passing-in-Cpp/" /><meta property="og:url" content="https://adeeconometrics.github.io//posts/Parameter-Passing-in-Cpp/" /><meta property="og:site_name" content="Dave Amiana" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-10T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Parameter Passing in C++" /><meta name="twitter:site" content="@iamdeb25" /><meta name="twitter:creator" content="@Dave Amiana" /><meta name="google-site-verification" content="google-site-verification=28bVbRErS2VwJaonXuu3GbqmRlyNvizt6I00B2kQh88" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Dave Amiana"},"dateModified":"2022-10-22T22:11:50+08:00","datePublished":"2021-04-10T00:00:00+08:00","description":"C++ offers a myriad of configuration that enhances performance. Most of these can be traced with the idea of pointers and references. Pointers and references are tools for memory management that allow us to work closely with the hardware. They are beneficial in many ways but using them introduces overhead for the programmer. In other words, using pointers and references adds more responsibility for the programmer as they must assure what values their pointers are referencing towards, whatever happens when the value changes, and what resources will get affected. In large projects, it can be very difficult to keep track of the resources that depend on your function, class, or variable. To resolve this, the programmer must familiarize themselves with the techniques the language supported for maintaining efficiency and ease of use. After all, pointers and references deserve their own right to be included in a high-performing language like C/C++. In this blog, I’ll introduce different types of parameter passing and their use-cases. Since this topic is closely related to the scopes of variables and stack frames, it is important to note that resources that are local to the function are freed after the function is executed. So, returning references to local resources within a function can be problematic which often causes a compilation error. Generally, there two means of passing an argument to a function: pass by value, and pass by reference. But the concept of constness in C++ deserves its room for this discussion and we shall see more of that later. passing by value void function(Type _type); Passing an argument by value requires the program to copy the value of the type the argument has taken on. The main benefit of this method to the programmer is that they would not have to worry about incurring unintended changes anywhere else in their program. Local changes on the _type are ensured to only live within the scope of a function. Consider the code below: 1 2 3 4 5 6 7 void function(int _a){ std::cout&lt;&lt; a &lt;&lt;std::endl; } int main(){ int a = 5; function(a); } In the program, the function has copied the value of a, whenever we make changes on the value of _a within the scope of the program, that will not incur changes on the variable a that we declared on our main function. On the other hand, for enormous types, copying can take time. We pay for this extra amount of resources as they take a toll on our performance, and we don’t want that. So, what can we do? passing by reference void function(Type *_type) or void function(Type &amp;_type) Passing by reference allows seamless transaction of resources between functions. By seamless, I meant the program no longer copies the value of _type. Instead, it takes note of the memory address of that type and uses it thereafter. The catch is: whenever we make changes on _type, it manifests anywhere else on our program within which _type is used. Think of sharing a sheet of paper with your friend, any kind of changes done on that sheet of paper may be irreversible. And that’s what we ought to look for since our responsibility extends to keeping track of the functions that share on one piece of resources. In passing by reference, we are allowing our functions to rewrite _type. Consider the code below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void function(int *ptr){ std::cout&lt;&lt; *(ptr) &lt;&lt;std::endl; *ptr += 1; } void function(int &amp;a){ std::cout&lt;&lt; a &lt;&lt;std::endl; a += 1; } int main(){ int *ptr = nullptr; int a = 5; ptr = &amp;a; function(ptr); function(a); std::cout&lt;&lt; a &lt;&lt; std::endl; } The program outputs 5,6,7 as we updated the value of ptr and a which points to the same memory address where the initial value was 5. In many situations, we may want to consider the concept of sharing a single piece of resources. For instance, we may want to update _type such as keeping a record of time per transaction. But what if we want to restrict our references in a way that we guarantee that a function cannot change whatever the initial value of that reference? In this situation, we should consider passing an argument by const reference. passing by const reference void function(const Type &amp;_type) or void function(const Type *_type) Passing by const reference imposes a restriction that the value of our references is not allowed to be changed. This makes them read-only. Consider the code below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void function(const int *ptr){*ptr += 1;} void function(const int &amp;a){a += 1;} int main(){ int *ptr = nullptr; int a = 5; ptr = &amp;a; function(ptr); function(a); std::cout&lt;&lt; a &lt;&lt; std::endl; } The program throws a compiler error indicating that references cannot be updated. This type of parameter passing is useful whenever a large _type is passed on a function as we want to guarantee that the function cannot update the values of _type. Takeaways In summary, for small types such as primitive types, passing by value is apt. In situations where we may want to update the values or enormous types, we should consider passing by reference whereas in situations where we want to guarantee that a function cannot change the value of _type, passing by const reference impose the rule that _type cannot be updated.","headline":"Parameter Passing in C++","mainEntityOfPage":{"@type":"WebPage","@id":"https://adeeconometrics.github.io//posts/Parameter-Passing-in-Cpp/"},"url":"https://adeeconometrics.github.io//posts/Parameter-Passing-in-Cpp/"}</script><title>Parameter Passing in C++ | Dave Amiana</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dave Amiana"><meta name="application-name" content="Dave Amiana"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0M61FBNQ0K"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0M61FBNQ0K'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/profile-picture.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dave Amiana</a></div><div class="site-subtitle font-italic">Open-source and Enterprise Software Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/adeeconometrics" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/dave-amiana/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['amiana.dave','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Parameter Passing in C++</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Parameter Passing in C++</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Dave Amiana </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Apr 10, 2021, 12:00 AM +0800" prep="on" > Apr 10, 2021 <i class="unloaded">2021-04-10T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 22, 2022, 10:11 PM +0800" prefix="Updated " > Oct 22, 2022 <i class="unloaded">2022-10-22T22:11:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="910 words">5 min</span></div></div><div class="post-content"><p>C++ offers a myriad of configuration that enhances performance. Most of these can be traced with the idea of <em>pointers and references</em>. Pointers and references are tools for memory management that allow us to work closely with the hardware. They are beneficial in many ways but using them introduces overhead for the programmer. In other words, using pointers and references adds more responsibility for the programmer as they must assure what values their pointers are referencing towards, whatever happens when the value changes, and what resources will get affected. In large projects, it can be very difficult to keep track of the resources that depend on your function, class, or variable.</p><p>To resolve this, the programmer must familiarize themselves with the techniques the language supported for maintaining efficiency and ease of use. After all, pointers and references deserve their own right to be included in a high-performing language like C/C++. In this blog, I’ll introduce different types of parameter passing and their use-cases.</p><p>Since this topic is closely related to the <a href="https://docs.microsoft.com/en-us/cpp/cpp/scope-visual-cpp#:~:text=When%20you%20declare%20a%20program,visible%20within%20that%20function%20body.">scopes of variables</a> and stack frames, it is important to note that resources that are local to the function are freed after the function is executed. So, returning references to local resources within a function can be problematic which often causes a compilation error.</p><p>Generally, there two means of passing an argument to a function: pass by value, and pass by reference. But the concept of constness in C++ deserves its room for this discussion and we shall see more of that later.</p><hr /><h4 id="passing-by-value-void-functiontype-_type">passing by value <code class="language-plaintext highlighter-rouge">void function(Type _type);</code></h4><p>Passing an argument by value requires the program to copy the value of the type the argument has taken on. The main benefit of this method to the programmer is that they would not have to worry about incurring unintended changes anywhere else in their program. Local changes on the <code class="language-plaintext highlighter-rouge">_type</code> are ensured to only <em>live</em> within the scope of a function.</p><p>Consider the code below:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span> <span class="n">_a</span><span class="p">){</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In the program, the <code class="language-plaintext highlighter-rouge">function</code> has copied the value of <code class="language-plaintext highlighter-rouge">a</code>, whenever we make changes on the value of <code class="language-plaintext highlighter-rouge">_a</code> within the scope of the program, that will not incur changes on the variable <code class="language-plaintext highlighter-rouge">a</code> that we declared on our main function.</p><p>On the other hand, for enormous types, copying can take time. We pay for this extra amount of resources as they take a toll on our performance, and we don’t want that. So, what can we do?</p><hr /><h4 id="passing-by-reference-void-functiontype-_type-or-void-functiontype-_type">passing by reference <code class="language-plaintext highlighter-rouge">void function(Type *_type)</code> or <code class="language-plaintext highlighter-rouge">void function(Type &amp;_type)</code></h4><p>Passing by reference allows seamless transaction of resources between functions. By seamless, I meant the program no longer copies the value of <code class="language-plaintext highlighter-rouge">_type</code>. Instead, it takes note of the memory address of that type and uses it thereafter. The catch is: whenever we make changes on <code class="language-plaintext highlighter-rouge">_type</code>, it manifests anywhere else on our program within which <code class="language-plaintext highlighter-rouge">_type</code> is used.</p><p>Think of sharing a sheet of paper with your friend, any kind of changes done on that sheet of paper may be irreversible. And that’s what we ought to look for since our responsibility extends to keeping track of the functions that share on one piece of resources. In passing by reference, we are allowing our functions to rewrite <code class="language-plaintext highlighter-rouge">_type</code>.</p><p>Consider the code below:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">){</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">){</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

	<span class="n">function</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
	<span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

	<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The program outputs <code class="language-plaintext highlighter-rouge">5,6,7</code> as we updated the value of <code class="language-plaintext highlighter-rouge">ptr</code> and <code class="language-plaintext highlighter-rouge">a</code> which points to the same memory address where the initial value was <code class="language-plaintext highlighter-rouge">5</code>. In many situations, we may want to consider the concept of sharing a single piece of resources. For instance, we may want to update <code class="language-plaintext highlighter-rouge">_type</code> such as keeping a record of time per transaction.</p><p>But what if we want to restrict our references in a way that we guarantee that a function cannot change whatever the initial value of that reference? In this situation, we should consider passing an argument by <code class="language-plaintext highlighter-rouge">const reference</code>.</p><hr /><h4 id="passing-by-const-reference-void-functionconst-type-_type-or-void-functionconst-type-_type">passing by <code class="language-plaintext highlighter-rouge">const</code> reference <code class="language-plaintext highlighter-rouge">void function(const Type &amp;_type)</code> or <code class="language-plaintext highlighter-rouge">void function(const Type *_type)</code></h4><p>Passing by const reference imposes a restriction that the value of our references is not allowed to be changed. This makes them <em>read-only</em>.</p><p>Consider the code below:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">function</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">){</span><span class="o">*</span><span class="n">ptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;}</span>

<span class="kt">void</span> <span class="nf">function</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">){</span><span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

	<span class="n">function</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
	<span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

	<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The program throws a compiler error indicating that references cannot be updated. This type of parameter passing is useful whenever a large <code class="language-plaintext highlighter-rouge">_type</code> is passed on a function as we want to guarantee that the function cannot update the values of <code class="language-plaintext highlighter-rouge">_type</code>.</p><hr /><h1 id="takeaways">Takeaways</h1><p>In summary, for small types such as primitive types, passing by value is apt. In situations where we may want to update the values or enormous types, we should consider passing by reference whereas in situations where we want to guarantee that a function cannot change the value of <code class="language-plaintext highlighter-rouge">_type</code>, passing by const reference impose the rule that <code class="language-plaintext highlighter-rouge">_type</code> cannot be updated.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/computer-science/'>Computer Science</a>, <a href='/categories/c/'>C++</a>, <a href='/categories/programming/'>Programming</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/programming/" class="post-tag no-text-decoration" >Programming</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Parameter Passing in C++ - Dave Amiana&url=https://adeeconometrics.github.io//posts/Parameter-Passing-in-Cpp/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Parameter Passing in C++ - Dave Amiana&u=https://adeeconometrics.github.io//posts/Parameter-Passing-in-Cpp/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Parameter Passing in C++ - Dave Amiana&url=https://adeeconometrics.github.io//posts/Parameter-Passing-in-Cpp/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/On-Pointer-Types/">On Pointer Types</a><li><a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/">Pointers and References: Design Goals and Use Cases</a><li><a href="/posts/Unique-Reference/">Unique References</a><li><a href="/posts/Shared-Reference/">Shared References</a><li><a href="/posts/Weak-Reference/">Weak References</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/On-Pointer-Types/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>On Pointer Types</h3><div class="text-muted small"><p> In this article, I aim to introduce the concept and motivation behind using pointers. There are breeds of C++ developers that only use smart pointers for safety reasons, others that only use raw po...</p></div></div></a></div><div class="card"> <a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Pointers and References: Design Goals and Use Cases</h3><div class="text-muted small"><p> At first, it seems that C++ makes things more complicated by introducing yet another layer of abstraction. References seem to encapsulate the same set of functionalities as pointers. Both of these ...</p></div></div></a></div><div class="card"> <a href="/posts/Unique-Reference/"><div class="card-body"> <span class="timeago small" > Aug 17, 2021 <i class="unloaded">2021-08-17T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Unique References</h3><div class="text-muted small"><p> Our previous discussion explores the anatomy of pointer types in C and C++ on par with hinting nuances of reference semantics. We discussed the use cases of raw pointers and smart pointers in moder...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Programming-for-Beginners/" class="btn btn-outline-primary" prompt="Older"><p>Programming for Beginners</p></a> <a href="/posts/Python-Typed-Annotations/" class="btn btn-outline-primary" prompt="Newer"><p>Python Typed Annotations</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/iamdeb25">Dave Amiana</a>.</p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://adeeconometrics.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
