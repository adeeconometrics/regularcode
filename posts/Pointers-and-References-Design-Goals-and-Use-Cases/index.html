<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Pointers and References: Design Goals and Use Cases" /><meta name="author" content="Dave Amiana" /><meta property="og:locale" content="en_US" /><meta name="description" content="At first, it seems that C++ makes things more complicated by introducing yet another layer of abstraction. References seem to encapsulate the same set of functionalities as pointers. Both of these constructs are used to refer to another entity as they provide access points into manipulating the contents of the referent entity; they are both allocated on the heap. With this, we are faced with the following questions: Are pointers and references the same thing? Are there any techniques that pointers can only do and vice-versa? When do we favor pointers over references and vice-versa? By the end of this article, I hope to disentangle these two concepts and aim to give a reason why references deserve their own right for building more robust higher-order concepts. Pointers Pointers are introduced in C. Pointers store the memory address of an entity of type T (where T is a template parameter that can be resolved to any types), as mentioned, it provides an access point for changing the values of the entity it points to. Consider the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; int main(){ int x = 10; // sets the content of x to 10. int *y = &amp;x; // sets the pointer to the address of x *y = 5; // changes the content of &amp;x to 5. std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;; // outputs to content of x that is 5. std::cout &lt;&lt; y &lt;&lt; &#39;\n&#39;; // outputs the memory address of x. std::cout &lt;&lt; &amp;x &lt;&lt; &#39;\n&#39;; // outputs the memory address of x. } Pointers are great for making use of indirections that manipulate the contents within a certain block of memory. Let us modify the above code to demonstrate a series of indirection as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; int main(){ int x = 10; int *y = &amp;x; int *z = y; // takes the address of y i.e. &amp;x. *z = 6; // changes the content of &amp;x. std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &amp;x &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; y &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; z &lt;&lt; &#39;\n&#39;; } We can extend this by nesting them together: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; int main(){ int x = 10; int *y = &amp;x; int **z = &amp;y; // declares a double pointer that is pointed to the address of y. **z = 6; // dereferencing of a double pointer to change the content of x. std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &amp;x &lt;&lt; &#39;\n&#39;; // outputs the address of x. std::cout &lt;&lt; &amp;y &lt;&lt; &#39;\n&#39;; // outputs the address of y. std::cout &lt;&lt; z &lt;&lt; &#39;\n&#39;; // outputs the address of y. } As we notice, the address of pointers is not the same as the address of its reference. This observation is because pointers have their own identity. Consequently, pointers can be reassigned to another variable more so they can tolerate null values: NULL and nullptr (prefer using nullptr if you are using pointers). That is, int *x = nullptr is valid and will compile. More so, pointers can iterate over arrays with pre- and post-increment operators, pre- and post-decrement operators, and subscript operators. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; void iterate(int* a_ptr, size_t a_size){ for(size_t i = 0; i &lt; a_size; ++i){ std::cout &lt;&lt; a_ptr[i] &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\n&#39; &lt;&lt; *(++a_ptr); // 2 std::cout &lt;&lt; &#39;\n&#39; &lt;&lt; *(--a_ptr); // 1 std::cout &lt;&lt; &#39;\n&#39; &lt;&lt; *(a_ptr++); // 1 std::cout &lt;&lt; &#39;\n&#39; &lt;&lt; *(a_ptr--); // 2 } int main(){ int array[5]{1,2,3,4,5}; int *ptr_arr = array; iterate(ptr_arr, 5); } As mentioned, pointers can be used for allocating values on the heap as well as writing in that location. Let’s consider allocating memory for an array block with size 3: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; void output(int* a_ptr, size_t a_size){ std::cout &lt;&lt; &#39;\n&#39;; for(size_t i = 0; i &lt; a_size; ++i) std::cout &lt;&lt; a_ptr[i] &lt;&lt; &quot; &quot;; } int main(){ int *array = new int[3]; // printing uninitialized array output(array, 3); // writing values on array block for(size_t i = 0; i &lt; 3; ++i) array[i] = i+1; output(array, 3); // deallocates the memory delete [] array; } Reminders for using Pointers Pointers can be difficult to manage as they can be nested and combined without restrictions, this can result in a complicated piece of code that is hard to maintain. Pointers may leak resources if not properly managed: ensure clean-ups when pointer types are no longer needed remember to deallocate resources allocated on the heap when they are no longer relevant to your code. Prefer using smart pointers: std::unique_ptr&lt;T&gt; u_ptr, std::shared_ptr&lt;T&gt; s_ptr, and std::weak_ptr&lt;T&gt; w_ptr over raw pointers when performance is secondary to safety or finer grain of control are unnecessary. Smart pointers allow you to automate clean-up through RAII with a minimal performance cost, in the case of u_ptr there is zero performance overhead. For pointer objects ptr_obj or user-defined types, members can be accessed through arrow operator e.g. ptr_obj-&gt; function(). References References make things more convenient to express, it provides the necessary set of constraints for expressing ownership semantics – a topic that is beyond our concern, for now. C++ follows the design principle that solutions that adhere to the standards should be easier than the alternatives. Now that we know about pointers, how do we contrast this with references? References can be thought of as a constant pointer T const* c_ptr = &amp;obj and should not be confused with const T* ref = &amp;obj: The former allows the contents of the object to be modified but restricts the address to refer to obj, the latter reverses the effect and only restricts the obj to be modified. 1 2 3 int x = 5, y = 6; int *const ptr = &amp;x; ptr = &amp;y; // error To modify the content of x and set it to y we say: 1 2 3 int x = 5, y = 6; int *const ptr = &amp;x; *ptr = y; The same effect is achieved with references. As a result, references bind to the location of the entity in memory. It allows the contents of an entity to be modified, but it cannot be reassigned and must be bound at initialization. Therefore, the reference of an entity assumes the entity of the original variable. As mentioned, references can also allocate memory for a single entity on the heap. 1 2 3 4 int &amp;ref = *(new int(0)); std::cout &lt;&lt; ref &lt;&lt;&#39;\n&#39;; ref = 3; std::cout &lt;&lt; ref; Reminders for using References References cannot be assigned to nullptr. References cannot iterate over arrays. Returning references over local variables may cause undefined behavior (dangling references). References must be bound to an existing entity. References only allow for one level of indirection. References express the intention clearly and concisely. Since C++11 standards, references have been used more often as the elements for move semantics are built from the notion of references (lvalue and rvalue references). Summary Are pointers and references the same thing? No. Are there any techniques that pointers can only do and vice-versa? Pointers are more flexible than references which can make your code complicated if not managed well. T const* ref achieves the same behavior of references, except for array referencing which gives us more reason for choosing references over pointers (when appropriate) as its semantics restrict iterating over array-like structures: 1 2 int const *r = &amp;*(new int[3]{1,3,4}); std::cout &lt;&lt; r[2] &lt;&lt;&#39;\n&#39;; Whereas array indexing with references will result to compiler error: 1 2 int &amp;r = *(new int[3]{1,3,4}; std::cout &lt;&lt; r[2] &lt;&lt;&#39;\n&#39;; When do we favor pointers over references and vice-versa? Pointer types are generally useful for setting up a separate field of indirection capable of modifying the contents of multiple variables of the same type. Having the same pointer accessing multiple variables may be difficult to trace and reason with. It is preferred to maintain clarity over the convenience of typing one pointer to all variables of the same type. For this reason, making use of references is safer. Pointers are not really terrible, in fact, they are one of the greatest features we unlock in languages like C/C++, however, their power comes with a cost. In conclusion, references are not just syntax sugar to cast T const*, it has its own design goals and purpose namely containing the address of declared entities. This improves the clarity of our intent, and in these situations, the C++ compiler is our friend." /><meta property="og:description" content="At first, it seems that C++ makes things more complicated by introducing yet another layer of abstraction. References seem to encapsulate the same set of functionalities as pointers. Both of these constructs are used to refer to another entity as they provide access points into manipulating the contents of the referent entity; they are both allocated on the heap. With this, we are faced with the following questions: Are pointers and references the same thing? Are there any techniques that pointers can only do and vice-versa? When do we favor pointers over references and vice-versa? By the end of this article, I hope to disentangle these two concepts and aim to give a reason why references deserve their own right for building more robust higher-order concepts. Pointers Pointers are introduced in C. Pointers store the memory address of an entity of type T (where T is a template parameter that can be resolved to any types), as mentioned, it provides an access point for changing the values of the entity it points to. Consider the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; int main(){ int x = 10; // sets the content of x to 10. int *y = &amp;x; // sets the pointer to the address of x *y = 5; // changes the content of &amp;x to 5. std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;; // outputs to content of x that is 5. std::cout &lt;&lt; y &lt;&lt; &#39;\n&#39;; // outputs the memory address of x. std::cout &lt;&lt; &amp;x &lt;&lt; &#39;\n&#39;; // outputs the memory address of x. } Pointers are great for making use of indirections that manipulate the contents within a certain block of memory. Let us modify the above code to demonstrate a series of indirection as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; int main(){ int x = 10; int *y = &amp;x; int *z = y; // takes the address of y i.e. &amp;x. *z = 6; // changes the content of &amp;x. std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &amp;x &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; y &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; z &lt;&lt; &#39;\n&#39;; } We can extend this by nesting them together: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; int main(){ int x = 10; int *y = &amp;x; int **z = &amp;y; // declares a double pointer that is pointed to the address of y. **z = 6; // dereferencing of a double pointer to change the content of x. std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &amp;x &lt;&lt; &#39;\n&#39;; // outputs the address of x. std::cout &lt;&lt; &amp;y &lt;&lt; &#39;\n&#39;; // outputs the address of y. std::cout &lt;&lt; z &lt;&lt; &#39;\n&#39;; // outputs the address of y. } As we notice, the address of pointers is not the same as the address of its reference. This observation is because pointers have their own identity. Consequently, pointers can be reassigned to another variable more so they can tolerate null values: NULL and nullptr (prefer using nullptr if you are using pointers). That is, int *x = nullptr is valid and will compile. More so, pointers can iterate over arrays with pre- and post-increment operators, pre- and post-decrement operators, and subscript operators. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; void iterate(int* a_ptr, size_t a_size){ for(size_t i = 0; i &lt; a_size; ++i){ std::cout &lt;&lt; a_ptr[i] &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\n&#39; &lt;&lt; *(++a_ptr); // 2 std::cout &lt;&lt; &#39;\n&#39; &lt;&lt; *(--a_ptr); // 1 std::cout &lt;&lt; &#39;\n&#39; &lt;&lt; *(a_ptr++); // 1 std::cout &lt;&lt; &#39;\n&#39; &lt;&lt; *(a_ptr--); // 2 } int main(){ int array[5]{1,2,3,4,5}; int *ptr_arr = array; iterate(ptr_arr, 5); } As mentioned, pointers can be used for allocating values on the heap as well as writing in that location. Let’s consider allocating memory for an array block with size 3: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; void output(int* a_ptr, size_t a_size){ std::cout &lt;&lt; &#39;\n&#39;; for(size_t i = 0; i &lt; a_size; ++i) std::cout &lt;&lt; a_ptr[i] &lt;&lt; &quot; &quot;; } int main(){ int *array = new int[3]; // printing uninitialized array output(array, 3); // writing values on array block for(size_t i = 0; i &lt; 3; ++i) array[i] = i+1; output(array, 3); // deallocates the memory delete [] array; } Reminders for using Pointers Pointers can be difficult to manage as they can be nested and combined without restrictions, this can result in a complicated piece of code that is hard to maintain. Pointers may leak resources if not properly managed: ensure clean-ups when pointer types are no longer needed remember to deallocate resources allocated on the heap when they are no longer relevant to your code. Prefer using smart pointers: std::unique_ptr&lt;T&gt; u_ptr, std::shared_ptr&lt;T&gt; s_ptr, and std::weak_ptr&lt;T&gt; w_ptr over raw pointers when performance is secondary to safety or finer grain of control are unnecessary. Smart pointers allow you to automate clean-up through RAII with a minimal performance cost, in the case of u_ptr there is zero performance overhead. For pointer objects ptr_obj or user-defined types, members can be accessed through arrow operator e.g. ptr_obj-&gt; function(). References References make things more convenient to express, it provides the necessary set of constraints for expressing ownership semantics – a topic that is beyond our concern, for now. C++ follows the design principle that solutions that adhere to the standards should be easier than the alternatives. Now that we know about pointers, how do we contrast this with references? References can be thought of as a constant pointer T const* c_ptr = &amp;obj and should not be confused with const T* ref = &amp;obj: The former allows the contents of the object to be modified but restricts the address to refer to obj, the latter reverses the effect and only restricts the obj to be modified. 1 2 3 int x = 5, y = 6; int *const ptr = &amp;x; ptr = &amp;y; // error To modify the content of x and set it to y we say: 1 2 3 int x = 5, y = 6; int *const ptr = &amp;x; *ptr = y; The same effect is achieved with references. As a result, references bind to the location of the entity in memory. It allows the contents of an entity to be modified, but it cannot be reassigned and must be bound at initialization. Therefore, the reference of an entity assumes the entity of the original variable. As mentioned, references can also allocate memory for a single entity on the heap. 1 2 3 4 int &amp;ref = *(new int(0)); std::cout &lt;&lt; ref &lt;&lt;&#39;\n&#39;; ref = 3; std::cout &lt;&lt; ref; Reminders for using References References cannot be assigned to nullptr. References cannot iterate over arrays. Returning references over local variables may cause undefined behavior (dangling references). References must be bound to an existing entity. References only allow for one level of indirection. References express the intention clearly and concisely. Since C++11 standards, references have been used more often as the elements for move semantics are built from the notion of references (lvalue and rvalue references). Summary Are pointers and references the same thing? No. Are there any techniques that pointers can only do and vice-versa? Pointers are more flexible than references which can make your code complicated if not managed well. T const* ref achieves the same behavior of references, except for array referencing which gives us more reason for choosing references over pointers (when appropriate) as its semantics restrict iterating over array-like structures: 1 2 int const *r = &amp;*(new int[3]{1,3,4}); std::cout &lt;&lt; r[2] &lt;&lt;&#39;\n&#39;; Whereas array indexing with references will result to compiler error: 1 2 int &amp;r = *(new int[3]{1,3,4}; std::cout &lt;&lt; r[2] &lt;&lt;&#39;\n&#39;; When do we favor pointers over references and vice-versa? Pointer types are generally useful for setting up a separate field of indirection capable of modifying the contents of multiple variables of the same type. Having the same pointer accessing multiple variables may be difficult to trace and reason with. It is preferred to maintain clarity over the convenience of typing one pointer to all variables of the same type. For this reason, making use of references is safer. Pointers are not really terrible, in fact, they are one of the greatest features we unlock in languages like C/C++, however, their power comes with a cost. In conclusion, references are not just syntax sugar to cast T const*, it has its own design goals and purpose namely containing the address of declared entities. This improves the clarity of our intent, and in these situations, the C++ compiler is our friend." /><link rel="canonical" href="https://adeeconometrics.github.io//posts/Pointers-and-References-Design-Goals-and-Use-Cases/" /><meta property="og:url" content="https://adeeconometrics.github.io//posts/Pointers-and-References-Design-Goals-and-Use-Cases/" /><meta property="og:site_name" content="Dave Amiana" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-12T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Pointers and References: Design Goals and Use Cases" /><meta name="twitter:site" content="@iamdeb25" /><meta name="twitter:creator" content="@Dave Amiana" /><meta name="google-site-verification" content="google-site-verification=28bVbRErS2VwJaonXuu3GbqmRlyNvizt6I00B2kQh88" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Dave Amiana"},"dateModified":"2022-10-22T22:11:50+08:00","datePublished":"2021-08-12T00:00:00+08:00","description":"At first, it seems that C++ makes things more complicated by introducing yet another layer of abstraction. References seem to encapsulate the same set of functionalities as pointers. Both of these constructs are used to refer to another entity as they provide access points into manipulating the contents of the referent entity; they are both allocated on the heap. With this, we are faced with the following questions: Are pointers and references the same thing? Are there any techniques that pointers can only do and vice-versa? When do we favor pointers over references and vice-versa? By the end of this article, I hope to disentangle these two concepts and aim to give a reason why references deserve their own right for building more robust higher-order concepts. Pointers Pointers are introduced in C. Pointers store the memory address of an entity of type T (where T is a template parameter that can be resolved to any types), as mentioned, it provides an access point for changing the values of the entity it points to. Consider the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; int main(){ int x = 10; // sets the content of x to 10. int *y = &amp;x; // sets the pointer to the address of x *y = 5; // changes the content of &amp;x to 5. std::cout &lt;&lt; x &lt;&lt; &#39;\\n&#39;; // outputs to content of x that is 5. std::cout &lt;&lt; y &lt;&lt; &#39;\\n&#39;; // outputs the memory address of x. std::cout &lt;&lt; &amp;x &lt;&lt; &#39;\\n&#39;; // outputs the memory address of x. } Pointers are great for making use of indirections that manipulate the contents within a certain block of memory. Let us modify the above code to demonstrate a series of indirection as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; int main(){ int x = 10; int *y = &amp;x; int *z = y; // takes the address of y i.e. &amp;x. *z = 6; // changes the content of &amp;x. std::cout &lt;&lt; x &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &amp;x &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; y &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; z &lt;&lt; &#39;\\n&#39;; } We can extend this by nesting them together: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; int main(){ int x = 10; int *y = &amp;x; int **z = &amp;y; // declares a double pointer that is pointed to the address of y. **z = 6; // dereferencing of a double pointer to change the content of x. std::cout &lt;&lt; x &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &amp;x &lt;&lt; &#39;\\n&#39;; // outputs the address of x. std::cout &lt;&lt; &amp;y &lt;&lt; &#39;\\n&#39;; // outputs the address of y. std::cout &lt;&lt; z &lt;&lt; &#39;\\n&#39;; // outputs the address of y. } As we notice, the address of pointers is not the same as the address of its reference. This observation is because pointers have their own identity. Consequently, pointers can be reassigned to another variable more so they can tolerate null values: NULL and nullptr (prefer using nullptr if you are using pointers). That is, int *x = nullptr is valid and will compile. More so, pointers can iterate over arrays with pre- and post-increment operators, pre- and post-decrement operators, and subscript operators. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; void iterate(int* a_ptr, size_t a_size){ for(size_t i = 0; i &lt; a_size; ++i){ std::cout &lt;&lt; a_ptr[i] &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\\n&#39; &lt;&lt; *(++a_ptr); // 2 std::cout &lt;&lt; &#39;\\n&#39; &lt;&lt; *(--a_ptr); // 1 std::cout &lt;&lt; &#39;\\n&#39; &lt;&lt; *(a_ptr++); // 1 std::cout &lt;&lt; &#39;\\n&#39; &lt;&lt; *(a_ptr--); // 2 } int main(){ int array[5]{1,2,3,4,5}; int *ptr_arr = array; iterate(ptr_arr, 5); } As mentioned, pointers can be used for allocating values on the heap as well as writing in that location. Let’s consider allocating memory for an array block with size 3: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;iostream&gt; void output(int* a_ptr, size_t a_size){ std::cout &lt;&lt; &#39;\\n&#39;; for(size_t i = 0; i &lt; a_size; ++i) std::cout &lt;&lt; a_ptr[i] &lt;&lt; &quot; &quot;; } int main(){ int *array = new int[3]; // printing uninitialized array output(array, 3); // writing values on array block for(size_t i = 0; i &lt; 3; ++i) array[i] = i+1; output(array, 3); // deallocates the memory delete [] array; } Reminders for using Pointers Pointers can be difficult to manage as they can be nested and combined without restrictions, this can result in a complicated piece of code that is hard to maintain. Pointers may leak resources if not properly managed: ensure clean-ups when pointer types are no longer needed remember to deallocate resources allocated on the heap when they are no longer relevant to your code. Prefer using smart pointers: std::unique_ptr&lt;T&gt; u_ptr, std::shared_ptr&lt;T&gt; s_ptr, and std::weak_ptr&lt;T&gt; w_ptr over raw pointers when performance is secondary to safety or finer grain of control are unnecessary. Smart pointers allow you to automate clean-up through RAII with a minimal performance cost, in the case of u_ptr there is zero performance overhead. For pointer objects ptr_obj or user-defined types, members can be accessed through arrow operator e.g. ptr_obj-&gt; function(). References References make things more convenient to express, it provides the necessary set of constraints for expressing ownership semantics – a topic that is beyond our concern, for now. C++ follows the design principle that solutions that adhere to the standards should be easier than the alternatives. Now that we know about pointers, how do we contrast this with references? References can be thought of as a constant pointer T const* c_ptr = &amp;obj and should not be confused with const T* ref = &amp;obj: The former allows the contents of the object to be modified but restricts the address to refer to obj, the latter reverses the effect and only restricts the obj to be modified. 1 2 3 int x = 5, y = 6; int *const ptr = &amp;x; ptr = &amp;y; // error To modify the content of x and set it to y we say: 1 2 3 int x = 5, y = 6; int *const ptr = &amp;x; *ptr = y; The same effect is achieved with references. As a result, references bind to the location of the entity in memory. It allows the contents of an entity to be modified, but it cannot be reassigned and must be bound at initialization. Therefore, the reference of an entity assumes the entity of the original variable. As mentioned, references can also allocate memory for a single entity on the heap. 1 2 3 4 int &amp;ref = *(new int(0)); std::cout &lt;&lt; ref &lt;&lt;&#39;\\n&#39;; ref = 3; std::cout &lt;&lt; ref; Reminders for using References References cannot be assigned to nullptr. References cannot iterate over arrays. Returning references over local variables may cause undefined behavior (dangling references). References must be bound to an existing entity. References only allow for one level of indirection. References express the intention clearly and concisely. Since C++11 standards, references have been used more often as the elements for move semantics are built from the notion of references (lvalue and rvalue references). Summary Are pointers and references the same thing? No. Are there any techniques that pointers can only do and vice-versa? Pointers are more flexible than references which can make your code complicated if not managed well. T const* ref achieves the same behavior of references, except for array referencing which gives us more reason for choosing references over pointers (when appropriate) as its semantics restrict iterating over array-like structures: 1 2 int const *r = &amp;*(new int[3]{1,3,4}); std::cout &lt;&lt; r[2] &lt;&lt;&#39;\\n&#39;; Whereas array indexing with references will result to compiler error: 1 2 int &amp;r = *(new int[3]{1,3,4}; std::cout &lt;&lt; r[2] &lt;&lt;&#39;\\n&#39;; When do we favor pointers over references and vice-versa? Pointer types are generally useful for setting up a separate field of indirection capable of modifying the contents of multiple variables of the same type. Having the same pointer accessing multiple variables may be difficult to trace and reason with. It is preferred to maintain clarity over the convenience of typing one pointer to all variables of the same type. For this reason, making use of references is safer. Pointers are not really terrible, in fact, they are one of the greatest features we unlock in languages like C/C++, however, their power comes with a cost. In conclusion, references are not just syntax sugar to cast T const*, it has its own design goals and purpose namely containing the address of declared entities. This improves the clarity of our intent, and in these situations, the C++ compiler is our friend.","headline":"Pointers and References: Design Goals and Use Cases","mainEntityOfPage":{"@type":"WebPage","@id":"https://adeeconometrics.github.io//posts/Pointers-and-References-Design-Goals-and-Use-Cases/"},"url":"https://adeeconometrics.github.io//posts/Pointers-and-References-Design-Goals-and-Use-Cases/"}</script><title>Pointers and References: Design Goals and Use Cases | Dave Amiana</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dave Amiana"><meta name="application-name" content="Dave Amiana"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0M61FBNQ0K"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0M61FBNQ0K'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/profile-picture.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dave Amiana</a></div><div class="site-subtitle font-italic">Open-source and Enterprise Software Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/adeeconometrics" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/dave-amiana/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['amiana.dave','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Pointers and References: Design Goals and Use Cases</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Pointers and References: Design Goals and Use Cases</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Dave Amiana </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Aug 12, 2021, 12:00 AM +0800" prep="on" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 22, 2022, 10:11 PM +0800" prefix="Updated " > Oct 22, 2022 <i class="unloaded">2022-10-22T22:11:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1467 words">8 min</span></div></div><div class="post-content"><p>At first, it seems that C++ makes things more complicated by introducing yet another layer of abstraction. References seem to encapsulate the same set of functionalities as pointers. Both of these constructs are used to <em>refer</em> to another entity as they provide access points into manipulating the contents of the <em>referent</em> entity; they are both allocated on the heap.</p><p>With this, we are faced with the following questions:</p><ol><li>Are pointers and references the same thing?<li>Are there any techniques that pointers can only do and vice-versa?<li>When do we favor pointers over references and vice-versa?</ol><p>By the end of this article, I hope to disentangle these two concepts and aim to give a reason why references deserve their own right for building more robust higher-order concepts.</p><hr /><h2 id="pointers">Pointers</h2><p>Pointers are introduced in C. Pointers store the memory address of an entity of type <code class="language-plaintext highlighter-rouge">T</code> (where <code class="language-plaintext highlighter-rouge">T</code> is a template parameter that can be resolved to <em>any</em> types), as mentioned, it provides an access point for changing the values of the entity it points to. Consider the following snippet:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">x</span>  <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// sets the content of x to 10.</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// sets the pointer to the address of x</span>
    <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// changes the content of &amp;x to 5.</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span>  <span class="n">x</span>  <span class="o">&lt;&lt;</span>  <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// outputs to content of x that is 5.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// outputs the memory address of x.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// outputs the memory address of x.</span>
<span class="p">}</span>

</pre></table></code></div></div><p>Pointers are great for making use of indirections that manipulate the contents within a certain block of memory. Let us modify the above code to demonstrate a series of indirection as follows:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// takes the address of y i.e. &amp;x.</span>
    <span class="o">*</span><span class="n">z</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>  <span class="c1">// changes the content of &amp;x.</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We can extend this by nesting them together:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">**</span><span class="n">z</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span> <span class="c1">// declares a double pointer that is pointed to the address of y.</span>
    <span class="o">**</span><span class="n">z</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// dereferencing of a double pointer to change the content of x.</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// outputs the address of x.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// outputs the address of y.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// outputs the address of y.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As we notice, the address of pointers is not the same as the address of its reference. This observation is because pointers have their own identity. Consequently, pointers can be reassigned to another variable more so they can tolerate null values: <code class="language-plaintext highlighter-rouge">NULL</code> and <code class="language-plaintext highlighter-rouge">nullptr</code> (prefer using <code class="language-plaintext highlighter-rouge">nullptr</code> if you are <a href="https://www.ibm.com/docs/en/i/7.3?topic=pointers-null">using pointers</a>). That is, <code class="language-plaintext highlighter-rouge">int *x = nullptr</code> is valid and will compile.</p><p>More so, pointers can iterate over arrays with pre- and post-increment operators, pre- and post-decrement operators, and subscript operators.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">iterate</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a_ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">a_size</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="o">++</span><span class="n">a_ptr</span><span class="p">);</span> <span class="c1">// 2</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">a_ptr</span><span class="p">);</span> <span class="c1">// 1</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">a_ptr</span><span class="o">++</span><span class="p">);</span> <span class="c1">// 1</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">a_ptr</span><span class="o">--</span><span class="p">);</span> <span class="c1">// 2</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr_arr</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span>
    <span class="n">iterate</span><span class="p">(</span><span class="n">ptr_arr</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>

</pre></table></code></div></div><p>As mentioned, pointers can be used for allocating values on the heap as well as writing in that location. Let’s consider allocating memory for an array block with size <code class="language-plaintext highlighter-rouge">3</code>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">output</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a_ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">a_size</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="c1">// printing uninitialized array</span>
    <span class="n">output</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="c1">// writing values on array block</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">output</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

    <span class="c1">// deallocates the memory</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">array</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h3 id="reminders-for-using-pointers">Reminders for using Pointers</h3><ul><li>Pointers can be difficult to manage as they can be nested and combined without restrictions, this can result in a complicated piece of code that is hard to maintain.<li>Pointers may leak resources if not properly managed:<ul><li>ensure clean-ups when pointer types are no longer needed<li>remember to deallocate resources allocated on the heap when they are no longer relevant to your code.</ul><li>Prefer using smart pointers: <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;T&gt; u_ptr</code>, <code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;T&gt; s_ptr</code>, and <code class="language-plaintext highlighter-rouge">std::weak_ptr&lt;T&gt; w_ptr</code> over raw pointers when performance is secondary to safety or finer grain of control are unnecessary. Smart pointers allow you to automate clean-up through <a href="https://bityl.co/8BOl">RAII</a> with a minimal performance cost, in the case of <code class="language-plaintext highlighter-rouge">u_ptr</code> there is zero performance overhead.<li>For pointer objects <code class="language-plaintext highlighter-rouge">ptr_obj</code> or user-defined types, members can be accessed through arrow operator e.g. <code class="language-plaintext highlighter-rouge">ptr_obj-&gt; function()</code>.</ul><h2 id="references">References</h2><p>References make things more convenient to express, it provides the necessary set of constraints for expressing <em>ownership semantics</em> – a topic that is beyond our concern, for now. C++ follows the design principle that solutions that adhere to the standards should be easier than the alternatives.</p><p><strong>Now that we know about pointers, how do we contrast this with references?</strong></p><p>References can be thought of as a <a href="https://bityl.co/8BUS">constant pointer</a> <code class="language-plaintext highlighter-rouge">T const* c_ptr = &amp;obj</code> and should not be confused with <code class="language-plaintext highlighter-rouge">const T* ref = &amp;obj</code>: The former allows the contents of the object to be modified but restricts the address to refer to <code class="language-plaintext highlighter-rouge">obj</code>, the latter reverses the effect and only restricts the <code class="language-plaintext highlighter-rouge">obj</code> to be modified.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span> <span class="c1">// error</span>
</pre></table></code></div></div><p>To modify the content of <code class="language-plaintext highlighter-rouge">x</code> and set it to <code class="language-plaintext highlighter-rouge">y</code> we say:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
</pre></table></code></div></div><p>The same effect is achieved with references. As a result, references bind to the location of the entity in memory. It allows the contents of an entity to be modified, but it <em>cannot</em> be reassigned and must be bound at initialization. Therefore, the reference of an entity assumes the entity of the original variable.</p><p>As mentioned, references can also allocate memory for a single entity on the heap.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>    <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ref</span> <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ref</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="reminders-for-using-references">Reminders for using References</h3><ul><li>References cannot be assigned to <code class="language-plaintext highlighter-rouge">nullptr</code>.<li>References cannot iterate over arrays.<li>Returning references over local variables may cause undefined behavior (dangling references).<li>References must be bound to an existing entity.<li>References only allow for one level of indirection.<li>References express the intention clearly and concisely.<li>Since C++11 standards, references have been used more often as the elements for move semantics are <a href="https://en.cppreference.com/w/cpp/language/move_constructor">built from the notion of references</a> (<code class="language-plaintext highlighter-rouge">lvalue</code> and <code class="language-plaintext highlighter-rouge">rvalue</code> references).</ul><hr /><h2 id="summary">Summary</h2><ul><li><strong>Are pointers and references the same thing?</strong> No.<li><strong>Are there any techniques that pointers can only do and vice-versa?</strong> Pointers are more flexible than references which can make your code complicated if not managed well. <code class="language-plaintext highlighter-rouge">T const* ref</code> achieves the same behavior of references, except for array referencing which gives us more reason for choosing references over pointers (when appropriate) as its semantics restrict iterating over array-like structures:</ul><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
</pre></table></code></div></div><p>Whereas array indexing with references will result to compiler error:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>    <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
</pre></table></code></div></div><ul><li><strong>When do we favor pointers over references and vice-versa?</strong> Pointer types are generally useful for setting up a separate field of indirection capable of modifying the contents of multiple variables of the same type. Having the same pointer accessing multiple variables may be difficult to trace and reason with. It is preferred to maintain clarity over the convenience of typing one pointer to all variables of the same type. For this reason, making use of references is safer.</ul><p>Pointers are not really terrible, in fact, they are one of the greatest features we unlock in languages like C/C++, however, their power comes with a cost.</p><p>In conclusion, references are not just syntax sugar to cast <code class="language-plaintext highlighter-rouge">T const*</code>, it has its own design goals and purpose namely containing the address of declared entities. This improves the clarity of our intent, and in these situations, the C++ compiler is our friend.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a>, <a href='/categories/computer-science/'>Computer Science</a>, <a href='/categories/c/'>C++</a>, <a href='/categories/ownership-semantics/'>Ownership Semantics</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/programming/" class="post-tag no-text-decoration" >programming</a> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/ownership-semantics/" class="post-tag no-text-decoration" >Ownership Semantics</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Pointers and References: Design Goals and Use Cases - Dave Amiana&url=https://adeeconometrics.github.io//posts/Pointers-and-References-Design-Goals-and-Use-Cases/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Pointers and References: Design Goals and Use Cases - Dave Amiana&u=https://adeeconometrics.github.io//posts/Pointers-and-References-Design-Goals-and-Use-Cases/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Pointers and References: Design Goals and Use Cases - Dave Amiana&url=https://adeeconometrics.github.io//posts/Pointers-and-References-Design-Goals-and-Use-Cases/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/On-Pointer-Types/">On Pointer Types</a><li><a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/">Pointers and References: Design Goals and Use Cases</a><li><a href="/posts/Unique-Reference/">Unique References</a><li><a href="/posts/Shared-Reference/">Shared References</a><li><a href="/posts/Weak-Reference/">Weak References</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/On-Pointer-Types/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>On Pointer Types</h3><div class="text-muted small"><p> In this article, I aim to introduce the concept and motivation behind using pointers. There are breeds of C++ developers that only use smart pointers for safety reasons, others that only use raw po...</p></div></div></a></div><div class="card"> <a href="/posts/Unique-Reference/"><div class="card-body"> <span class="timeago small" > Aug 17, 2021 <i class="unloaded">2021-08-17T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Unique References</h3><div class="text-muted small"><p> Our previous discussion explores the anatomy of pointer types in C and C++ on par with hinting nuances of reference semantics. We discussed the use cases of raw pointers and smart pointers in moder...</p></div></div></a></div><div class="card"> <a href="/posts/Shared-Reference/"><div class="card-body"> <span class="timeago small" > Aug 20, 2021 <i class="unloaded">2021-08-20T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Shared References</h3><div class="text-muted small"><p> In our previous discussion, we fleshed out the design requirements and took action into servicing them. In the same way, this article aims to flesh out the design requirement for shared reference. ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/On-Pointer-Types/" class="btn btn-outline-primary" prompt="Older"><p>On Pointer Types</p></a> <a href="/posts/Unique-Reference/" class="btn btn-outline-primary" prompt="Newer"><p>Unique References</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/iamdeb25">Dave Amiana</a>.</p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://adeeconometrics.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
