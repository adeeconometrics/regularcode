<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Weak References" /><meta name="author" content="Dave Amiana" /><meta property="og:locale" content="en_US" /><meta name="description" content="In our last discussion, we talked about the semantics of sharing. We fleshed out the design goals of shared reference and met the minimum design requirements. Similarly, we do the same with our implementation of weak references. If you followed along with the series, we now know that weak references solve the problem of reference cycles; that is, without weak references, shared reference may be misused, resulting in reference cycles, which results in suppressing resource clean-up. Once again, let us demonstrate the problem of reference cycles with our shared_reference&lt;T&gt; class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &quot;shared_reference.h&quot; #include &lt;iostream&gt; struct B; struct A{ shared_reference&lt;B&gt; ab; A(){ std::cout &lt;&lt; &quot;Resources of A are acquired. \n&quot;; } ~A(){ std::cout &lt;&lt; &quot;Resources of A are cleaned up. \n&quot;; } }; struct B{ shared_reference&lt;A&gt; ba; B(){ std::cout &lt;&lt; &quot;Resources of B are acquired. \n&quot;; } ~B(){ std::cout &lt;&lt; &quot;Resources of B are cleaned up. \n&quot;; } }; int main(){ shared_reference&lt;A&gt; sa (new A()); shared_reference&lt;B&gt; sb (new B()); sa-&gt;ab=sb; sb-&gt;ba=sa; } If we compile the above code on the IDE provided below, we encounter the following output. Resources of A are acquired. Resources of B are acquired. It never released our resources at the time our objects went out of scope. This problem should be solved with a weak reference type. Design goals Our weak reference class is an extension of shared reference as it can access and modify the contents of our shared reference without imposing its presence on the shared_reference interface. Consequently, we have must satisfy the following requirements: Must initialize only shared_reference&lt;T&gt; type Must not take ownership of shared_reference&lt;T&gt; type Pointer-like interface Must provide a function of counting references Implementation Now that we defined our goals, let us work on them! Requirement: Must initialize only shared_reference&lt;T&gt; type I found this a little bit tricky to implement. We will find out why it is tricky when we implement a non-owning mechanism. But for now, let us try to partially fulfill our first requirement. 1 2 3 4 template&lt;typename T&gt; class weak_reference: public shared_reference&lt;T&gt;{ public: explicit weak_reference(shared_reference&lt;T&gt;&amp; i_ptr); }; This may seem what we meant by an extension of shared reference. And by the looks of it, it may be a plausible assumption until we ran into the problem of calling destructors. Let us discuss the subtle design flaws on this matter in our attempt to suffice the second requirement. Requirement: Must not take ownership of shared_reference&lt;T&gt; type Before we proceed into anything, let us be clear by what we mean by taking ownership? In the context of shared reference, all entities share ownership with the resource it has; that is, for each time a shared_reference instance goes out of scope, it determines the state on whether calling the resource clean-up would be appropriate. Now, our weak reference should not take ownership of shared_reference’s resource. We only need to be able to access and modify its content. In doing so, we need to communicate with the shared_reference class. To establish communication between classes, we have to make dependencies. That is why our attempts jump back and forth with our shared_reference class. Let us consider our first attempt at establishing dependency with inheritance and discover its design flaws. Consider an adjacent example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class SuperType{ public: SuperType() { std::cout &lt;&lt; &quot;SuperType resources are acquired. \n&quot;; } virtual ~SuperType() { std::cout &lt;&lt; &quot;SuperType resources are released. \n&quot;; } }; class Subtype: public SuperType{ public: Subtype() { std::cout &lt;&lt; &quot;Subtype resources are acquired. &quot; &lt;&lt; &#39;\n&#39;; } ~Subtype() { std::cout &lt;&lt; &quot;Subtype resources are released. &quot; &lt;&lt; &#39;\n&#39;; } }; int main() { Subtype s; } At the time s goes out of scope, it outputs the following: SuperType resources are acquired. Subtype resources are acquired. Subtype resources are released. SuperType resources are released. In the above example, we inevitably call the superclass destructor. And we must call its destructor if we want to establish dependency through inheritance, but what does it mean when we decided to extend share reference to weak reference by means for the inheritance? You guessed it! We alter the state of our reference counter and possibly preemptively release our resources because of it. 1 2 3 4 5 shared_reference&lt;A&gt; sh_ref(new A()); { weak_referene&lt;A&gt; wk_ref(sh_ref); } // since it calls superclass destructor the clean-up happens here Let us step back and consider another attempt of establishing dependency. Recall that our concern is to get access to shared_reference’s private members. For this case, we can use a friend to access shared_reference’s private members without inheriting them. We declare a friend class inside our shared_reference as follows: 1 2 3 4 5 6 7 8 9 10 #include &quot;weak_reference.h&quot; template&lt;typename T&gt; class shared_reference{ template &lt;typename&gt; friend class weak_reference; static size_t m_counter; T* m_ptr; . . . }; Then we write a special constructor that accepts shared_reference and an internal representation of that reference inside our weak_reference class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # include &quot;shared_reference.h&quot; template &lt;typename T&gt; class weak_reference{ T *m_ptr{nullptr}; shared_reference&lt;T&gt; handle; public: explicit weak_reference(shared_reference&lt;T&gt;&amp; i_ptr) : m_ptr(i_ptr.get()), handle(i_ptr) {} weak_reference() = default; . . . }; Recall that for each time we call the reference constructor, we call the copy() function that increments the state of our reference counter. Since we do not want to alter the state of our reference counter, we have to counteract the consequences of calling the reference constructor. Inside our shared reference class, we declare a private function that is responsible for suppressing unintended incrementation by calling the reference constructor. 1 2 3 private: void suppress_increment(void) noexcept {m_counter -= 1; } void suppress_decrement(void) noexcept {m_coutner += 1; } Since for each time, shared_reference destructor gets called we decrement our reference counter until it is set for clean-up, we need to make sure this will not happen in the context of weak_reference. So we write another private function for suppressing unintended decrementation. In effect, our weak reference will not alter the state of the reference counter and we have got ourselves a representation of shared_reference which we shall exploit later. Requirement: Pointer-like interface We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer. Recall that a pointer can be dereferenced with * and -&gt; operators. And we need &amp; operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write: 1 2 3 T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(weak_reference&lt;T&gt; &amp;other) { return other.m_ptr; } Let us walk through the three lines. The first line returns a reference of *(this-&gt;m_ptr) which means that the content of m_ptr is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to m_ptr’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. Recall that a pointer has its own location in memory separate from the entities it points to. Let’s go beyond our requirement list and add little features that return the current count of our references and their contents. We call these functions count(), is_expired(), and release(). The implementation is equally trivial. Requirement: Must provide a function of counting references Since we have an internal representation of shared reference, we can inspect the state of its reference counter and check if our resources have been released. Additionally, we may want our weak reference to release its handle on shared reference resources. These functionalities are handled by the following public functions: 1 2 3 int count(void){ return handle.count(); } void release(void) noexcept { m_ptr = nullptr; } bool is_expired(void) noexcept { return m_ptr == nullptr; } Putting it all together 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # pragma once # include &quot;shared_reference.h&quot; template &lt;typename T&gt; class weak_reference{ T *m_ptr{nullptr}; shared_reference&lt;T&gt; handle; public: explicit weak_reference(shared_reference&lt;T&gt;&amp; i_ptr) : m_ptr(i_ptr.get()), handle(i_ptr) {i_ptr.suppress_increment();} weak_reference() = delete; weak_reference(const weak_reference&lt;T&gt; &amp;) = delete; weak_reference(weak_reference&lt;T&gt; &amp;&amp;) = delete; ~weak_reference() { m_ptr = nullptr; handle.suppress_decrement(); } weak_reference &amp;operator=(weak_reference&lt;T&gt; &amp;&amp;) = delete; weak_reference &amp;operator=(const weak_reference&lt;T&gt; &amp;Type) = delete; T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(weak_reference&lt;T&gt; &amp;other) { return other.m_ptr; } T *get(void) { return (this-&gt;m_ptr); } int count(void){return handle.count();} void release(void) noexcept { m_ptr = nullptr; } bool is_expired(void) noexcept { return m_ptr == nullptr; } }; Test cases Time to see if we satisfied our design requirements: In the executable program above, we noticed that weak references solve the reference cycle problem. Summary We fleshed out our design requirements and implemented our version of the weak reference to satisfy what we intend to do with it. We extended the capability of shared reference by extending its features with weak reference whereby we successfully solved the reference cycle problem. Here ends the ownership semantics series! I hope you carry along with you the new things we learned regarding resource management. As always, have fun hacking! References Wikipedia contributors. (2021, July 29). Reference counting. In Wikipedia, The Free Encyclopedia. Retrieved 08:48, August 25, 2021, from https://en.wikipedia.org/w/index.php?title=Reference_counting&amp;oldid=1036113247 Amiana, D. (2021). Implementing Building Blocks of Reference Semantics: Shared Reference. https://dcode.hashnode.dev/implementing-building-blocks-of-reference-semantics-shared-reference cppreference.com (2021). Friend. https://en.cppreference.com/w/cpp/language/friend." /><meta property="og:description" content="In our last discussion, we talked about the semantics of sharing. We fleshed out the design goals of shared reference and met the minimum design requirements. Similarly, we do the same with our implementation of weak references. If you followed along with the series, we now know that weak references solve the problem of reference cycles; that is, without weak references, shared reference may be misused, resulting in reference cycles, which results in suppressing resource clean-up. Once again, let us demonstrate the problem of reference cycles with our shared_reference&lt;T&gt; class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &quot;shared_reference.h&quot; #include &lt;iostream&gt; struct B; struct A{ shared_reference&lt;B&gt; ab; A(){ std::cout &lt;&lt; &quot;Resources of A are acquired. \n&quot;; } ~A(){ std::cout &lt;&lt; &quot;Resources of A are cleaned up. \n&quot;; } }; struct B{ shared_reference&lt;A&gt; ba; B(){ std::cout &lt;&lt; &quot;Resources of B are acquired. \n&quot;; } ~B(){ std::cout &lt;&lt; &quot;Resources of B are cleaned up. \n&quot;; } }; int main(){ shared_reference&lt;A&gt; sa (new A()); shared_reference&lt;B&gt; sb (new B()); sa-&gt;ab=sb; sb-&gt;ba=sa; } If we compile the above code on the IDE provided below, we encounter the following output. Resources of A are acquired. Resources of B are acquired. It never released our resources at the time our objects went out of scope. This problem should be solved with a weak reference type. Design goals Our weak reference class is an extension of shared reference as it can access and modify the contents of our shared reference without imposing its presence on the shared_reference interface. Consequently, we have must satisfy the following requirements: Must initialize only shared_reference&lt;T&gt; type Must not take ownership of shared_reference&lt;T&gt; type Pointer-like interface Must provide a function of counting references Implementation Now that we defined our goals, let us work on them! Requirement: Must initialize only shared_reference&lt;T&gt; type I found this a little bit tricky to implement. We will find out why it is tricky when we implement a non-owning mechanism. But for now, let us try to partially fulfill our first requirement. 1 2 3 4 template&lt;typename T&gt; class weak_reference: public shared_reference&lt;T&gt;{ public: explicit weak_reference(shared_reference&lt;T&gt;&amp; i_ptr); }; This may seem what we meant by an extension of shared reference. And by the looks of it, it may be a plausible assumption until we ran into the problem of calling destructors. Let us discuss the subtle design flaws on this matter in our attempt to suffice the second requirement. Requirement: Must not take ownership of shared_reference&lt;T&gt; type Before we proceed into anything, let us be clear by what we mean by taking ownership? In the context of shared reference, all entities share ownership with the resource it has; that is, for each time a shared_reference instance goes out of scope, it determines the state on whether calling the resource clean-up would be appropriate. Now, our weak reference should not take ownership of shared_reference’s resource. We only need to be able to access and modify its content. In doing so, we need to communicate with the shared_reference class. To establish communication between classes, we have to make dependencies. That is why our attempts jump back and forth with our shared_reference class. Let us consider our first attempt at establishing dependency with inheritance and discover its design flaws. Consider an adjacent example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class SuperType{ public: SuperType() { std::cout &lt;&lt; &quot;SuperType resources are acquired. \n&quot;; } virtual ~SuperType() { std::cout &lt;&lt; &quot;SuperType resources are released. \n&quot;; } }; class Subtype: public SuperType{ public: Subtype() { std::cout &lt;&lt; &quot;Subtype resources are acquired. &quot; &lt;&lt; &#39;\n&#39;; } ~Subtype() { std::cout &lt;&lt; &quot;Subtype resources are released. &quot; &lt;&lt; &#39;\n&#39;; } }; int main() { Subtype s; } At the time s goes out of scope, it outputs the following: SuperType resources are acquired. Subtype resources are acquired. Subtype resources are released. SuperType resources are released. In the above example, we inevitably call the superclass destructor. And we must call its destructor if we want to establish dependency through inheritance, but what does it mean when we decided to extend share reference to weak reference by means for the inheritance? You guessed it! We alter the state of our reference counter and possibly preemptively release our resources because of it. 1 2 3 4 5 shared_reference&lt;A&gt; sh_ref(new A()); { weak_referene&lt;A&gt; wk_ref(sh_ref); } // since it calls superclass destructor the clean-up happens here Let us step back and consider another attempt of establishing dependency. Recall that our concern is to get access to shared_reference’s private members. For this case, we can use a friend to access shared_reference’s private members without inheriting them. We declare a friend class inside our shared_reference as follows: 1 2 3 4 5 6 7 8 9 10 #include &quot;weak_reference.h&quot; template&lt;typename T&gt; class shared_reference{ template &lt;typename&gt; friend class weak_reference; static size_t m_counter; T* m_ptr; . . . }; Then we write a special constructor that accepts shared_reference and an internal representation of that reference inside our weak_reference class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # include &quot;shared_reference.h&quot; template &lt;typename T&gt; class weak_reference{ T *m_ptr{nullptr}; shared_reference&lt;T&gt; handle; public: explicit weak_reference(shared_reference&lt;T&gt;&amp; i_ptr) : m_ptr(i_ptr.get()), handle(i_ptr) {} weak_reference() = default; . . . }; Recall that for each time we call the reference constructor, we call the copy() function that increments the state of our reference counter. Since we do not want to alter the state of our reference counter, we have to counteract the consequences of calling the reference constructor. Inside our shared reference class, we declare a private function that is responsible for suppressing unintended incrementation by calling the reference constructor. 1 2 3 private: void suppress_increment(void) noexcept {m_counter -= 1; } void suppress_decrement(void) noexcept {m_coutner += 1; } Since for each time, shared_reference destructor gets called we decrement our reference counter until it is set for clean-up, we need to make sure this will not happen in the context of weak_reference. So we write another private function for suppressing unintended decrementation. In effect, our weak reference will not alter the state of the reference counter and we have got ourselves a representation of shared_reference which we shall exploit later. Requirement: Pointer-like interface We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer. Recall that a pointer can be dereferenced with * and -&gt; operators. And we need &amp; operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write: 1 2 3 T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(weak_reference&lt;T&gt; &amp;other) { return other.m_ptr; } Let us walk through the three lines. The first line returns a reference of *(this-&gt;m_ptr) which means that the content of m_ptr is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to m_ptr’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. Recall that a pointer has its own location in memory separate from the entities it points to. Let’s go beyond our requirement list and add little features that return the current count of our references and their contents. We call these functions count(), is_expired(), and release(). The implementation is equally trivial. Requirement: Must provide a function of counting references Since we have an internal representation of shared reference, we can inspect the state of its reference counter and check if our resources have been released. Additionally, we may want our weak reference to release its handle on shared reference resources. These functionalities are handled by the following public functions: 1 2 3 int count(void){ return handle.count(); } void release(void) noexcept { m_ptr = nullptr; } bool is_expired(void) noexcept { return m_ptr == nullptr; } Putting it all together 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # pragma once # include &quot;shared_reference.h&quot; template &lt;typename T&gt; class weak_reference{ T *m_ptr{nullptr}; shared_reference&lt;T&gt; handle; public: explicit weak_reference(shared_reference&lt;T&gt;&amp; i_ptr) : m_ptr(i_ptr.get()), handle(i_ptr) {i_ptr.suppress_increment();} weak_reference() = delete; weak_reference(const weak_reference&lt;T&gt; &amp;) = delete; weak_reference(weak_reference&lt;T&gt; &amp;&amp;) = delete; ~weak_reference() { m_ptr = nullptr; handle.suppress_decrement(); } weak_reference &amp;operator=(weak_reference&lt;T&gt; &amp;&amp;) = delete; weak_reference &amp;operator=(const weak_reference&lt;T&gt; &amp;Type) = delete; T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(weak_reference&lt;T&gt; &amp;other) { return other.m_ptr; } T *get(void) { return (this-&gt;m_ptr); } int count(void){return handle.count();} void release(void) noexcept { m_ptr = nullptr; } bool is_expired(void) noexcept { return m_ptr == nullptr; } }; Test cases Time to see if we satisfied our design requirements: In the executable program above, we noticed that weak references solve the reference cycle problem. Summary We fleshed out our design requirements and implemented our version of the weak reference to satisfy what we intend to do with it. We extended the capability of shared reference by extending its features with weak reference whereby we successfully solved the reference cycle problem. Here ends the ownership semantics series! I hope you carry along with you the new things we learned regarding resource management. As always, have fun hacking! References Wikipedia contributors. (2021, July 29). Reference counting. In Wikipedia, The Free Encyclopedia. Retrieved 08:48, August 25, 2021, from https://en.wikipedia.org/w/index.php?title=Reference_counting&amp;oldid=1036113247 Amiana, D. (2021). Implementing Building Blocks of Reference Semantics: Shared Reference. https://dcode.hashnode.dev/implementing-building-blocks-of-reference-semantics-shared-reference cppreference.com (2021). Friend. https://en.cppreference.com/w/cpp/language/friend." /><link rel="canonical" href="https://adeeconometrics.github.io//posts/Weak-Reference/" /><meta property="og:url" content="https://adeeconometrics.github.io//posts/Weak-Reference/" /><meta property="og:site_name" content="Dave Amiana" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-25T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Weak References" /><meta name="twitter:site" content="@iamdeb25" /><meta name="twitter:creator" content="@Dave Amiana" /><meta name="google-site-verification" content="google-site-verification=28bVbRErS2VwJaonXuu3GbqmRlyNvizt6I00B2kQh88" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Dave Amiana"},"dateModified":"2022-10-22T22:11:50+08:00","datePublished":"2021-08-25T00:00:00+08:00","description":"In our last discussion, we talked about the semantics of sharing. We fleshed out the design goals of shared reference and met the minimum design requirements. Similarly, we do the same with our implementation of weak references. If you followed along with the series, we now know that weak references solve the problem of reference cycles; that is, without weak references, shared reference may be misused, resulting in reference cycles, which results in suppressing resource clean-up. Once again, let us demonstrate the problem of reference cycles with our shared_reference&lt;T&gt; class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &quot;shared_reference.h&quot; #include &lt;iostream&gt; struct B; struct A{ shared_reference&lt;B&gt; ab; A(){ std::cout &lt;&lt; &quot;Resources of A are acquired. \\n&quot;; } ~A(){ std::cout &lt;&lt; &quot;Resources of A are cleaned up. \\n&quot;; } }; struct B{ shared_reference&lt;A&gt; ba; B(){ std::cout &lt;&lt; &quot;Resources of B are acquired. \\n&quot;; } ~B(){ std::cout &lt;&lt; &quot;Resources of B are cleaned up. \\n&quot;; } }; int main(){ shared_reference&lt;A&gt; sa (new A()); shared_reference&lt;B&gt; sb (new B()); sa-&gt;ab=sb; sb-&gt;ba=sa; } If we compile the above code on the IDE provided below, we encounter the following output. Resources of A are acquired. Resources of B are acquired. It never released our resources at the time our objects went out of scope. This problem should be solved with a weak reference type. Design goals Our weak reference class is an extension of shared reference as it can access and modify the contents of our shared reference without imposing its presence on the shared_reference interface. Consequently, we have must satisfy the following requirements: Must initialize only shared_reference&lt;T&gt; type Must not take ownership of shared_reference&lt;T&gt; type Pointer-like interface Must provide a function of counting references Implementation Now that we defined our goals, let us work on them! Requirement: Must initialize only shared_reference&lt;T&gt; type I found this a little bit tricky to implement. We will find out why it is tricky when we implement a non-owning mechanism. But for now, let us try to partially fulfill our first requirement. 1 2 3 4 template&lt;typename T&gt; class weak_reference: public shared_reference&lt;T&gt;{ public: explicit weak_reference(shared_reference&lt;T&gt;&amp; i_ptr); }; This may seem what we meant by an extension of shared reference. And by the looks of it, it may be a plausible assumption until we ran into the problem of calling destructors. Let us discuss the subtle design flaws on this matter in our attempt to suffice the second requirement. Requirement: Must not take ownership of shared_reference&lt;T&gt; type Before we proceed into anything, let us be clear by what we mean by taking ownership? In the context of shared reference, all entities share ownership with the resource it has; that is, for each time a shared_reference instance goes out of scope, it determines the state on whether calling the resource clean-up would be appropriate. Now, our weak reference should not take ownership of shared_reference’s resource. We only need to be able to access and modify its content. In doing so, we need to communicate with the shared_reference class. To establish communication between classes, we have to make dependencies. That is why our attempts jump back and forth with our shared_reference class. Let us consider our first attempt at establishing dependency with inheritance and discover its design flaws. Consider an adjacent example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class SuperType{ public: SuperType() { std::cout &lt;&lt; &quot;SuperType resources are acquired. \\n&quot;; } virtual ~SuperType() { std::cout &lt;&lt; &quot;SuperType resources are released. \\n&quot;; } }; class Subtype: public SuperType{ public: Subtype() { std::cout &lt;&lt; &quot;Subtype resources are acquired. &quot; &lt;&lt; &#39;\\n&#39;; } ~Subtype() { std::cout &lt;&lt; &quot;Subtype resources are released. &quot; &lt;&lt; &#39;\\n&#39;; } }; int main() { Subtype s; } At the time s goes out of scope, it outputs the following: SuperType resources are acquired. Subtype resources are acquired. Subtype resources are released. SuperType resources are released. In the above example, we inevitably call the superclass destructor. And we must call its destructor if we want to establish dependency through inheritance, but what does it mean when we decided to extend share reference to weak reference by means for the inheritance? You guessed it! We alter the state of our reference counter and possibly preemptively release our resources because of it. 1 2 3 4 5 shared_reference&lt;A&gt; sh_ref(new A()); { weak_referene&lt;A&gt; wk_ref(sh_ref); } // since it calls superclass destructor the clean-up happens here Let us step back and consider another attempt of establishing dependency. Recall that our concern is to get access to shared_reference’s private members. For this case, we can use a friend to access shared_reference’s private members without inheriting them. We declare a friend class inside our shared_reference as follows: 1 2 3 4 5 6 7 8 9 10 #include &quot;weak_reference.h&quot; template&lt;typename T&gt; class shared_reference{ template &lt;typename&gt; friend class weak_reference; static size_t m_counter; T* m_ptr; . . . }; Then we write a special constructor that accepts shared_reference and an internal representation of that reference inside our weak_reference class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # include &quot;shared_reference.h&quot; template &lt;typename T&gt; class weak_reference{ T *m_ptr{nullptr}; shared_reference&lt;T&gt; handle; public: explicit weak_reference(shared_reference&lt;T&gt;&amp; i_ptr) : m_ptr(i_ptr.get()), handle(i_ptr) {} weak_reference() = default; . . . }; Recall that for each time we call the reference constructor, we call the copy() function that increments the state of our reference counter. Since we do not want to alter the state of our reference counter, we have to counteract the consequences of calling the reference constructor. Inside our shared reference class, we declare a private function that is responsible for suppressing unintended incrementation by calling the reference constructor. 1 2 3 private: void suppress_increment(void) noexcept {m_counter -= 1; } void suppress_decrement(void) noexcept {m_coutner += 1; } Since for each time, shared_reference destructor gets called we decrement our reference counter until it is set for clean-up, we need to make sure this will not happen in the context of weak_reference. So we write another private function for suppressing unintended decrementation. In effect, our weak reference will not alter the state of the reference counter and we have got ourselves a representation of shared_reference which we shall exploit later. Requirement: Pointer-like interface We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer. Recall that a pointer can be dereferenced with * and -&gt; operators. And we need &amp; operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write: 1 2 3 T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(weak_reference&lt;T&gt; &amp;other) { return other.m_ptr; } Let us walk through the three lines. The first line returns a reference of *(this-&gt;m_ptr) which means that the content of m_ptr is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to m_ptr’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. Recall that a pointer has its own location in memory separate from the entities it points to. Let’s go beyond our requirement list and add little features that return the current count of our references and their contents. We call these functions count(), is_expired(), and release(). The implementation is equally trivial. Requirement: Must provide a function of counting references Since we have an internal representation of shared reference, we can inspect the state of its reference counter and check if our resources have been released. Additionally, we may want our weak reference to release its handle on shared reference resources. These functionalities are handled by the following public functions: 1 2 3 int count(void){ return handle.count(); } void release(void) noexcept { m_ptr = nullptr; } bool is_expired(void) noexcept { return m_ptr == nullptr; } Putting it all together 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # pragma once # include &quot;shared_reference.h&quot; template &lt;typename T&gt; class weak_reference{ T *m_ptr{nullptr}; shared_reference&lt;T&gt; handle; public: explicit weak_reference(shared_reference&lt;T&gt;&amp; i_ptr) : m_ptr(i_ptr.get()), handle(i_ptr) {i_ptr.suppress_increment();} weak_reference() = delete; weak_reference(const weak_reference&lt;T&gt; &amp;) = delete; weak_reference(weak_reference&lt;T&gt; &amp;&amp;) = delete; ~weak_reference() { m_ptr = nullptr; handle.suppress_decrement(); } weak_reference &amp;operator=(weak_reference&lt;T&gt; &amp;&amp;) = delete; weak_reference &amp;operator=(const weak_reference&lt;T&gt; &amp;Type) = delete; T &amp;operator*(void) { return *(this-&gt;m_ptr); } T *operator-&gt;(void) { return this-&gt;m_ptr; } T &amp;operator&amp;(weak_reference&lt;T&gt; &amp;other) { return other.m_ptr; } T *get(void) { return (this-&gt;m_ptr); } int count(void){return handle.count();} void release(void) noexcept { m_ptr = nullptr; } bool is_expired(void) noexcept { return m_ptr == nullptr; } }; Test cases Time to see if we satisfied our design requirements: In the executable program above, we noticed that weak references solve the reference cycle problem. Summary We fleshed out our design requirements and implemented our version of the weak reference to satisfy what we intend to do with it. We extended the capability of shared reference by extending its features with weak reference whereby we successfully solved the reference cycle problem. Here ends the ownership semantics series! I hope you carry along with you the new things we learned regarding resource management. As always, have fun hacking! References Wikipedia contributors. (2021, July 29). Reference counting. In Wikipedia, The Free Encyclopedia. Retrieved 08:48, August 25, 2021, from https://en.wikipedia.org/w/index.php?title=Reference_counting&amp;oldid=1036113247 Amiana, D. (2021). Implementing Building Blocks of Reference Semantics: Shared Reference. https://dcode.hashnode.dev/implementing-building-blocks-of-reference-semantics-shared-reference cppreference.com (2021). Friend. https://en.cppreference.com/w/cpp/language/friend.","headline":"Weak References","mainEntityOfPage":{"@type":"WebPage","@id":"https://adeeconometrics.github.io//posts/Weak-Reference/"},"url":"https://adeeconometrics.github.io//posts/Weak-Reference/"}</script><title>Weak References | Dave Amiana</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dave Amiana"><meta name="application-name" content="Dave Amiana"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0M61FBNQ0K"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0M61FBNQ0K'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/profile-picture.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dave Amiana</a></div><div class="site-subtitle font-italic">Open-source and Enterprise Software Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/adeeconometrics" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/dave-amiana/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['amiana.dave','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Weak References</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Weak References</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Dave Amiana </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Aug 25, 2021, 12:00 AM +0800" prep="on" > Aug 25, 2021 <i class="unloaded">2021-08-25T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 22, 2022, 10:11 PM +0800" prefix="Updated " > Oct 22, 2022 <i class="unloaded">2022-10-22T22:11:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1614 words">8 min</span></div></div><div class="post-content"><p>In our last discussion, we talked about the semantics of sharing. We fleshed out the design goals of shared reference and met the minimum design requirements. Similarly, we do the same with our implementation of weak references.</p><p>If you followed along with the series, we now know that weak references solve the problem of reference cycles; that is, without weak references, shared reference may be misused, resulting in <a href="https://en.wikipedia.org/wiki/Reference_counting">reference cycles</a>, which results in suppressing resource clean-up.</p><p>Once again, let us demonstrate the problem of reference cycles with our <code class="language-plaintext highlighter-rouge">shared_reference&lt;T&gt;</code> class.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"shared_reference.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">B</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
    <span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">ab</span><span class="p">;</span>
    <span class="n">A</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of A are acquired. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">A</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of A are cleaned up. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="nc">B</span><span class="p">{</span>
    <span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">ba</span><span class="p">;</span>
    <span class="n">B</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of B are acquired. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">B</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resources of B are cleaned up. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">sa</span> <span class="p">(</span><span class="k">new</span> <span class="n">A</span><span class="p">());</span>
    <span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">sb</span> <span class="p">(</span><span class="k">new</span> <span class="n">B</span><span class="p">());</span>

    <span class="n">sa</span><span class="o">-&gt;</span><span class="n">ab</span><span class="o">=</span><span class="n">sb</span><span class="p">;</span>
    <span class="n">sb</span><span class="o">-&gt;</span><span class="n">ba</span><span class="o">=</span><span class="n">sa</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>If we compile the above code on the IDE provided below, we encounter the following output.</p><pre><code class="language-None">Resources of A are acquired.
Resources of B are acquired.
</code></pre><p>It never released our resources at the time our objects went out of scope. This problem should be solved with a weak reference type.</p><hr /><h3 id="design-goals">Design goals</h3><p>Our weak reference class is an extension of shared reference as it can access and modify the contents of our shared reference without imposing its presence on the <code class="language-plaintext highlighter-rouge">shared_reference</code> interface. Consequently, we have must satisfy the following requirements:</p><ul><li>Must initialize only <code class="language-plaintext highlighter-rouge">shared_reference&lt;T&gt;</code> type<li>Must not take ownership of <code class="language-plaintext highlighter-rouge">shared_reference&lt;T&gt;</code> type<li>Pointer-like interface<li>Must provide a function of counting references</ul><hr /><h3 id="implementation">Implementation</h3><p>Now that we defined our goals, let us work on them!</p><h4 id="requirement-must-initialize-only-shared_referencet-type">Requirement: Must initialize only <code class="language-plaintext highlighter-rouge">shared_reference&lt;T&gt;</code> type</h4><p>I found this a little bit tricky to implement. We will find out why it is tricky when we implement a non-owning mechanism. But for now, let us try to partially fulfill our first requirement.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>template&lt;typename T&gt; class weak_reference: public shared_reference&lt;T&gt;{
    public:
        explicit weak_reference(shared_reference&lt;T&gt;&amp; i_ptr);
};
</pre></table></code></div></div><p>This may seem what we meant by an <em>extension</em> of shared reference. And by the looks of it, it may be a plausible assumption until we ran into the problem of calling destructors. Let us discuss the subtle design flaws on this matter in our attempt to suffice the second requirement.</p><h4 id="requirement-must-not-take-ownership-of-shared_referencet-type">Requirement: Must not take ownership of <code class="language-plaintext highlighter-rouge">shared_reference&lt;T&gt;</code> type</h4><p>Before we proceed into anything, let us be clear by what we mean by taking ownership? In the context of shared reference, all entities share ownership with the resource it has; that is, for each time a <code class="language-plaintext highlighter-rouge">shared_reference</code> instance goes out of scope, it determines the state on whether calling the resource clean-up would be appropriate. Now, our weak reference should not take ownership of <code class="language-plaintext highlighter-rouge">shared_reference</code>’s resource. We only need to be able to access and modify its content. In doing so, we need to communicate with the <code class="language-plaintext highlighter-rouge">shared_reference</code> class.</p><p>To establish communication between classes, we have to make dependencies. That is why our attempts jump back and forth with our <a href="https://dcode.hashnode.dev/implementing-building-blocks-of-reference-semantics-shared-reference">shared_reference</a> class. Let us consider our first attempt at establishing dependency with inheritance and discover its design flaws. Consider an adjacent example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">SuperType</span><span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">SuperType</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"SuperType resources are acquired. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">SuperType</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"SuperType resources are released. </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Subtype</span><span class="o">:</span> <span class="k">public</span> <span class="n">SuperType</span><span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Subtype</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Subtype resources are acquired. "</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="p">}</span>
	<span class="o">~</span><span class="n">Subtype</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Subtype resources are released. "</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Subtype</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>At the time <code class="language-plaintext highlighter-rouge">s</code> goes out of scope, it outputs the following:</p><pre><code class="language-None">SuperType resources are acquired.
Subtype resources are acquired.
Subtype resources are released.
SuperType resources are released.
</code></pre><p>In the above example, we inevitably call the superclass destructor. And we must call its destructor if we want to establish dependency through inheritance, but what does it mean when we decided to extend share reference to weak reference by means for the inheritance? You guessed it! We alter the state of our reference counter and possibly preemptively release our resources because of it.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">sh_ref</span><span class="p">(</span><span class="k">new</span> <span class="nf">A</span><span class="p">());</span>
<span class="p">{</span>
    <span class="n">weak_referene</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">wk_ref</span><span class="p">(</span><span class="n">sh_ref</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// since it calls superclass destructor the clean-up happens here</span>

</pre></table></code></div></div><p>Let us step back and consider another attempt of establishing dependency. Recall that our concern is to get access to <code class="language-plaintext highlighter-rouge">shared_reference</code>’s private members. For this case, we can use a <a href="https://en.cppreference.com/w/cpp/language/friend">friend</a> to access <code class="language-plaintext highlighter-rouge">shared_reference</code>’s private members without inheriting them.</p><p>We declare a friend class inside our <code class="language-plaintext highlighter-rouge">shared_reference</code> as follows:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"weak_reference.h"</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">shared_reference</span><span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">weak_reference</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">size_t</span> <span class="n">m_counter</span><span class="p">;</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">m_ptr</span><span class="p">;</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Then we write a special constructor that accepts <code class="language-plaintext highlighter-rouge">shared_reference</code> and an internal representation of that reference inside our <code class="language-plaintext highlighter-rouge">weak_reference</code> class.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp"># include "shared_reference.h"
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">weak_reference</span><span class="p">{</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">m_ptr</span><span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
    <span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">handle</span><span class="p">;</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="nf">weak_reference</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">i_ptr</span><span class="p">)</span> <span class="o">:</span>
      <span class="n">m_ptr</span><span class="p">(</span><span class="n">i_ptr</span><span class="p">.</span><span class="n">get</span><span class="p">()),</span>
      <span class="n">handle</span><span class="p">(</span><span class="n">i_ptr</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="n">weak_reference</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Recall that for each time we call the reference constructor, we call the <code class="language-plaintext highlighter-rouge">copy()</code> function that increments the state of our reference counter. Since we do not want to alter the state of our reference counter, we have to counteract the consequences of calling the reference constructor. Inside our shared reference class, we declare a private function that is responsible for suppressing unintended incrementation by calling the reference constructor.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nl">private:</span>
    <span class="kt">void</span> <span class="n">suppress_increment</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span><span class="n">m_counter</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">suppress_decrement</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span><span class="n">m_coutner</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</pre></table></code></div></div><p>Since for each time, <code class="language-plaintext highlighter-rouge">shared_reference</code> destructor gets called we decrement our reference counter until it is set for clean-up, we need to make sure this will not happen in the context of <code class="language-plaintext highlighter-rouge">weak_reference</code>. So we write another private function for suppressing unintended decrementation.</p><p>In effect, our weak reference will not alter the state of the reference counter and we have got ourselves a representation of shared_reference which we shall exploit later.</p><h4 id="requirement-pointer-like-interface">Requirement: Pointer-like interface</h4><p>We need an interface to communicate with the state of our unique reference. For consistency, it has to resemble the interface of a pointer.</p><p>Recall that a pointer can be dereferenced with <code class="language-plaintext highlighter-rouge">*</code> and <code class="language-plaintext highlighter-rouge">-&gt;</code> operators. And we need <code class="language-plaintext highlighter-rouge">&amp;</code> operator to inspect the location of our pointer in memory. These are the basic operators we need to overload for our unique reference. To do this, we write:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    T &amp;operator*(void) { return *(this-&gt;m_ptr); }
    T *operator-&gt;(void) { return this-&gt;m_ptr; }
    T &amp;operator&amp;(weak_reference&lt;T&gt; &amp;other) { return other.m_ptr; }
</pre></table></code></div></div><p>Let us walk through the three lines.</p><p>The first line returns a reference of <code class="language-plaintext highlighter-rouge">*(this-&gt;m_ptr)</code> which means that the content of <code class="language-plaintext highlighter-rouge">m_ptr</code> is accessed that which we can modify and read. The same idea goes with the arrow operator, we return a pointer to <code class="language-plaintext highlighter-rouge">m_ptr</code>’s location in memory. The last operator is slightly different in that it returns the address of the pointer and not the referent. <a href="https://dcode.hashnode.dev/pointers-and-references-design-goals-and-use-cases">Recall</a> that a pointer has its own location in memory separate from the entities it points to.</p><p>Let’s go beyond our requirement list and add little features that return the current count of our references and their contents. We call these functions <code class="language-plaintext highlighter-rouge">count()</code>, <code class="language-plaintext highlighter-rouge">is_expired()</code>, and <code class="language-plaintext highlighter-rouge">release()</code>. The implementation is equally trivial.</p><h4 id="requirement-must-provide-a-function-of-counting-references">Requirement: Must provide a function of counting references</h4><p>Since we have an internal representation of shared reference, we can inspect the state of its reference counter and check if our resources have been released. Additionally, we may want our weak reference to release its handle on shared reference resources. These functionalities are handled by the following public functions:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    <span class="kt">int</span> <span class="nf">count</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span> <span class="k">return</span> <span class="n">handle</span><span class="p">.</span><span class="n">count</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">release</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">is_expired</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_ptr</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="p">}</span>
</pre></table></code></div></div><hr /><h3 id="putting-it-all-together">Putting it all together</h3><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="cp"># pragma once
# include "shared_reference.h"
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">weak_reference</span><span class="p">{</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">m_ptr</span><span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>
    <span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">handle</span><span class="p">;</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="nf">weak_reference</span><span class="p">(</span><span class="n">shared_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">i_ptr</span><span class="p">)</span> <span class="o">:</span>
      <span class="n">m_ptr</span><span class="p">(</span><span class="n">i_ptr</span><span class="p">.</span><span class="n">get</span><span class="p">()),</span>
      <span class="n">handle</span><span class="p">(</span><span class="n">i_ptr</span><span class="p">)</span>
    <span class="p">{</span><span class="n">i_ptr</span><span class="p">.</span><span class="n">suppress_increment</span><span class="p">();}</span>

    <span class="n">weak_reference</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">weak_reference</span><span class="p">(</span><span class="k">const</span> <span class="n">weak_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">weak_reference</span><span class="p">(</span><span class="n">weak_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="o">~</span><span class="n">weak_reference</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
      <span class="n">handle</span><span class="p">.</span><span class="n">suppress_decrement</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">weak_reference</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">weak_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">weak_reference</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">weak_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Type</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">T</span> <span class="o">*</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&amp;</span><span class="p">(</span><span class="n">weak_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">other</span><span class="p">.</span><span class="n">m_ptr</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">T</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_ptr</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">count</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span><span class="k">return</span> <span class="n">handle</span><span class="p">.</span><span class="n">count</span><span class="p">();}</span>

    <span class="kt">void</span> <span class="n">release</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">is_expired</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_ptr</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><hr /><h3 id="test-cases">Test cases</h3><p>Time to see if we satisfied our design requirements:</p><iframe height="700px" width="100%" src="https://replit.com/@delvinjohn/WeakReference?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe><p>In the executable program above, we noticed that weak references solve the reference cycle problem.</p><hr /><h3 id="summary">Summary</h3><p>We fleshed out our design requirements and implemented our version of the weak reference to satisfy what we intend to do with it. We extended the capability of shared reference by extending its features with weak reference whereby we successfully solved the reference cycle problem.</p><p>Here ends the ownership semantics series! I hope you carry along with you the new things we learned regarding resource management.</p><p>As always, have fun hacking!</p><hr /><h3 id="references">References</h3><ul><li><p>Wikipedia contributors. (2021, July 29). Reference counting. In Wikipedia, The Free Encyclopedia. Retrieved 08:48, August 25, 2021, from https://en.wikipedia.org/w/index.php?title=Reference_counting&amp;oldid=1036113247</p><li><p>Amiana, D. (2021). Implementing Building Blocks of Reference Semantics: Shared Reference. https://dcode.hashnode.dev/implementing-building-blocks-of-reference-semantics-shared-reference</p><li><p>cppreference.com (2021). Friend. https://en.cppreference.com/w/cpp/language/friend.</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a>, <a href='/categories/computer-science/'>Computer Science</a>, <a href='/categories/c/'>C++</a>, <a href='/categories/ownership-semantics/'>Ownership Semantics</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/programming/" class="post-tag no-text-decoration" >programming</a> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/ownership-semantics/" class="post-tag no-text-decoration" >Ownership Semantics</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Weak References - Dave Amiana&url=https://adeeconometrics.github.io//posts/Weak-Reference/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Weak References - Dave Amiana&u=https://adeeconometrics.github.io//posts/Weak-Reference/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Weak References - Dave Amiana&url=https://adeeconometrics.github.io//posts/Weak-Reference/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/On-Pointer-Types/">On Pointer Types</a><li><a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/">Pointers and References: Design Goals and Use Cases</a><li><a href="/posts/Unique-Reference/">Unique References</a><li><a href="/posts/Shared-Reference/">Shared References</a><li><a href="/posts/Weak-Reference/">Weak References</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/On-Pointer-Types/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>On Pointer Types</h3><div class="text-muted small"><p> In this article, I aim to introduce the concept and motivation behind using pointers. There are breeds of C++ developers that only use smart pointers for safety reasons, others that only use raw po...</p></div></div></a></div><div class="card"> <a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/"><div class="card-body"> <span class="timeago small" > Aug 12, 2021 <i class="unloaded">2021-08-12T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Pointers and References: Design Goals and Use Cases</h3><div class="text-muted small"><p> At first, it seems that C++ makes things more complicated by introducing yet another layer of abstraction. References seem to encapsulate the same set of functionalities as pointers. Both of these ...</p></div></div></a></div><div class="card"> <a href="/posts/Unique-Reference/"><div class="card-body"> <span class="timeago small" > Aug 17, 2021 <i class="unloaded">2021-08-17T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Unique References</h3><div class="text-muted small"><p> Our previous discussion explores the anatomy of pointer types in C and C++ on par with hinting nuances of reference semantics. We discussed the use cases of raw pointers and smart pointers in moder...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Shared-Reference/" class="btn btn-outline-primary" prompt="Older"><p>Shared References</p></a> <a href="/posts/Preface-DataStructures/" class="btn btn-outline-primary" prompt="Newer"><p>Preface: Data Structures</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/iamdeb25">Dave Amiana</a>.</p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://adeeconometrics.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
