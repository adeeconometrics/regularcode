<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Elements of Programming" /><meta name="author" content="Dave Amiana" /><meta property="og:locale" content="en_US" /><meta name="description" content="There are two general ways of looking at data structures: concept and implementation. Ideally, they should serve you the sense in selecting an effective data structure for a given problem. Fundamental data structures manifest themselves naturally in most situations. The problem usually demands a certain data structure, while others could be represented in different ways. An effective data structure should simplify the problem. But that is only half of the story since a data structure must also ensure computational efficiency. We can simplify the problem by conceptually looking for an apt data structure while performance benefits are obtained by looking into the implementation. Now that we are familiar with the essence of looking at the two broad lenses in selecting a data structure, I should formally introduce you to the characters. We can view data structures from abstraction — that we shall call from hereon then as Abstract Data Type — and implementation. An Abstract Data Types (ADT) ought to describe a set of functionalities in a given data structure — they are written in a declarative manner. It is close to an algebraic structure in mathematics that outlines the rules and operations in a particular context [1]. The inspirations from mathematics are established within a class that contains a collection of values, and behaviors that support the operations that we can do within a structure. Such an abstract model hides the implementation logic. ADT is language-agnostic as it only describes the prototype of a data structure. List: - add -&gt; adds an element on the list - remove -&gt; removes an element on the list - sort -&gt; sort the list in order - search -&gt; search a value on the list. If value is found, return true. - display -&gt; display list traversal In programming a data structure with an abstract model (ADT), a good practice is to establish loose coupling between modules that contain the ADT and the implementation specifics. The purpose is to maintain a conceptual map between programming logic and functionalities which improves the maintainability of our system. Below is an example of implementing an ADT inside a language which in this case is C++ because the Standard Template Library (STL) is deemed mature and state of the art, it is a good reference for reading a good piece of software. However, due to its nuances and technical sophistication, we will only base our discussion on one of the core concepts of STL: containers. Keeping this in a separate module improves maintainability and clarifies the intention of the developer before they implement the logic specific to that functionality. Do not worry about the new word singly-linked list because we would not talk about that here. For now, focus on how we wrote our ADT for describing the operations of the data structure — which in this case is a List. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # pragma once // ADT of singly-linked list class List{ private: struct Node{ int data; Node *next; }; Node *head; public: explicit List(); ~List(); void add(Node _node); void remove(Node _node); void sort(); void display(); void clear(); bool is_empty(); bool is_element(Node _node); }; Meanwhile, the implementation specifics contain the quirks and tricks that ensure the operations ascribed in the ADT. From this perspective, it is important to know the quirks of your language to know the techniques that ensure safety and efficiency, such as referencing and memory management in languages like C/C++. For this matter, implementing the concepts defined in ADT closely works with the language; the programmer must be technically adept in the language. In practice, these two lenses work together by establishing clarity first, then specifications. Fundamental Data Structures Much like the abstract and practical resemblance of Euclidean geometry to the world, ADT and its Implementation correspond in a manner where the former is purely ideal while the latter is closer with actuality. For this section, we briefly introduce the fundamental data structures and cite some of their use cases. We shall be introduced to the following data structures. List Deque Tree Set Map Graph Before we delve in a little further, we should keep in mind the Base functionalities of our data structures. The baseline for each structure has to support the following operations: it should be able to search an item, sort, insert, update, and delete items. Search − Algorithm to find an item in a data structure. Sort − Algorithm to organize items in a certain order. Insert − Algorithm to insert items in a data structure. Update − Algorithm to update an existing item in a data structure. Delete − Algorithm to remove an existing item from a data structure. 1 2 3 4 5 6 7 8 9 10 11 template&lt;typename T&gt; class Base{ public: Base(); virtual ~Base(); virtual void search(const T&amp; _element) = 0; virtual void sort() = 0; virtual void insert(const T&amp; _element) = 0; virtual void update() = 0; virtual void delete(const T&amp; _element) = 0; }; List The list is an abstract data type that represents a countable number of ordered values, where the same value may occur more than once. Lists can be ordered linearly or non-linearly. Non-linear lists can be implemented in a form of a Tree, Graph, or a Map. However, we distinguished them in their respective categories for they, themselves, have their own nuances. List, in this context, pertains to a linear list family. A list data structure is useful when the notion of order is obtained, a value is allowed to have duplicates, and whenever we would like to do sorting and searching with our data set. The List ADT is implemented in the class of Sequence containers in C++ STL. It comprises the following: array, vector, deque, forwad_list, and list. Conceptually, all other data structures can be implemented with lists [2], however, we want to categorize them for the sorts of structures they represent, which is useful for problems we encounter. This is related to how algorithms are categorized which I laid out here: %[https://dcode.hashnode.dev/making-sense-of-algorithms-general-perspective] A common structure when we talk about a list is called linked-list (implemented in STL as a list). It is applied in many use-cases such as deriving other structures, the links you visit in a web browser, or music playlists. Deque Deque is a combination of queue and stack since the difference between these data structures is their ordering whereas the queue maintains a FIFO order, the stack keeps a LIFO order. Thus, deque support FIFO and LIFO ordering of a list. FIFO means first-in, first-out ordering. The most common example would be to think of waiting in line in supermarkets. Sometimes we call this a queue where the policy established is first-come, first-served. LIFO, on the other hand, stands for last-in, first-out ordering. Think of removing a book from a pile of books. You would have to remove the top book, iteratively until you found the book you want to read. Queues are used for maintaining a LIFO order of precedence in processing requests. A great example would be scheduling systems: the processing is done on a first-come, first-serve basis. CPU scheduling systems exploit the LIFO property of the queue [3]. A sample thread pool (green boxes) with a queue (FIFO) of waiting for tasks (blue) and a queue of completed tasks (yellow). The common use-cases of the stack resonate within the language such as the call stack wherein stack data structure that stores information about the active subroutines of a computer program. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # pragma once template &lt;typename T&gt; class Deque: public Base&lt;T&gt;{ private: int size; T* front_reference; T* back_reference; public: Deque(); ~Deque(); // basic functionalities void search(const T&amp; _element) override; void sort() override; void insert(const T&amp; _element) override; void update() override; void delete(const T&amp; _element) override; // specialized function in Deque container void push_back(const T&amp; _element); void push_front(const T&amp; _element); void pop_back(const T&amp; _element); void pop_front(const T&amp; _element); void front(); void back(); }; Moving on to more specialized data structures since they rely on the previous data structures. This is where it gets so exciting! Trees A tree data structure is used to represent hierarchy or non-linear ordering. We commonly name them with what resembles a family tree. We will go over some common terminologies but keep in mind that it is not exhaustive. root — a root node is a starting point of a tree structure. It does not have a parent node. parent — a parent node is an immediate predecessor of a node. child — a child is a successor of a parent node leaf — a leaf is located at the end of the tree. It does not have any children. There are many versions of trees, and they can be implemented in various ways. It is important to note that although C++ STL does not have a tree container, it does implement sets as a Binary Search Tree. A binary search tree (BST) is a particular type of tree that maintains a property of allowing only two children per parent node where the left child is always less than the parent while the right child is always greater than the parent [4]. Another kind of tree that is widely used in cryptography is known as the Merkle Tree in which every leaf node is labeled with the cryptographic hash of a data block, and every non-leaf node is labeled with the cryptographic hash of the labels of its child nodes [5]. Compilers and interpreters [6] exploit the hierarchical structure and order of a tree. Parse trees are formal representations of a language that can be understood by computers. Set As we mentioned earlier, sets are implemented as trees. Sets are very useful for keeping unique elements in a given list, not to mention that they serve to be the foundation of mathematics — we know this from set theory. It follows that advanced mathematical concepts are realized within the structure of the set. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # pragma once template &lt;typename T&gt; class Set{ public: Set(); ~Set(); void display(); void insert(const T&amp; _element); void remove(const T&amp; _element); int size(); bool is_element(const T&amp; _element); bool is_empty(); bool is_disjoint(); bool is_subset(const Set&amp; set); Set union(const Set&amp; set); Set intersection(const Set&amp; set); Set complement(const Set&amp; set); Set difference(const Set&amp; set); Set symmetric_difference(const Set&amp; set); }; Map A map is a key-value pair data structure, other languages like Python call them dictionaries. A key is an index that you use to call its corresponding value. The computer scientist, Brian Kernighan, deemed them as the most useful kind of data structure. %[https://youtu.be/qTZJLJ3Gm6Q] The most notable application of maps is in database systems. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # pragma once # include &lt;string&gt; template&lt;typename T&gt; class Map{ public: Map(); ~Map(); void add(const std::string &amp;key, const T&amp; value); void remove(const std::string &amp;key, const T&amp; value); void get_value(const std::string &amp;key); void get_key(const T&amp; value); void display(); }; Graph Finally, the broadest category of data structure is here! A graph is a generalization of Trees. An area of mathematics and computer science is devoted to exploring the universe of graphs. Among my personal favorites is the realization of graph theory in automated theorem proving and some theoretical foundations in Physics, as found in Stephen Wolfram’s project. Graphs are everywhere, and we can represent nearly all problems with a graph since a tree is a special case of a graph and a linked list is a special case of a tree. Takeaways Now that we covered the fundamental data structures and their use cases, we learned that we can represent problems in various forms of data structure. We also covered the areas of applications where such data structures are found most crucial. And we laid out the abstract model for implementing these data structures. A fun way to explore this area of computer science is to try and implement them on your own. If you want to engage on this topic with me, I’ll be posting a series on the quirky bits of implementing these data structures in detail soon so stay tuned! References Dale, Nell; Walker, Henry M. (1996). Abstract Data Types: Specifications, Implementations, and Applications. Jones &amp; Bartlett Learning. ISBN 978–0–66940000–7. Stephens, R. (2019). Essential algorithms: a practical approach to computer algorithms using Python and C. John Wiley &amp; Sons. GeekforGeeks (2018). Applications of Queue Data Structure. https://www.geeksforgeeks.org/applications-of-queue-data-structure/ Wikipedia contributors. (2021, March 31). Binary search tree. In Wikipedia, The Free Encyclopedia. Retrieved 08:24, April 13, 2021, from https://en.wikipedia.org/w/index.php?title=Binary_search_tree&amp;oldid=1015282423 Becker, Georg (2008–07–18). “Merkle Signature Schemes, Merkle Trees and Their Cryptanalysis” (PDF). Ruhr-Universität Bochum. p. 16. Nystrom, R. (2018). Crafting Interpreters. https://craftinginterpreters. com/[2. 8. 2020]." /><meta property="og:description" content="There are two general ways of looking at data structures: concept and implementation. Ideally, they should serve you the sense in selecting an effective data structure for a given problem. Fundamental data structures manifest themselves naturally in most situations. The problem usually demands a certain data structure, while others could be represented in different ways. An effective data structure should simplify the problem. But that is only half of the story since a data structure must also ensure computational efficiency. We can simplify the problem by conceptually looking for an apt data structure while performance benefits are obtained by looking into the implementation. Now that we are familiar with the essence of looking at the two broad lenses in selecting a data structure, I should formally introduce you to the characters. We can view data structures from abstraction — that we shall call from hereon then as Abstract Data Type — and implementation. An Abstract Data Types (ADT) ought to describe a set of functionalities in a given data structure — they are written in a declarative manner. It is close to an algebraic structure in mathematics that outlines the rules and operations in a particular context [1]. The inspirations from mathematics are established within a class that contains a collection of values, and behaviors that support the operations that we can do within a structure. Such an abstract model hides the implementation logic. ADT is language-agnostic as it only describes the prototype of a data structure. List: - add -&gt; adds an element on the list - remove -&gt; removes an element on the list - sort -&gt; sort the list in order - search -&gt; search a value on the list. If value is found, return true. - display -&gt; display list traversal In programming a data structure with an abstract model (ADT), a good practice is to establish loose coupling between modules that contain the ADT and the implementation specifics. The purpose is to maintain a conceptual map between programming logic and functionalities which improves the maintainability of our system. Below is an example of implementing an ADT inside a language which in this case is C++ because the Standard Template Library (STL) is deemed mature and state of the art, it is a good reference for reading a good piece of software. However, due to its nuances and technical sophistication, we will only base our discussion on one of the core concepts of STL: containers. Keeping this in a separate module improves maintainability and clarifies the intention of the developer before they implement the logic specific to that functionality. Do not worry about the new word singly-linked list because we would not talk about that here. For now, focus on how we wrote our ADT for describing the operations of the data structure — which in this case is a List. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # pragma once // ADT of singly-linked list class List{ private: struct Node{ int data; Node *next; }; Node *head; public: explicit List(); ~List(); void add(Node _node); void remove(Node _node); void sort(); void display(); void clear(); bool is_empty(); bool is_element(Node _node); }; Meanwhile, the implementation specifics contain the quirks and tricks that ensure the operations ascribed in the ADT. From this perspective, it is important to know the quirks of your language to know the techniques that ensure safety and efficiency, such as referencing and memory management in languages like C/C++. For this matter, implementing the concepts defined in ADT closely works with the language; the programmer must be technically adept in the language. In practice, these two lenses work together by establishing clarity first, then specifications. Fundamental Data Structures Much like the abstract and practical resemblance of Euclidean geometry to the world, ADT and its Implementation correspond in a manner where the former is purely ideal while the latter is closer with actuality. For this section, we briefly introduce the fundamental data structures and cite some of their use cases. We shall be introduced to the following data structures. List Deque Tree Set Map Graph Before we delve in a little further, we should keep in mind the Base functionalities of our data structures. The baseline for each structure has to support the following operations: it should be able to search an item, sort, insert, update, and delete items. Search − Algorithm to find an item in a data structure. Sort − Algorithm to organize items in a certain order. Insert − Algorithm to insert items in a data structure. Update − Algorithm to update an existing item in a data structure. Delete − Algorithm to remove an existing item from a data structure. 1 2 3 4 5 6 7 8 9 10 11 template&lt;typename T&gt; class Base{ public: Base(); virtual ~Base(); virtual void search(const T&amp; _element) = 0; virtual void sort() = 0; virtual void insert(const T&amp; _element) = 0; virtual void update() = 0; virtual void delete(const T&amp; _element) = 0; }; List The list is an abstract data type that represents a countable number of ordered values, where the same value may occur more than once. Lists can be ordered linearly or non-linearly. Non-linear lists can be implemented in a form of a Tree, Graph, or a Map. However, we distinguished them in their respective categories for they, themselves, have their own nuances. List, in this context, pertains to a linear list family. A list data structure is useful when the notion of order is obtained, a value is allowed to have duplicates, and whenever we would like to do sorting and searching with our data set. The List ADT is implemented in the class of Sequence containers in C++ STL. It comprises the following: array, vector, deque, forwad_list, and list. Conceptually, all other data structures can be implemented with lists [2], however, we want to categorize them for the sorts of structures they represent, which is useful for problems we encounter. This is related to how algorithms are categorized which I laid out here: %[https://dcode.hashnode.dev/making-sense-of-algorithms-general-perspective] A common structure when we talk about a list is called linked-list (implemented in STL as a list). It is applied in many use-cases such as deriving other structures, the links you visit in a web browser, or music playlists. Deque Deque is a combination of queue and stack since the difference between these data structures is their ordering whereas the queue maintains a FIFO order, the stack keeps a LIFO order. Thus, deque support FIFO and LIFO ordering of a list. FIFO means first-in, first-out ordering. The most common example would be to think of waiting in line in supermarkets. Sometimes we call this a queue where the policy established is first-come, first-served. LIFO, on the other hand, stands for last-in, first-out ordering. Think of removing a book from a pile of books. You would have to remove the top book, iteratively until you found the book you want to read. Queues are used for maintaining a LIFO order of precedence in processing requests. A great example would be scheduling systems: the processing is done on a first-come, first-serve basis. CPU scheduling systems exploit the LIFO property of the queue [3]. A sample thread pool (green boxes) with a queue (FIFO) of waiting for tasks (blue) and a queue of completed tasks (yellow). The common use-cases of the stack resonate within the language such as the call stack wherein stack data structure that stores information about the active subroutines of a computer program. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # pragma once template &lt;typename T&gt; class Deque: public Base&lt;T&gt;{ private: int size; T* front_reference; T* back_reference; public: Deque(); ~Deque(); // basic functionalities void search(const T&amp; _element) override; void sort() override; void insert(const T&amp; _element) override; void update() override; void delete(const T&amp; _element) override; // specialized function in Deque container void push_back(const T&amp; _element); void push_front(const T&amp; _element); void pop_back(const T&amp; _element); void pop_front(const T&amp; _element); void front(); void back(); }; Moving on to more specialized data structures since they rely on the previous data structures. This is where it gets so exciting! Trees A tree data structure is used to represent hierarchy or non-linear ordering. We commonly name them with what resembles a family tree. We will go over some common terminologies but keep in mind that it is not exhaustive. root — a root node is a starting point of a tree structure. It does not have a parent node. parent — a parent node is an immediate predecessor of a node. child — a child is a successor of a parent node leaf — a leaf is located at the end of the tree. It does not have any children. There are many versions of trees, and they can be implemented in various ways. It is important to note that although C++ STL does not have a tree container, it does implement sets as a Binary Search Tree. A binary search tree (BST) is a particular type of tree that maintains a property of allowing only two children per parent node where the left child is always less than the parent while the right child is always greater than the parent [4]. Another kind of tree that is widely used in cryptography is known as the Merkle Tree in which every leaf node is labeled with the cryptographic hash of a data block, and every non-leaf node is labeled with the cryptographic hash of the labels of its child nodes [5]. Compilers and interpreters [6] exploit the hierarchical structure and order of a tree. Parse trees are formal representations of a language that can be understood by computers. Set As we mentioned earlier, sets are implemented as trees. Sets are very useful for keeping unique elements in a given list, not to mention that they serve to be the foundation of mathematics — we know this from set theory. It follows that advanced mathematical concepts are realized within the structure of the set. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # pragma once template &lt;typename T&gt; class Set{ public: Set(); ~Set(); void display(); void insert(const T&amp; _element); void remove(const T&amp; _element); int size(); bool is_element(const T&amp; _element); bool is_empty(); bool is_disjoint(); bool is_subset(const Set&amp; set); Set union(const Set&amp; set); Set intersection(const Set&amp; set); Set complement(const Set&amp; set); Set difference(const Set&amp; set); Set symmetric_difference(const Set&amp; set); }; Map A map is a key-value pair data structure, other languages like Python call them dictionaries. A key is an index that you use to call its corresponding value. The computer scientist, Brian Kernighan, deemed them as the most useful kind of data structure. %[https://youtu.be/qTZJLJ3Gm6Q] The most notable application of maps is in database systems. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # pragma once # include &lt;string&gt; template&lt;typename T&gt; class Map{ public: Map(); ~Map(); void add(const std::string &amp;key, const T&amp; value); void remove(const std::string &amp;key, const T&amp; value); void get_value(const std::string &amp;key); void get_key(const T&amp; value); void display(); }; Graph Finally, the broadest category of data structure is here! A graph is a generalization of Trees. An area of mathematics and computer science is devoted to exploring the universe of graphs. Among my personal favorites is the realization of graph theory in automated theorem proving and some theoretical foundations in Physics, as found in Stephen Wolfram’s project. Graphs are everywhere, and we can represent nearly all problems with a graph since a tree is a special case of a graph and a linked list is a special case of a tree. Takeaways Now that we covered the fundamental data structures and their use cases, we learned that we can represent problems in various forms of data structure. We also covered the areas of applications where such data structures are found most crucial. And we laid out the abstract model for implementing these data structures. A fun way to explore this area of computer science is to try and implement them on your own. If you want to engage on this topic with me, I’ll be posting a series on the quirky bits of implementing these data structures in detail soon so stay tuned! References Dale, Nell; Walker, Henry M. (1996). Abstract Data Types: Specifications, Implementations, and Applications. Jones &amp; Bartlett Learning. ISBN 978–0–66940000–7. Stephens, R. (2019). Essential algorithms: a practical approach to computer algorithms using Python and C. John Wiley &amp; Sons. GeekforGeeks (2018). Applications of Queue Data Structure. https://www.geeksforgeeks.org/applications-of-queue-data-structure/ Wikipedia contributors. (2021, March 31). Binary search tree. In Wikipedia, The Free Encyclopedia. Retrieved 08:24, April 13, 2021, from https://en.wikipedia.org/w/index.php?title=Binary_search_tree&amp;oldid=1015282423 Becker, Georg (2008–07–18). “Merkle Signature Schemes, Merkle Trees and Their Cryptanalysis” (PDF). Ruhr-Universität Bochum. p. 16. Nystrom, R. (2018). Crafting Interpreters. https://craftinginterpreters. com/[2. 8. 2020]." /><link rel="canonical" href="https://adeeconometrics.github.io//posts/Elements-of-Programming/" /><meta property="og:url" content="https://adeeconometrics.github.io//posts/Elements-of-Programming/" /><meta property="og:site_name" content="Dave Amiana" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-05-20T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Elements of Programming" /><meta name="twitter:site" content="@iamdeb25" /><meta name="twitter:creator" content="@Dave Amiana" /><meta name="google-site-verification" content="google-site-verification=28bVbRErS2VwJaonXuu3GbqmRlyNvizt6I00B2kQh88" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Dave Amiana"},"dateModified":"2022-10-22T22:11:50+08:00","datePublished":"2021-05-20T00:00:00+08:00","description":"There are two general ways of looking at data structures: concept and implementation. Ideally, they should serve you the sense in selecting an effective data structure for a given problem. Fundamental data structures manifest themselves naturally in most situations. The problem usually demands a certain data structure, while others could be represented in different ways. An effective data structure should simplify the problem. But that is only half of the story since a data structure must also ensure computational efficiency. We can simplify the problem by conceptually looking for an apt data structure while performance benefits are obtained by looking into the implementation. Now that we are familiar with the essence of looking at the two broad lenses in selecting a data structure, I should formally introduce you to the characters. We can view data structures from abstraction — that we shall call from hereon then as Abstract Data Type — and implementation. An Abstract Data Types (ADT) ought to describe a set of functionalities in a given data structure — they are written in a declarative manner. It is close to an algebraic structure in mathematics that outlines the rules and operations in a particular context [1]. The inspirations from mathematics are established within a class that contains a collection of values, and behaviors that support the operations that we can do within a structure. Such an abstract model hides the implementation logic. ADT is language-agnostic as it only describes the prototype of a data structure. List: - add -&gt; adds an element on the list - remove -&gt; removes an element on the list - sort -&gt; sort the list in order - search -&gt; search a value on the list. If value is found, return true. - display -&gt; display list traversal In programming a data structure with an abstract model (ADT), a good practice is to establish loose coupling between modules that contain the ADT and the implementation specifics. The purpose is to maintain a conceptual map between programming logic and functionalities which improves the maintainability of our system. Below is an example of implementing an ADT inside a language which in this case is C++ because the Standard Template Library (STL) is deemed mature and state of the art, it is a good reference for reading a good piece of software. However, due to its nuances and technical sophistication, we will only base our discussion on one of the core concepts of STL: containers. Keeping this in a separate module improves maintainability and clarifies the intention of the developer before they implement the logic specific to that functionality. Do not worry about the new word singly-linked list because we would not talk about that here. For now, focus on how we wrote our ADT for describing the operations of the data structure — which in this case is a List. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # pragma once // ADT of singly-linked list class List{ private: struct Node{ int data; Node *next; }; Node *head; public: explicit List(); ~List(); void add(Node _node); void remove(Node _node); void sort(); void display(); void clear(); bool is_empty(); bool is_element(Node _node); }; Meanwhile, the implementation specifics contain the quirks and tricks that ensure the operations ascribed in the ADT. From this perspective, it is important to know the quirks of your language to know the techniques that ensure safety and efficiency, such as referencing and memory management in languages like C/C++. For this matter, implementing the concepts defined in ADT closely works with the language; the programmer must be technically adept in the language. In practice, these two lenses work together by establishing clarity first, then specifications. Fundamental Data Structures Much like the abstract and practical resemblance of Euclidean geometry to the world, ADT and its Implementation correspond in a manner where the former is purely ideal while the latter is closer with actuality. For this section, we briefly introduce the fundamental data structures and cite some of their use cases. We shall be introduced to the following data structures. List Deque Tree Set Map Graph Before we delve in a little further, we should keep in mind the Base functionalities of our data structures. The baseline for each structure has to support the following operations: it should be able to search an item, sort, insert, update, and delete items. Search − Algorithm to find an item in a data structure. Sort − Algorithm to organize items in a certain order. Insert − Algorithm to insert items in a data structure. Update − Algorithm to update an existing item in a data structure. Delete − Algorithm to remove an existing item from a data structure. 1 2 3 4 5 6 7 8 9 10 11 template&lt;typename T&gt; class Base{ public: Base(); virtual ~Base(); virtual void search(const T&amp; _element) = 0; virtual void sort() = 0; virtual void insert(const T&amp; _element) = 0; virtual void update() = 0; virtual void delete(const T&amp; _element) = 0; }; List The list is an abstract data type that represents a countable number of ordered values, where the same value may occur more than once. Lists can be ordered linearly or non-linearly. Non-linear lists can be implemented in a form of a Tree, Graph, or a Map. However, we distinguished them in their respective categories for they, themselves, have their own nuances. List, in this context, pertains to a linear list family. A list data structure is useful when the notion of order is obtained, a value is allowed to have duplicates, and whenever we would like to do sorting and searching with our data set. The List ADT is implemented in the class of Sequence containers in C++ STL. It comprises the following: array, vector, deque, forwad_list, and list. Conceptually, all other data structures can be implemented with lists [2], however, we want to categorize them for the sorts of structures they represent, which is useful for problems we encounter. This is related to how algorithms are categorized which I laid out here: %[https://dcode.hashnode.dev/making-sense-of-algorithms-general-perspective] A common structure when we talk about a list is called linked-list (implemented in STL as a list). It is applied in many use-cases such as deriving other structures, the links you visit in a web browser, or music playlists. Deque Deque is a combination of queue and stack since the difference between these data structures is their ordering whereas the queue maintains a FIFO order, the stack keeps a LIFO order. Thus, deque support FIFO and LIFO ordering of a list. FIFO means first-in, first-out ordering. The most common example would be to think of waiting in line in supermarkets. Sometimes we call this a queue where the policy established is first-come, first-served. LIFO, on the other hand, stands for last-in, first-out ordering. Think of removing a book from a pile of books. You would have to remove the top book, iteratively until you found the book you want to read. Queues are used for maintaining a LIFO order of precedence in processing requests. A great example would be scheduling systems: the processing is done on a first-come, first-serve basis. CPU scheduling systems exploit the LIFO property of the queue [3]. A sample thread pool (green boxes) with a queue (FIFO) of waiting for tasks (blue) and a queue of completed tasks (yellow). The common use-cases of the stack resonate within the language such as the call stack wherein stack data structure that stores information about the active subroutines of a computer program. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # pragma once template &lt;typename T&gt; class Deque: public Base&lt;T&gt;{ private: int size; T* front_reference; T* back_reference; public: Deque(); ~Deque(); // basic functionalities void search(const T&amp; _element) override; void sort() override; void insert(const T&amp; _element) override; void update() override; void delete(const T&amp; _element) override; // specialized function in Deque container void push_back(const T&amp; _element); void push_front(const T&amp; _element); void pop_back(const T&amp; _element); void pop_front(const T&amp; _element); void front(); void back(); }; Moving on to more specialized data structures since they rely on the previous data structures. This is where it gets so exciting! Trees A tree data structure is used to represent hierarchy or non-linear ordering. We commonly name them with what resembles a family tree. We will go over some common terminologies but keep in mind that it is not exhaustive. root — a root node is a starting point of a tree structure. It does not have a parent node. parent — a parent node is an immediate predecessor of a node. child — a child is a successor of a parent node leaf — a leaf is located at the end of the tree. It does not have any children. There are many versions of trees, and they can be implemented in various ways. It is important to note that although C++ STL does not have a tree container, it does implement sets as a Binary Search Tree. A binary search tree (BST) is a particular type of tree that maintains a property of allowing only two children per parent node where the left child is always less than the parent while the right child is always greater than the parent [4]. Another kind of tree that is widely used in cryptography is known as the Merkle Tree in which every leaf node is labeled with the cryptographic hash of a data block, and every non-leaf node is labeled with the cryptographic hash of the labels of its child nodes [5]. Compilers and interpreters [6] exploit the hierarchical structure and order of a tree. Parse trees are formal representations of a language that can be understood by computers. Set As we mentioned earlier, sets are implemented as trees. Sets are very useful for keeping unique elements in a given list, not to mention that they serve to be the foundation of mathematics — we know this from set theory. It follows that advanced mathematical concepts are realized within the structure of the set. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # pragma once template &lt;typename T&gt; class Set{ public: Set(); ~Set(); void display(); void insert(const T&amp; _element); void remove(const T&amp; _element); int size(); bool is_element(const T&amp; _element); bool is_empty(); bool is_disjoint(); bool is_subset(const Set&amp; set); Set union(const Set&amp; set); Set intersection(const Set&amp; set); Set complement(const Set&amp; set); Set difference(const Set&amp; set); Set symmetric_difference(const Set&amp; set); }; Map A map is a key-value pair data structure, other languages like Python call them dictionaries. A key is an index that you use to call its corresponding value. The computer scientist, Brian Kernighan, deemed them as the most useful kind of data structure. %[https://youtu.be/qTZJLJ3Gm6Q] The most notable application of maps is in database systems. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # pragma once # include &lt;string&gt; template&lt;typename T&gt; class Map{ public: Map(); ~Map(); void add(const std::string &amp;key, const T&amp; value); void remove(const std::string &amp;key, const T&amp; value); void get_value(const std::string &amp;key); void get_key(const T&amp; value); void display(); }; Graph Finally, the broadest category of data structure is here! A graph is a generalization of Trees. An area of mathematics and computer science is devoted to exploring the universe of graphs. Among my personal favorites is the realization of graph theory in automated theorem proving and some theoretical foundations in Physics, as found in Stephen Wolfram’s project. Graphs are everywhere, and we can represent nearly all problems with a graph since a tree is a special case of a graph and a linked list is a special case of a tree. Takeaways Now that we covered the fundamental data structures and their use cases, we learned that we can represent problems in various forms of data structure. We also covered the areas of applications where such data structures are found most crucial. And we laid out the abstract model for implementing these data structures. A fun way to explore this area of computer science is to try and implement them on your own. If you want to engage on this topic with me, I’ll be posting a series on the quirky bits of implementing these data structures in detail soon so stay tuned! References Dale, Nell; Walker, Henry M. (1996). Abstract Data Types: Specifications, Implementations, and Applications. Jones &amp; Bartlett Learning. ISBN 978–0–66940000–7. Stephens, R. (2019). Essential algorithms: a practical approach to computer algorithms using Python and C. John Wiley &amp; Sons. GeekforGeeks (2018). Applications of Queue Data Structure. https://www.geeksforgeeks.org/applications-of-queue-data-structure/ Wikipedia contributors. (2021, March 31). Binary search tree. In Wikipedia, The Free Encyclopedia. Retrieved 08:24, April 13, 2021, from https://en.wikipedia.org/w/index.php?title=Binary_search_tree&amp;oldid=1015282423 Becker, Georg (2008–07–18). “Merkle Signature Schemes, Merkle Trees and Their Cryptanalysis” (PDF). Ruhr-Universität Bochum. p. 16. Nystrom, R. (2018). Crafting Interpreters. https://craftinginterpreters. com/[2. 8. 2020].","headline":"Elements of Programming","mainEntityOfPage":{"@type":"WebPage","@id":"https://adeeconometrics.github.io//posts/Elements-of-Programming/"},"url":"https://adeeconometrics.github.io//posts/Elements-of-Programming/"}</script><title>Elements of Programming | Dave Amiana</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Dave Amiana"><meta name="application-name" content="Dave Amiana"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0M61FBNQ0K"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0M61FBNQ0K'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/profile-picture.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Dave Amiana</a></div><div class="site-subtitle font-italic">Open-source and Enterprise Software Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/adeeconometrics" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/dave-amiana/" aria-label="linkedin" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['amiana.dave','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Elements of Programming</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Elements of Programming</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Dave Amiana </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, May 20, 2021, 12:00 AM +0800" prep="on" > May 20, 2021 <i class="unloaded">2021-05-20T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 22, 2022, 10:11 PM +0800" prefix="Updated " > Oct 22, 2022 <i class="unloaded">2022-10-22T22:11:50+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2172 words">12 min</span></div></div><div class="post-content"><p>There are two general ways of looking at data structures: concept and implementation. Ideally, they should serve you the sense in selecting an effective data structure for a given problem. Fundamental data structures manifest themselves naturally in most situations. The problem usually demands a certain data structure, while others could be represented in different ways. An effective data structure should simplify the problem. But that is only half of the story since a data structure must also ensure computational efficiency. We can simplify the problem by conceptually looking for an apt data structure while performance benefits are obtained by looking into the implementation.</p><p>Now that we are familiar with the essence of looking at the two broad lenses in selecting a data structure, I should formally introduce you to the characters. We can view data structures from abstraction — that we shall call from hereon then as Abstract Data Type — and implementation.</p><p>An Abstract Data Types (ADT) ought to describe a set of functionalities in a given data structure — they are written in a declarative manner. It is close to an algebraic structure in mathematics that outlines the rules and operations in a particular context [1]. The inspirations from mathematics are established within a class that contains a collection of values, and behaviors that support the operations that we can do within a structure. Such an abstract model hides the implementation logic. ADT is language-agnostic as it only describes the prototype of a data structure.</p><pre><code class="language-None">List:
  - add -&gt; adds an element on the list
  - remove -&gt; removes an element on the list
  - sort -&gt; sort the list in order
  - search -&gt; search a value on the list. If value is found, return true.
  - display -&gt; display list traversal
</code></pre><hr /><p>In programming a data structure with an abstract model (ADT), a good practice is to establish <a href="https://en.wikipedia.org/wiki/Loose_coupling">loose coupling</a> between modules that contain the ADT and the implementation specifics. The purpose is to maintain a conceptual map between programming logic and functionalities which improves the maintainability of our system.</p><p>Below is an example of implementing an ADT inside a language which in this case is C++ because the Standard Template Library (STL) is deemed mature and state of the art, it is a good reference for reading a good piece of software. However, due to its nuances and technical sophistication, we will only base our discussion on one of the core concepts of STL: containers.</p><p>Keeping this in a separate module improves maintainability and clarifies the intention of the developer before they implement the logic specific to that functionality. Do not worry about the new word singly-linked list because we would not talk about that here. For now, focus on how we wrote our ADT for describing the operations of the data structure — which in this case is a List.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp"># pragma once
</span>
<span class="c1">// ADT of singly-linked list</span>
<span class="k">class</span> <span class="nc">List</span><span class="p">{</span>
  <span class="nl">private:</span>
    <span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
      <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
      <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="nf">List</span><span class="p">();</span>
    <span class="o">~</span><span class="n">List</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">Node</span> <span class="n">_node</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="n">Node</span> <span class="n">_node</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">sort</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">display</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">clear</span><span class="p">();</span>

    <span class="kt">bool</span> <span class="nf">is_empty</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="nf">is_element</span><span class="p">(</span><span class="n">Node</span> <span class="n">_node</span><span class="p">);</span>

<span class="p">};</span>
</pre></table></code></div></div><hr /><p>Meanwhile, the implementation specifics contain the quirks and tricks that ensure the operations ascribed in the ADT. From this perspective, it is important to know the quirks of your language to know the techniques that ensure safety and efficiency, such as referencing and memory management in languages like C/C++. For this matter, implementing the concepts defined in ADT closely works with the language; the programmer must be technically adept in the language.</p><p>In practice, these two lenses work together by establishing clarity first, then specifications.</p><hr /><h1 id="fundamental-data-structures">Fundamental Data Structures</h1><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1618748350087/pFDpTZUal.png" alt="image.png" /></p><blockquote><p>Much like the abstract and practical resemblance of Euclidean geometry to the world, ADT and its Implementation correspond in a manner where the former is purely ideal while the latter is closer with actuality.</p></blockquote><p>For this section, we briefly introduce the fundamental data structures and cite some of their use cases. We shall be introduced to the following data structures.</p><ul><li>List<li>Deque<li>Tree<li>Set<li>Map<li>Graph</ul><p>Before we delve in a little further, we should keep in mind the Base functionalities of our data structures. The baseline for each structure has to support the following operations: it should be able to search an item, sort, insert, update, and delete items.</p><ul><li>Search − Algorithm to find an item in a data structure.<li>Sort − Algorithm to organize items in a certain order.<li>Insert − Algorithm to insert items in a data structure.<li>Update − Algorithm to update an existing item in a data structure.<li>Delete − Algorithm to remove an existing item from a data structure.</ul><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
	<span class="nl">public:</span>
		<span class="n">Base</span><span class="p">();</span>
		<span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">();</span>
		<span class="k">virtual</span> <span class="kt">void</span> <span class="n">search</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span> <span class="kt">void</span> <span class="n">sort</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span> <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span> <span class="kt">void</span> <span class="k">delete</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><hr /><h2 id="list">List</h2><p>The list is an abstract data type that represents a countable number of ordered values, where the same value may occur more than once. Lists can be ordered linearly or non-linearly. Non-linear lists can be implemented in a form of a Tree, Graph, or a Map. However, we distinguished them in their respective categories for they, themselves, have their own nuances. List, in this context, pertains to a linear list family.</p><p>A list data structure is useful when the notion of order is obtained, a value is allowed to have duplicates, and whenever we would like to do sorting and searching with our data set. The List ADT is implemented in the class of <a href="https://www.cplusplus.com/reference/stl/">Sequence containers</a> in C++ STL. It comprises the following: <code class="language-plaintext highlighter-rouge">array</code>, <code class="language-plaintext highlighter-rouge">vector</code>, <code class="language-plaintext highlighter-rouge">deque</code>, <code class="language-plaintext highlighter-rouge">forwad_list</code>, and <code class="language-plaintext highlighter-rouge">list</code>.</p><p>Conceptually, all other data structures can be implemented with lists [2], however, we want to categorize them for the sorts of structures they represent, which is useful for problems we encounter.</p><blockquote><p>This is related to how algorithms are categorized which I laid out here:</p></blockquote><p>%[https://dcode.hashnode.dev/making-sense-of-algorithms-general-perspective]</p><p>A common structure when we talk about a list is called linked-list (implemented in STL as a list). It is applied in many use-cases such as deriving other structures, the links you visit in a web browser, or music playlists.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1618748833225/AiGuik0ex.png" alt="image.png" /></p><hr /><h2 id="deque">Deque</h2><p>Deque is a combination of queue and stack since the difference between these data structures is their ordering whereas the queue maintains a FIFO order, the stack keeps a LIFO order. Thus, deque support FIFO and LIFO ordering of a list.</p><p>FIFO means first-in, first-out ordering. The most common example would be to think of waiting in line in supermarkets. Sometimes we call this a queue where the policy established is first-come, first-served.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1618748875863/2u47zCGFS.png" alt="image.png" /></p><p>LIFO, on the other hand, stands for last-in, first-out ordering. Think of removing a book from a pile of books. You would have to remove the top book, iteratively until you found the book you want to read.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1618748897961/bhtYXEoIf.png" alt="image.png" /></p><p>Queues are used for maintaining a LIFO order of precedence in processing requests. A great example would be scheduling systems: the processing is done on a first-come, first-serve basis. CPU scheduling systems exploit the LIFO property of the queue [3].</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1618748918810/UPWHykQC-.png" alt="image.png" /></p><blockquote><p>A sample <a href="https://en.wikipedia.org/wiki/Thread_pool">thread pool</a> (green boxes) with a queue (FIFO) of waiting for tasks (blue) and a queue of completed tasks (yellow).</p></blockquote><p>The common use-cases of the stack resonate within the language such as the call stack wherein stack data structure that stores information about the active subroutines of a computer program.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1618748968929/2haShHIfx.png" alt="image.png" /></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp"># pragma once
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Deque</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span>
  <span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">front_reference</span><span class="p">;</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">back_reference</span><span class="p">;</span>

  <span class="nl">public:</span>
  <span class="n">Deque</span><span class="p">();</span>
  <span class="o">~</span><span class="n">Deque</span><span class="p">();</span>
  <span class="c1">// basic functionalities</span>
  <span class="kt">void</span> <span class="n">search</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">sort</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
  <span class="kt">void</span> <span class="k">delete</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
  <span class="c1">// specialized function in Deque container</span>
  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">push_front</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">pop_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">pop_front</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">front</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">back</span><span class="p">();</span>
<span class="p">};</span>
</pre></table></code></div></div><hr /><blockquote><p>Moving on to more specialized data structures since they rely on the previous data structures. This is where it gets so exciting!</p></blockquote><h2 id="trees">Trees</h2><p>A tree data structure is used to represent hierarchy or non-linear ordering. We commonly name them with what resembles a family tree. We will go over some common terminologies but keep in mind that it is not exhaustive.</p><ul><li>root — a root node is a starting point of a tree structure. It does not have a parent node.<li>parent — a parent node is an immediate predecessor of a node.<li>child — a child is a successor of a parent node<li>leaf — a leaf is located at the end of the tree. It does not have any children.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1618749099683/K2gKBo-8H.png" alt="image.png" /></p><p>There are many versions of trees, and they can be implemented in various ways. It is important to note that although C++ STL does not have a tree container, it does implement sets as a <a href="https://bityl.co/6Mhm">Binary Search Tree</a>.</p><p>A binary search tree (BST) is a particular type of tree that maintains a property of allowing only two children per parent node where the left child is always less than the parent while the right child is always greater than the parent [4].</p><p>Another kind of tree that is widely used in cryptography is known as the Merkle Tree in which every <a href="https://en.wikipedia.org/wiki/Leaf_node">leaf node</a> is labeled with the <a href="https://en.wikipedia.org/wiki/Leaf_node">cryptographic hash</a> of a data block, and every non-leaf node is labeled with the cryptographic hash of the labels of its child nodes [5].</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1618749178746/ha8It3rEE.png" alt="image.png" /></p><p>Compilers and interpreters [6] exploit the hierarchical structure and order of a tree. Parse trees are formal representations of a language that can be understood by computers.</p><hr /><h2 id="set">Set</h2><p>As we mentioned earlier, sets are implemented as trees. Sets are very useful for keeping unique elements in a given list, not to mention that they serve to be the foundation of mathematics — we know this from <a href="https://bityl.co/6Qni">set theory</a>. It follows that advanced mathematical concepts are realized within the structure of the set.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp"># pragma once
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Set</span><span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">Set</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Set</span><span class="p">();</span>

    <span class="kt">void</span> <span class="n">display</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">size</span><span class="p">();</span>

    <span class="kt">bool</span> <span class="n">is_element</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">_element</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">is_empty</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">is_disjoint</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">is_subset</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&amp;</span> <span class="n">set</span><span class="p">);</span>

    <span class="n">Set</span> <span class="k">union</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&amp;</span> <span class="n">set</span><span class="p">);</span>
    <span class="n">Set</span> <span class="n">intersection</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&amp;</span> <span class="n">set</span><span class="p">);</span>
    <span class="n">Set</span> <span class="n">complement</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&amp;</span> <span class="n">set</span><span class="p">);</span>
    <span class="n">Set</span> <span class="n">difference</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&amp;</span> <span class="n">set</span><span class="p">);</span>
    <span class="n">Set</span> <span class="n">symmetric_difference</span><span class="p">(</span><span class="k">const</span> <span class="n">Set</span><span class="o">&amp;</span> <span class="n">set</span><span class="p">);</span>
<span class="p">};</span>
</pre></table></code></div></div><hr /><h2 id="map">Map</h2><p>A map is a key-value pair data structure, other languages like Python call them dictionaries. A key is an index that you use to call its corresponding value.</p><p>The computer scientist, Brian Kernighan, deemed them as the most useful kind of data structure. %[https://youtu.be/qTZJLJ3Gm6Q]</p><p>The most notable application of maps is in <a href="https://www.cise.ufl.edu/~mschneid/Research/papers/HS05BoCh.pdf">database systems</a>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp"># pragma once
# include &lt;string&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Map</span><span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">Map</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Map</span><span class="p">();</span>

    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">get_value</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">get_key</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">display</span><span class="p">();</span>
<span class="p">};</span>
</pre></table></code></div></div><hr /><h2 id="graph">Graph</h2><p>Finally, the broadest category of data structure is here!</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://cdn.hashnode.com/res/hashnode/image/upload/v1618749384541/ZDis7E-3P.png" alt="image.png" /></p><p>A graph is a generalization of Trees. An area of mathematics and computer science is devoted to exploring the universe of graphs. Among my personal favorites is the realization of graph theory in automated theorem proving and some theoretical foundations in Physics, as found in Stephen Wolfram’s project.</p><p>Graphs are everywhere, and we can represent nearly all problems with a graph since a tree is a special case of a graph and a linked list is a special case of a tree.</p><hr /><h1 id="takeaways">Takeaways</h1><p>Now that we covered the fundamental data structures and their use cases, we learned that we can represent problems in various forms of data structure. We also covered the areas of applications where such data structures are found most crucial. And we laid out the abstract model for implementing these data structures. A fun way to explore this area of computer science is to try and implement them on your own.</p><p><em>If you want to engage on this topic with me, I’ll be posting a series on the quirky bits of implementing these data structures in detail soon so stay tuned!</em></p><hr /><h2 id="references">References</h2><ol><li>Dale, Nell; Walker, Henry M. (1996). Abstract Data Types: Specifications, Implementations, and Applications. Jones &amp; Bartlett Learning. ISBN 978–0–66940000–7.<li>Stephens, R. (2019). Essential algorithms: a practical approach to computer algorithms using Python and C. John Wiley &amp; Sons.<li>GeekforGeeks (2018). Applications of Queue Data Structure. https://www.geeksforgeeks.org/applications-of-queue-data-structure/<li>Wikipedia contributors. (2021, March 31). Binary search tree. In Wikipedia, The Free Encyclopedia. Retrieved 08:24, April 13, 2021, from https://en.wikipedia.org/w/index.php?title=Binary_search_tree&amp;oldid=1015282423<li>Becker, Georg (2008–07–18). “Merkle Signature Schemes, Merkle Trees and Their Cryptanalysis” (PDF). Ruhr-Universität Bochum. p. 16.<li>Nystrom, R. (2018). Crafting Interpreters. https://craftinginterpreters. com/[2. 8. 2020].</ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/programming/'>Programming</a>, <a href='/categories/computer-science/'>Computer Science</a>, <a href='/categories/data-structures/'>Data Structures</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/programming/" class="post-tag no-text-decoration" >programming</a> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/data-structures/" class="post-tag no-text-decoration" >Data Structures</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Elements of Programming - Dave Amiana&url=https://adeeconometrics.github.io//posts/Elements-of-Programming/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Elements of Programming - Dave Amiana&u=https://adeeconometrics.github.io//posts/Elements-of-Programming/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Elements of Programming - Dave Amiana&url=https://adeeconometrics.github.io//posts/Elements-of-Programming/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/On-Pointer-Types/">On Pointer Types</a><li><a href="/posts/Pointers-and-References-Design-Goals-and-Use-Cases/">Pointers and References: Design Goals and Use Cases</a><li><a href="/posts/Unique-Reference/">Unique References</a><li><a href="/posts/Shared-Reference/">Shared References</a><li><a href="/posts/Weak-Reference/">Weak References</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Preface-DataStructures/"><div class="card-body"> <span class="timeago small" > Aug 27, 2021 <i class="unloaded">2021-08-27T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Preface: Data Structures</h3><div class="text-muted small"><p> Introduction: Mostly about my Experience I took this course during my sophomore year in Computer Science. I am in my Junior year and I’m currently hacking on languages which I plan to build a seri...</p></div></div></a></div><div class="card"> <a href="/posts/Iterators/"><div class="card-body"> <span class="timeago small" > Aug 28, 2021 <i class="unloaded">2021-08-28T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Iterators: The link between Data Structures and Algorithms</h3><div class="text-muted small"><p> This article will introduce the need for implementing iterators in writing a maintainable and flexible data structure. Before we start the series and actually implement data structures, it is impo...</p></div></div></a></div><div class="card"> <a href="/posts/Understanding-Abstract-Data-Types/"><div class="card-body"> <span class="timeago small" > Aug 31, 2021 <i class="unloaded">2021-08-31T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Understanding Abstract Data Types</h3><div class="text-muted small"><p> This article introduces what we mean by Abstract Data Types (ADT) and its importance in developing our Data Structures Library. Abstraction is of the essence of a scalable software system. In desig...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/The-R-Language-Overview/" class="btn btn-outline-primary" prompt="Older"><p>The R Language Overview</p></a> <a href="/posts/Designing-Functions/" class="btn btn-outline-primary" prompt="Newer"><p>Designing Functions</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/iamdeb25">Dave Amiana</a>.</p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/computer-science/">Computer Science</a> <a class="post-tag" href="/tags/programming/">programming</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/data-structures/">Data Structures</a> <a class="post-tag" href="/tags/programming/">Programming</a> <a class="post-tag" href="/tags/algorithms/">Algorithms</a> <a class="post-tag" href="/tags/ownership-semantics/">Ownership Semantics</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/java/">Java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://adeeconometrics.github.io/{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
